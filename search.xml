<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AcWing 4440.照相</title>
    <url>/posts/f6c0bb1c.html</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230615231310.png" alt="Img"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>14
GGGHGHHGHHHGHG
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>1
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>在这个例子中，只需反转由前六头奶牛组成的前缀即可。
   GGGHGHHGHHHGHG （反转前）
-&gt; HGHGGGHGHHHGHG （反转后）
在反转之前，四头更赛牛处于偶数位置。
反转后，六头更赛牛处于偶数位置。不可能使得超过六头更赛牛处于偶数位置
</code></pre><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>2≤N≤2×$10^5$ ，N 为偶数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们得注意到题目中所给的条件。</p>
<ol>
<li>使得尽可能多的更塞牛处于队列中的偶数位置（即，使得尽可能多的<code>G</code>在字符串的奇数位置）</li>
<li>能让他的奶牛的<strong>偶数</strong>长的<strong>前缀</strong>进行反转</li>
</ol>
<p>由上我们可以得知，相邻的两个牛是彼此绑定的，比如样例中的<code>GGGHGHHGHHHGHG</code>，我们可以划分为<code>GG|GH|GH|HG|HH|HG|HG</code>，可以看到两种牛的组合有四种，分别是<code>GG</code>、<code>HH</code>、<code>GH</code>、<code>HG</code>，其中有两种反转不影响结果，即<code>GG</code>和<code>HH</code>。那为了达到目的，我们需要让相邻的组合除了是<code>GG</code>和<code>HH</code>之外都是<code>HG</code>。因此我们得将<code>GH</code>都进行翻转。</p>
<p>既然知道了这个，我们还得判断他怎么翻转。首先我们得知道，翻转的时候每一个位置都会发生变化，如果前<code>n</code>组的组合不一致，那么翻转之后也不一致，因此我们在翻转的时候得确保前<code>n</code>组的组合一致。</p>
<p>如果样例是<code>HGGH</code>我们如果要翻转使得更多的<code>G</code>在偶数位置，那么我们首先得翻转<code>HG</code>使得要翻转的组合是一致的。</p>
<p>由上我们可以得知翻转的特性。那么什么时候需要翻转呢？那就是相邻两组组合不一致，那么我们就要将前面的组合进行翻转变成使其变成和后面的组合一致。这样翻转就能使得字符串所有的牛的组合是一样的，最后如果组合都是<code>GH</code>，那么我们还需要对其翻转一次，使得其变成<code>HG</code></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int main()&#123;
    int n;
    string str;
    cin &gt;&gt; n;
    cin &gt;&gt; str;
    int tmp = -1, res = -1;
    for(int i = 0; i &lt; n; i += 2)&#123;
        if(str[i] == &#39;G&#39; &amp;&amp; str[i + 1] == &#39;H&#39;)&#123;
            if(tmp == -1)&#123;
                tmp = 0;
                res = 0;
            &#125;else if(tmp == 1)&#123;
                tmp = 0;
                res++;
            &#125;
        &#125;else if(str[i] == &#39;H&#39; &amp;&amp; str[i + 1] == &#39;G&#39;)&#123;
            if(tmp == -1)&#123;
                tmp = 1;
                res = 0;
            &#125;else if(tmp == 0)&#123;
                tmp = 1;
                res++;
            &#125;
        &#125;
    &#125;
    if(tmp == 0) res++;
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>夏季赛每日一题</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 4908. 饥饿的牛</title>
    <url>/posts/bdc5df1d.html</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230610103819.png" alt="Img"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>2 5
1 10
5 10
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>5
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>10捆干草在第 1
天早上被送到了牛棚，所以贝茜第 1∼5天都有干草吃。
</code></pre><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>1 ≤ N ≤ $10^5$</li>
<li>1 ≤ T ≤ $10^{14}$</li>
<li>1 ≤ $d_i$ ≤ $10^{14}$</li>
<li>1 ≤ $b_i$ ≤ $10^9$</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到时间有序，那么我们只要从前往后遍历即可，然后在遍历的时候维护当前干草最多能支撑牛吃到什么时候。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-C++">#include&lt;iostream&gt;

using namespace std;

const int maxn = 1e5 + 10;

int main()&#123;
    long long N, T;
    scanf(&quot;%lld %lld&quot;, &amp;N, &amp;T);

    long long res = 0, days = 0;

    while(N--)&#123;
        long long b, d;
        scanf(&quot;%lld %lld&quot;, &amp;d, &amp;b);
        if(d &gt; days)&#123;   // 如果当前时间大于干草支撑的时间
            days = d + b - 1;   // -1是因为d这一天也要吃一份
        &#125;else&#123;
            days += b;
        &#125;
        res += b;
        if(days &gt;= T)&#123;  // 如果已经到T时间了，后面就没必要继续计算
            res -= (days - T);
            break;
        &#125;
    &#125;

    printf(&quot;%lld\n&quot;, res);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>夏季赛每日一题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 4741.魔法百合井</title>
    <url>/posts/29f70fcd.html</url>
    <content><![CDATA[<h1 id="AcWing-4741-魔法百合井"><a href="#AcWing-4741-魔法百合井" class="headerlink" title="AcWing 4741.魔法百合井"></a>AcWing 4741.魔法百合井</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting@main/mini/202307222129681.png" alt="image-20230722212959647"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>2
5
20
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>Case #1: 5
Case #2: 15
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>对于 Case 1，井中一共有 5 朵百合花。
最佳方案是一个接一个的连续向井中投入 5 个硬币，这样我们可以一个接一个的得到 5 朵百合花。
一共需要花费 5 个硬币。
对于 Case 2，井中一共有 15 朵百合花。
</code></pre><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>1 $\le$ T $\le$ 100</li>
<li>1 $\le$ L $\le$ $10^5$ </li>
</ul>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>刚开始我的想法是dp，但是我一开始想的是n个硬币能买多少话，这样做比较麻烦，因为最后还需要利用二分来查找想要买m朵花需要几个硬币。</p>
<p>后面转换了思路，即，计算要买m朵花需要几个硬币。<code>dp[花的数量] = 硬币的数量</code></p>
<p>有题目我们可以知道买花的方案主要有以下三个</p>
<ol>
<li>一个硬币换一朵花</li>
<li>四个硬币记录当前有多少花</li>
<li>二个硬币换上次记录的花的数量</li>
</ol>
<p>由上面三个方案我们可以得知</p>
<ol>
<li>第三个方案一定得在第二个方案后面，如果没有第二个方案，那么第三个方案一直用二个硬币换0朵花</li>
<li>第二个方案后面可以跟很多个第三个方案</li>
<li>在第二个方案后面，第一个方案不影响第三个方案，因此可以穿插着来</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

const int INF = 1e9 + 7;
const int maxn = 1e5 + 10;
int dp[maxn];

void init()&#123;
    memset(dp, INF, sizeof(dp));
    dp[0] = 0;
    for(int i = 1; i &lt; maxn; i++)&#123;
        dp[i] = std::min(dp[i - 1] + 1, dp[i]);
        for(int j = i + i, k = 1; j &lt; maxn; j += i, k++)&#123;    // 该for循环我们默认dp[i]的时候用了四个硬币记录当前的花树
            dp[j] = std::min(dp[j], dp[i] + 2 * k + 4);
        &#125;
    &#125;
&#125;

int main()&#123;
    init();
    int T, idx = 0;
    std::cin &gt;&gt; T;
    while(T--)&#123;
        int n;
        std::cin &gt;&gt; n;
        std::cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++idx &lt;&lt; &quot;: &quot; &lt;&lt; dp[n] &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>夏季赛每日一题</category>
      </categories>
      <tags>
        <tag>Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++初识</title>
    <url>/posts/6a30773a.html</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员阅读代码</li>
<li><p><strong>两种格式</strong>：</p>
<ul>
<li><p>单行注释：<code>// 描述信息</code></p>
<p>  通常放在一行代码的上方，或者一条语句的末尾。 对该行代码说明</p>
</li>
<li><p>多行注释：<code>/* 描述信息 */</code></p>
<p>  通常放在一段代码的上方。对该段代码做整体说明</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：编译器在做编译代码时，会忽略注释的内容。</p>
</blockquote>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内容</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p>示例：</p>
<pre><code class="lang-cpp">#include&lt;iostream&gt;
using namespace std;

int main()&#123;
    //变量的定义
    //语法： 数据类型 变量名 = 初始值;

    int a = 10;
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    return EXIT_SUCCESS;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323131712.png" alt=""></p>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错（如果你在全局定义的时候他会有默认值，在局部定义不调用也不会报错，所以这段话不严谨）</p>
</blockquote>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式：</p>
<ul>
<li><h1 id="define宏常量：-define-常量名-常量值"><a href="#define宏常量：-define-常量名-常量值" class="headerlink" title="define宏常量： #define 常量名 常量值"></a>define宏常量： <code>#define 常量名 常量值</code></h1><ul>
<li>通常在文件上方定义，表示一个常量</li>
</ul>
</li>
<li>const修饰的变量： <code>const 数据类型 常量名 = 常量值</code><ul>
<li>通常在变量定义前加关键字const，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ul>
<p>示例</p>
<pre><code class="lang-cpp">//1、宏常量
#define day 7

int main()&#123;
    cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl;
    //day = 8; //报错，宏常量不可修改

    //2、const修饰变量
    const int month = 12;
    cout &lt;&lt; &quot;&quot; &lt;&lt; month &lt;&lt; &quot;&quot; &lt;&lt; endl;
    //month = 24; //报错，常量是不可以修改的

    return EXIT_SUCCESS;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323131825.png" alt=""></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>作用</strong>：关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li>在定义变量或者常量时，不能使用关键字</li>
</ul>
<p>C++关键字如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：在给变量或者常量起名称时，不要用C++的关键字，否则会产生歧义</p>
</blockquote>
<h2 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h2><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++数据类型</title>
    <url>/posts/1b32398c.html</url>
    <content><![CDATA[<p>C++规定在创建一个变量或者常量时，必须要指定出相关的数据类型，否则无法给变量分配内存。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><strong>作用</strong>：整型变量表示的是<em>整数类型</em>的数据。</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h2><p><strong>作用</strong>：利用sizeof关键字可以统计<em>数据类型所占内存大小</em></p>
<p><strong>语法</strong>：<code>sizeof(数据类型/变量);</code></p>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;
    cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;
    cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;
    cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;
    cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132129.png" alt=""></p>
<blockquote>
<p>整型结论：short &lt; int ≤ long ≤ long long</p>
</blockquote>
<h2 id="实型（浮点型）"><a href="#实型（浮点型）" class="headerlink" title="实型（浮点型）"></a>实型（浮点型）</h2><p><strong>作用</strong>：用于<em>表示小数</em></p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度 float</li>
<li>双精度 double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;

    float f1 = 3.14f;
    double d1 = 3.14;

    cout &lt;&lt; f1 &lt;&lt; endl;
    cout &lt;&lt; d1&lt;&lt; endl;

    cout &lt;&lt; &quot;float  sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl;
    cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl;

    //科学计数法
    float f2 = 3e2; // 3 * 10 ^ 2 
    cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;

    float f3 = 3e-2;  // 3 * 0.1 ^ 2
    cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132209.png" alt=""></p>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p><strong>作用</strong>：字符型变量用于显示单个字符</p>
<p><strong>语法</strong>：<code>char ch = ‘a’;</code></p>
<blockquote>
<p>注意1：在现实字符型变量时，用单引号将字符括起来，而不是双引号</p>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用<em>一个字节</em></li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例</p>
<pre><code class="lang-cpp">int main() &#123;

    char ch = &#39;a&#39;;
    cout &lt;&lt; ch &lt;&lt; endl;
    cout &lt;&lt; sizeof(char) &lt;&lt; endl;

    //ch = &quot;abcde&quot;; //错误，不可以用双引号
    //ch = &#39;abcde&#39;; //错误，单引号内只能引用一个字符

    cout &lt;&lt; (int)ch &lt;&lt; endl;  //查看字符a对应的ASCII码
    ch = 97; //可以直接用ASCII给字符型变量赋值
    cout &lt;&lt; ch &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132240.png" alt=""></p>
<p>ASCII码表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>字符</th>
<th>ASCII值</th>
<th>字符</th>
<th>ASCII值</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
</div>
<p>ASCII码大致由以下<strong>两部分</strong>组成：</p>
<ul>
<li>ASCII非打印控制字符：ASCII表上的数字<strong>0-31</strong>分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII打印字符：数字<strong>32-126</strong>分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p><strong>作用</strong>：用于表示一些<em>不能显示出来的ASCII字符</em></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT)  （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\\\\</td>
<td>代表一个反斜线字符”\”</td>
<td>092</td>
</tr>
<tr>
<td>\’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>\”</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0~9，a~f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;


    cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\tHello&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\n&quot; &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>：<code>char 变量名[] = “字符串值”;</code></p>
<p> 示例</p>
<pre><code class="lang-cpp"> int main()&#123;
     char str1[] = &quot;hello world&quot;;
     chout &lt;&lt; str1 &lt;&lt; endl;

     return EXIT_SUCCESS;
 &#125;
</code></pre>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132314.png" alt=""></p>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
</li>
<li><p><strong>C++风格字符串</strong>：<code>string 变量名 = “字符串常量值”;</code></p>
<p> 示例</p>
<pre><code class="lang-cpp"> int main()&#123;
     string str = &quot;hello world&quot;;
     cout &lt;&lt; str &lt;&lt; endl;

     return EXIT_SUCCESS;
 &#125;
</code></pre>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132357.png" alt=""></p>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件 <em>#include<string></em></p>
</blockquote>
</li>
</ol>
<h2 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型 bool"></a>布尔类型 bool</h2><p><strong>作用</strong>：布尔数据类型代表真或假的值</p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  ——— 真（本质是1）</li>
<li>false ——— 假（本质是0）</li>
</ul>
<p>bool类型占<em>1个字节</em>大小</p>
<p>示例</p>
<pre><code class="lang-cpp">int main() &#123;

    bool flag = true;
    cout &lt;&lt; flag &lt;&lt; endl; // 1

    flag = false;
    cout &lt;&lt; flag &lt;&lt; endl; // 0

    cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132426.png" alt=""></p>
<h2 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h2><p><strong>作用</strong>：用于从键盘获取数据</p>
<p><strong>关键字</strong>：cin</p>
<p><strong>语法</strong>：<code>cin &gt;&gt; 变量;</code></p>
<p>示例</p>
<pre><code class="lang-cpp">int main()&#123;

    //整型输入
    int a = 0;
    cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;
    cin &gt;&gt; a;
    cout &lt;&lt; a &lt;&lt; endl;

    //浮点型输入
    double d = 0;
    cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;
    cin &gt;&gt; d;
    cout &lt;&lt; d &lt;&lt; endl;

    //字符型输入
    char ch = 0;
    cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;
    cin &gt;&gt; ch;
    cout &lt;&lt; ch &lt;&lt; endl;

    //字符串型输入
    string str;
    cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;
    cin &gt;&gt; str;
    cout &lt;&lt; str &lt;&lt; endl;

    //布尔类型输入
    bool flag = true;
    cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;
    cin &gt;&gt; flag;
    cout &lt;&lt; flag &lt;&lt; endl;
    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132645.png" alt=""></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>作用</strong>：用于执行代码的运算</p>
<p>本章主要讲解以下几类运算符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><strong>作用</strong>：用于处理四则运算</p>
<p>算数运算符包括以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>—</td>
<td>前置递减</td>
<td>a=2; b=—a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>—</td>
<td>后置递减</td>
<td>a=2; b=a—;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
</div>
<p>示例1：</p>
<pre><code class="lang-cpp">int main() &#123;

    int a1 = 10;
    int b1 = 3;

    cout &lt;&lt; a1 + b1 &lt;&lt; endl;
    cout &lt;&lt; a1 - b1 &lt;&lt; endl;
    cout &lt;&lt; a1 * b1 &lt;&lt; endl;
    cout &lt;&lt; a1 / b1 &lt;&lt; endl;  //两个整数相除结果依然是整数

    int a2 = 10;
    int b2 = 20;
    cout &lt;&lt; a2 / b2 &lt;&lt; endl; 

    int a3 = 10;
    int b3 = 0;
    //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0

    //两个小数可以相除
    double d1 = 0.5;
    double d2 = 0.25;
    cout &lt;&lt; d1 / d2 &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132721.png" alt=""></p>
<blockquote>
<p>总结：在除法运算中，除数不能为0（这应该算是小学数学了吧）</p>
</blockquote>
<p>示例2：</p>
<pre><code class="lang-cpp">//取模
int main() &#123;

    int a1 = 10;
    int b1 = 3;

    cout &lt;&lt; 10 % 3 &lt;&lt; endl;

    int a2 = 10;
    int b2 = 20;

    cout &lt;&lt; a2 % b2 &lt;&lt; endl;

    int a3 = 10;
    int b3 = 0;

    //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0

    //两个小数不可以取模
    double d1 = 3.14;
    double d2 = 1.1;

    //cout &lt;&lt; d1 % d2 &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132756.png" alt=""></p>
<blockquote>
<p>只有整型变量可以进行取模运算</p>
</blockquote>
<p>示例3：</p>
<pre><code class="lang-cpp">//递增
int main() &#123;

    //后置递增
    int a = 10;
    a++; //等价于a = a + 1
    cout &lt;&lt; a &lt;&lt; endl; // 11

    //前置递增
    int b = 10;
    ++b;
    cout &lt;&lt; b &lt;&lt; endl; // 11

    //区别
    //前置递增先对变量进行++，再计算表达式
    int a2 = 10;
    int b2 = ++a2 * 10;
    cout &lt;&lt; b2 &lt;&lt; endl;

    //后置递增先计算表达式，后对变量进行++
    int a3 = 10;
    int b3 = a3++ * 10;
    cout &lt;&lt; b3 &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132832.png" alt=""></p>
<blockquote>
<p>总结：前置递增先对变量进行++再进行计算表达式，后置递增相反</p>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>作用</strong>：用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;

    //赋值运算符

    // =
    int a = 10;
    a = 100;
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    // +=
    a = 10;
    a += 2; // a = a + 2;
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    // -=
    a = 10;
    a -= 2; // a = a - 2
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    // *=
    a = 10;
    a *= 2; // a = a * 2
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    // /=
    a = 10;
    a /= 2;  // a = a / 2;
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    // %=
    a = 10;
    a %= 2;  // a = a % 2;
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323132905.png" alt=""></p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><strong>作用</strong>：用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>></td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>>=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：C和C++语言的比较运算中，<em>“真”用数字“1”表示，“假”用数字“0”来表示</em></p>
</blockquote>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>作用</strong>：用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>术语</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>或</td>
<td>a</td>
<td></td>
<td>b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++对象模型和this指针</title>
    <url>/posts/c9c3276d.html</url>
    <content><![CDATA[<h2 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h2><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<pre><code class="lang-cpp">class Person &#123;
public:
    Person() &#123;
        mA = 0;
    &#125;
    //非静态成员变量占对象空间
    int mA;
    //静态成员变量不占对象空间
    static int mB; 
    //函数也不占对象空间，所有函数共享一个函数实例
    void func() &#123;
        cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;
    &#125;
    //静态成员函数也不占对象空间
    static void sfunc() &#123;
    &#125;
&#125;;

int main() &#123;

    cout &lt;&lt; sizeof(Person) &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h2><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是，这一块代码是如何区分那个对象调用自己的呢？</p>
<p>C++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可以用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<pre><code class="lang-cpp">class Person&#123;
public:

    Person(int age)    &#123;
        //1、当形参和成员变量同名时，可用this指针来区分
        this-&gt;age = age;
    &#125;

    Person&amp; PersonAddPerson(Person p)    &#123;
        this-&gt;age += p.age;
        //返回对象本身
        return *this;
    &#125;

    int age;
&#125;;

void test01()&#123;
    Person p1(10);
    cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl;

    Person p2(10);
    p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
    cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2><p>C++中空指针也可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<pre><code class="lang-cpp">//空指针访问成员函数
class Person &#123;
public:
    void ShowClassName() &#123;
        cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;
    &#125;

    void ShowPerson() &#123;
        if (this == NULL) &#123;
            return;
        &#125;
        cout &lt;&lt; mAge &lt;&lt; endl;
    &#125;

public:
    int mAge;
&#125;;

void test01()&#123;
    Person * p = NULL;
    p-&gt;ShowClassName(); //空指针，可以调用成员函数
    p-&gt;ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h2><p><strong>常函数</strong>：</p>
<ul>
<li>成员函数加const后我们称这个函数为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person &#123;
public:
    Person() &#123;
        m_A = 0;
        m_B = 0;
    &#125;

    //this指针的本质是一个指针常量，指针的指向不可修改
    //如果想让指针指向的值也不可以修改，需要声明常函数
    void ShowPerson() const &#123;
        //const Type* const pointer;
        //this = NULL; //不能修改指针的指向 Person* const this;
        //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的

        //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
        this-&gt;m_B = 100;
    &#125;

    void MyFunc() const &#123;
        //mA = 10000;
    &#125;

public:
    int m_A;
    mutable int m_B; //可修改 可变的
&#125;;

//const修饰对象  常对象
void test01() &#123;

    const Person person; //常量对象  
    cout &lt;&lt; person.m_A &lt;&lt; endl;
    //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
    person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

    //常对象访问成员函数
    person.MyFunc(); //常对象不能调用const的函数

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>Java 运行机制</title>
    <url>/posts/840dc5ee.html</url>
    <content><![CDATA[<h1 id="Java运行机制"><a href="#Java运行机制" class="headerlink" title="Java运行机制"></a>Java运行机制</h1><h2 id="Java运行的一般步骤是"><a href="#Java运行的一般步骤是" class="headerlink" title="Java运行的一般步骤是"></a>Java运行的一般步骤是</h2><ol>
<li>Java首先利用文本编辑器编写Java源程序，源文件的后缀名为.java;</li>
<li>再利用编译器（javac）将源程序编译成字节码，字节码文件的后缀名为.class;</li>
<li>最后利用虚拟机（解释器，Java）解释执行。如下图所示</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160450.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160702.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160716.png" alt=""></p>
<h2 id="JVM、JRE和JDK三者的不同"><a href="#JVM、JRE和JDK三者的不同" class="headerlink" title="JVM、JRE和JDK三者的不同"></a>JVM、JRE和JDK三者的不同</h2><p><strong>JVM</strong>(Java Virtual Machine):用于执行bytecode字节码的“虚拟计算机”；</p>
<p>不同的操作系统有不同版本的JVM，屏蔽了底层运行平台的差别，是实现跨平台的核心。</p>
<p><strong>JRE</strong>(Java Runtime Environment),它包含了Java虚拟机(JVM)、库函数等。</p>
<p><strong>JDK</strong>(Java Development Kit)包含了JRE，编译器和调试器等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320161326.png" alt=""></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O管理与磁盘调度</title>
    <url>/posts/7434cf9c.html</url>
    <content><![CDATA[<h2 id="I-O缓冲"><a href="#I-O缓冲" class="headerlink" title="I/O缓冲"></a>I/O缓冲</h2><p><strong>缓冲技术</strong>：在输入请求发出之前就开始执行输入传送，并且在输出请求发出一段时间之后才开始执行输出传送，这项技术称为缓冲</p>
<p>两类I/O设备：</p>
<ul>
<li><strong>面向块的I/O设备</strong>：将信息保存在块中，块的大小通常是固定的，传送过程中一次传送一块</li>
<li><strong>面向块的I/O设备</strong>：将信息保存在块中，块的大小通常是固定的，传送过程中一次传送一块</li>
</ul>
<h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519133222.png" alt="Img"></p>
<p><strong>对于面向块的I/O设备</strong>：</p>
<ul>
<li>对于面向块的I/O设备：</li>
<li>相对于无缓冲的情况，这种方法通常会提高系统速度。用户进程可以在下一数据块读取的同时，处理已读入的数据块。由于输入发生在系统内存中而非用户进程内存中，因此操作系统可以将该进程换出</li>
</ul>
<p><strong>对于面向流的I/O设备</strong>：</p>
<p>单缓冲方案能以每次传送一行的方式或者每次传送一个字节的方式使用</p>
<h3 id="双缓冲-缓冲交换"><a href="#双缓冲-缓冲交换" class="headerlink" title="双缓冲(缓冲交换)"></a>双缓冲(缓冲交换)</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519133353.png" alt="Img"></p>
<p>分配2个缓冲区。在一个进程往一个缓冲区中传送数据(从这个缓冲区中取数据)的同时，操作系统正在清空(或者填充)另一个缓冲区</p>
<h3 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519133429.png" alt="Img"></p>
<p>双缓冲方案可以平滑I/O设备和进程之间的数据流。如果关注的焦点是某个特定进程的性能，那么常常会希望相关I/O操作能够跟得上这个进程。如果该进程需要爆发式地执行大量的I/O操作，仅有双缓冲就不够了，在这种情况下，通常使用多于两个的缓冲区方案来缓解不足</p>
<h3 id="I-O缓冲的作用"><a href="#I-O缓冲的作用" class="headerlink" title="I/O缓冲的作用"></a>I/O缓冲的作用</h3><p>I/O缓冲是用来平滑I/O需求的峰值的一种技术，但是当进程的平均需求大于I/O设备的服务能力时，缓冲再多也不能让I/O设备与这个进程一直并驾齐驱。即使有多个缓冲区，所有的缓冲区终将会被填满，进程在处理完每一大块数据后不得不等待。但是，在多道程序设计环境中，当存在多种I/O活动和多种进程活动时，缓冲是提高操作系统效率和单个进程性能的一种方法</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><h3 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h3><ul>
<li><strong>寻道时间</strong>：磁头定位到磁道所需的时间</li>
<li><strong>旋转延迟</strong>：选好磁道后，磁头到达扇区开始位置的时间</li>
<li><strong>存取时间</strong>：寻道时间+旋转延迟</li>
<li><strong>传输时间</strong>：磁头定位到扇区开始位置后，数据读写的时间</li>
<li><strong>排队时间</strong></li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>在多道程序环境中，操作系统为每个I/O设备维护一个请求队列。因此对一个磁盘，队列中可能有来自多个进程的许多I/O请求。如果随机地从队列中选择请求，那么磁道完全是被随机访问的，这种情况下性能最差。随机调度可用于与其他调度算法进行对比</p>
<h4 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出(FIFO)"></a>先进先出(FIFO)</h4><ul>
<li>按顺序处理队列中的请求</li>
<li>如果有大量进程竞争一个磁盘，这种算法在性能上往往接近于随机调度</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li>这种方法不会优化磁盘利用率，但可以满足操作系统的其它目标</li>
<li>这种方法不会优化磁盘利用率，但可以满足操作系统的其它目标</li>
<li>可能会导致部分用户采用对抗手段：把作业分成小块，以回应系统的这种策略。对于数据库系统，这种算法往往性能较差</li>
</ul>
<h4 id="最短服务时间优先-SSTF"><a href="#最短服务时间优先-SSTF" class="headerlink" title="最短服务时间优先(SSTF)"></a>最短服务时间优先(SSTF)</h4><ul>
<li>选择使磁头臂从当前位置开始移动最少(最小寻道时间)的磁盘I/O请求</li>
<li>但是，总是选择最小寻道时间并不能保证平均寻道时间最小，不过能提供比FIFO更好的性能</li>
<li>磁头臂可以沿两个方向移动</li>
</ul>
<h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><ul>
<li>运行类似电梯。磁头臂沿某一方向移动，并在途中满足所有未完成请求，直到到达最后一个磁道，或者该方向上没有更多请求。接着反转服务方向</li>
<li>偏向接近最靠里或最靠外的磁道的请求，并且偏向最近的请求，可能发生饥饿</li>
</ul>
<h4 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h4><ul>
<li>沿某个方向的扫描结束后，返回到相反方向的末端，再次扫描</li>
<li>减少了新请求的最大延迟</li>
<li>可能饥饿</li>
</ul>
<h4 id="N-step-SCAN-N步扫描"><a href="#N-step-SCAN-N步扫描" class="headerlink" title="N-step-SCAN(N步扫描)"></a>N-step-SCAN(N步扫描)</h4><p>SSTF、SCAN和C-SCAN可能在一段很长时间内磁头臂都不会移动(比如一个或多个进程对一个磁道有较高的访问速度，通过重复的请求这个磁道垄断整个设备)，从而饥饿其它请求</p>
<ul>
<li>把请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列。在处理一个子队列时，新请求必须添加到其它某个队列中</li>
<li>对于比较大的N值，性能接近SCAN；当N=1时，实际上就是FIFO</li>
</ul>
<h3 id="磁盘调度算法比较"><a href="#磁盘调度算法比较" class="headerlink" title="磁盘调度算法比较"></a>磁盘调度算法比较</h3><p>假设有一些I/O请求，需问这些磁道：55、58、39、18、90、160、150、38、184</p>
<p>使用不同磁盘调度算法的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519134030.png" alt="Img"></p>
<h2 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h2><p>一个磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，它包含有磁盘中某些扇区的副本。当出现一个请求某一特定扇区的I/O请求时，首先进行检查，以确定该扇区是否在磁盘高速缓存中。如果在，则该请求可以通过这个高速缓存来满足；如果不在，则把请求的扇区从磁盘读到磁盘高速缓存中</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 1003.检查替换后的词是否有效</title>
    <url>/posts/5afd8342.html</url>
    <content><![CDATA[<h2 id="1003-检查替换后的词是否有效"><a href="#1003-检查替换后的词是否有效" class="headerlink" title="1003.检查替换后的词是否有效"></a><strong><a href="https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/description/">1003.检查替换后的词是否有效</a></strong></h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230503132845.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">s = &quot;aabcbc&quot;
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">true
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">&quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;aabcbc&quot;
因此，&quot;aabcbc&quot; 有效。
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>1 &lt;= s.length &lt;= 2 * 1e4</code></li>
<li><code>s</code> 由字母 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 组成</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题其实是和括号匹配是类似的，只不过现在是由<code>()</code>变成了<code>”abc”</code>。我们可以想想如果是<code>()</code>的话应该怎么解决。通常的做法都是使用栈来做，我们每碰见一个<code>(</code>时，我们就将左括号压入堆栈中，直到遇到<code>)</code>才取出栈顶的左括号进行匹配。这里也是一样，我们遇见<code>’a’</code>时将字符压入堆栈中，遇到字符<code>’b’</code>时查看栈顶是否为<code>’a’</code>，如果不为<code>’a’</code>，那么说明字符串无法匹配。相同的时，如果我们遇到字符<code>’c’</code>时，我们就得查看前两个字符是<code>”ab”</code>，如果不是则无法匹配。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码有两个版本，第一个版本正确省事，但是剪枝效果并不怎么好，因为如果我们遇到<code>b</code>时没有判断这个<code>b</code>是否合法。这个版本的耗时时12ms</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    bool isValid(string s) &#123;
        string str;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            if(s[i] == &#39;c&#39;)&#123;
                if(str.size() &lt; 2) return false;
                if(str.substr(str.size() - 2, 2) != &quot;ab&quot;) return false;
                else &#123;
                    str.pop_back();
                    str.pop_back();
                &#125;
            &#125;else&#123;
                str += s[i];
            &#125;
        &#125;
        if(str.empty()) return true;
        return false;
    &#125;
&#125;;
</code></pre>
<p>这个版本我们验证字符<code>b</code>是否合法，在这一基础上剪枝效果显著，耗时优化到了8ms</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    bool isValid(string s) &#123;
        string str;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            if(s[i] == &#39;c&#39;)&#123;
                if(str.size() &lt; 2) return false;
                if(str.substr(str.size() - 2, 2) != &quot;ab&quot;) return false;
                else &#123;
                    str.pop_back();
                    str.pop_back();
                &#125;
            &#125;else if(s[i] == &#39;b&#39;)&#123;
                if(str.empty()) return false;
                if(str.back() != &#39;a&#39;) return false;
                str += &#39;b&#39;;
            &#125;else str += &#39;a&#39;;
        &#125;
        if(str.empty()) return true;
        return false;
    &#125;
&#125;;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 1023.驼峰式匹配</title>
    <url>/posts/3effc393.html</url>
    <content><![CDATA[<h1 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023.驼峰式匹配"></a><strong><strong><a href="https://leetcode.cn/problems/camelcase-matching/description/">1023.驼峰式匹配</a></strong></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230414105634.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">[true,false,true,true,false]
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。
&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.
&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ol>
<li><code>1 &lt;= queries.length &lt;= 100</code></li>
<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>
<li><code>1 &lt;= pattern.length &lt;= 100</code></li>
<li>所有字符串都仅由大写和小写英文字母组成。</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意题目中，只能将小写字母插入模式串<code>pattern</code>，如果是大写的，那么说明不能匹配，返回<code>false</code>。那我们需要先扫一遍比较两个字符串的大写字母是否相同吗？答案是不需要，我们只要扫一遍就好了。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们将<code>queries</code>中的字符串与<code>pattern</code>进行一一比较，如果两个字符串对应的索引的字符相同，那么<code>pattern</code>的索引就<code>+1</code>，如果遇到字符不相同且<code>queries[i]</code>上的字符是大写字母时，那就返回<code>false</code>。注意，还有一种情况也是要返回<code>false</code>，即扫完一边<code>queries[i]</code>之后，我们的<code>pattern</code>字符串没有扫到最后一位，那么说明不管怎么在<code>pattern</code>中插入字符，都不可能变成<code>queries[i]</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;bool&gt; camelMatch(vector&lt;string&gt;&amp; queries, string pattern) &#123;
        int len = queries.size();
        vector&lt;bool&gt; res(len);
        for(int i = 0; i &lt; len; i++)&#123;
            int idx = 0;
            bool flag = true;
            for(int j = 0; j &lt; queries[i].size(); j++)&#123;
                if(idx &lt; pattern.size() &amp;&amp; queries[i][j] == pattern[idx]) ++idx;
                else if(queries[i][j] &lt;= &#39;Z&#39;) flag = false;
            &#125;
            if(idx != pattern.size()) flag = false;
            res[i] = flag;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1026.节点与其祖先之间的最大差值</title>
    <url>/posts/98792e2b.html</url>
    <content><![CDATA[<h1 id="1026-节点与其祖先之间的最大差值"><a href="#1026-节点与其祖先之间的最大差值" class="headerlink" title="1026.节点与其祖先之间的最大差值"></a><strong><a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/">1026.节点与其祖先之间的最大差值</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230418221658.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">root = [8,3,10,1,6,null,14,null,null,4,7,13]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">7
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230418221818.png" alt=""></p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>树中的节点数在 <code>2</code> 到 <code>5000</code> 之间。</li>
<li><code>0 &lt;= Node.val &lt;= 1e5</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通常树上操作我们都需要进行递归，那么我们想想这道题能不能用递归做。</p>
<p>因为我们要搜索所有的节点与它的祖先之间的差值，那么我们需要用dfs来遍历所有的节点，因此递归是可以做的。</p>
<p>那么问题来了，既然递归可以，那么我们怎么做呢？因为现在的问题是我们如果用平常的递归的话，每次计算差值我们难道需要返回去获得每一个祖先节点的值吗？</p>
<p>其实不用，我们可以用两个变量当作参数传入函数，这两个变量分别存储遍历到这个节点时所有的节点的val值的最大值和最小值，因此我们计算每个节点与祖先节点的差值的时候只要与这两个值进行做差即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    void dfs(TreeNode* root, int maxx, int minn, int *ans)&#123;
        if(root == nullptr) return;
        *ans = max(*ans, max(abs(root-&gt;val - maxx), abs(root-&gt;val - minn)));
        maxx = max(maxx, root-&gt;val);
        minn = min(minn, root-&gt;val);
        dfs(root-&gt;left, maxx, minn, ans);
        dfs(root-&gt;right, maxx, minn, ans);
    &#125;

    int maxAncestorDiff(TreeNode* root) &#123;
        if(root == nullptr) return 0;
        int ans = 0;
        int maxx = root-&gt;val, minn = root-&gt;val;
        dfs(root-&gt;left, maxx, minn, &amp;ans);
        dfs(root-&gt;right, maxx, minn, &amp;ans);
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Daily</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1053.交换一次的先前排列</title>
    <url>/posts/bee70a74.html</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230403182351.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">arr = [1,1,5]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">[1,1,5]
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">已经是最小排列
</code></pre>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><code>1 &lt;= arr.length &lt;= 1e4</code></li>
<li><code>1 &lt;= arr[i] &lt;= 1e4</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目的意思，就是找到该数组的字典序的上一个，如果这个数组已经是从小到大排列的有序数组，那么说明已经是最小了，那么就没有比这个更小的数，因此返回原数组，那么其它情况呢？我们只要从后往前找，每找一个数num的时候，就往后遍历，往后遍历的时候我们找到替换的数的要求有以下几点：</p>
<ol>
<li>数字比num小</li>
<li>该数比其它小于num的数要大</li>
<li>如果有多个相同的数，选择最近的那个</li>
</ol>
<p>如果有满足以上几点的数，那就将这个数与num进行交换。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; arr) &#123;
        int len = arr.size();
        for(int i = len - 2; i &gt;= 0; i--)&#123;
            int flag = -1, tmp = arr[i];
            for(int j = i + 1; j &lt; len; j++)&#123;
                if(tmp &gt; arr[j] &amp;&amp; flag == -1)&#123;
                    flag = j;
                    tmp = arr[j];
                &#125;else if(tmp &lt; arr[j] &amp;&amp; arr[i] &gt; arr[j])&#123;
                    flag = j;
                    tmp = arr[j];
                &#125;
            &#125;
            if(flag != -1)&#123;
                swap(arr[i], arr[flag]);
                return arr;
            &#125;
        &#125;
        return arr;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1170.比较字符串最小字母出现频次</title>
    <url>/posts/348193db.html</url>
    <content><![CDATA[<h1 id="LeetCode-1170-1432"><a href="#LeetCode-1170-1432" class="headerlink" title="LeetCode-1170(1432)"></a>LeetCode-1170(1432)</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230610104927.png" alt="Img"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>[1,2]
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>第一个查询 f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;)，第二个查询 f(&quot;aaa&quot;) 和 f(&quot;aaaa&quot;) 都 &gt; f(&quot;cc&quot;)。
</code></pre><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>1 &lt;= queries.length &lt;= 2000</li>
<li>1 &lt;= words.length &lt;= 2000</li>
<li>1 &lt;= queries[i].length, words[i].length &lt;= 10</li>
<li>queries[i][j]、words[i][j] 都由小写英文字母组成</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题有几个必要条件得获取</p>
<ul>
<li><code>words</code>中每个单词<code>word</code>的<code>f(word)</code>的值得知道</li>
<li><code>queries</code>中每个单词<code>query</code>的<code>f(query)</code>的值也得知道</li>
</ul>
<p>这两个条件大家的时间复杂度应该都是一样的，$O(nm)$，其中，<code>n</code>是字符串数组的长度，<code>m</code>是字符串长度。</p>
<p>那么我们获取上面的之后应该怎么快速的获得<code>query</code>对应的值呢？有一种暴力解法就是每获取一个<code>query</code>的<code>f</code>值，我们就对比一边所有的<code>f(word)</code>的值，然后输出结果，但是这样的事件复杂度为$O(n^2)$，时间复杂度偏高。</p>
<p>但是我们可以换个思路来做这道题。如果<code>f(words)</code>是有序的，这道题就可以变成查询每个<code>f(query)</code>插入<code>f(words)</code>中的位置，那么我们一般怎么求位置呢？用二分，我们可以用二分的方法来确定<code>f(query)</code>对应的位置。根据这样的方法，排序的时间复杂度为$O(nlogn)$，二分的时间复杂度为$O(nlogn)$，总的时间复杂度为$O(nlogn)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-C++">class Solution &#123;
public:
    int f(string s)&#123;
        int res = 1, idx = 0;
        for(int i = 1; i &lt; s.size(); i++)&#123;
            if(s[i] == s[idx]) res++;
            else if(s[i] &lt; s[idx])&#123;
                res = 1;
                idx = i;
            &#125;
        &#125;
        return res;
    &#125;

    int binary_search(vector&lt;int&gt; &amp;arr, int target)&#123;
        int left = -1, right = arr.size();
        while(left + 1 &lt; right)&#123;
            int mid = (left + right) &gt;&gt; 1;
            if(arr[mid] &lt;= target) left = mid;
            else right = mid;
        &#125;
        return left + 1;
    &#125;

    vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) &#123;
        int len_queries = queries.size(), len_words = words.size();
        vector&lt;int&gt; res(len_queries, 0);
        vector&lt;int&gt; f_queries(len_queries, 0), f_words(len_words, 0);
        for(int i = 0; i &lt; len_queries; i++) f_queries[i] = f(queries[i]);
        for(int i = 0; i &lt; len_words; i++) f_words[i] = f(words[i]);

        sort(f_words.begin(), f_words.end());
        for(int i = 0; i &lt; len_queries; i++)&#123;
            res[i] = len_words - binary_search(f_words, f_queries[i]);
        &#125;

        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1171.从链表中删去总和值为零的连续节点</title>
    <url>/posts/e00fa290.html</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230611223436.png" alt="Img"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>head = [1,2,-3,3,1]
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>[3,1]
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>答案 [1,2,1] 也是正确的。
</code></pre><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>给你的链表中可能有 1 到 1000 个节点。</li>
<li>对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们怎么快速找到一段总和为<code>0</code>的连续区间呢？一般的做法就是用两个<code>for</code>循环遍历数组，然后计算，但是这样的时间复杂度为$O(n^2)$，当数组长度过大时，就会导致时间超限。那么我们可以怎么做呢？</p>
<p>我们可以利用前缀和的思想，在一个前缀和的数组中，如果数组中有两个数相等，索引分别是<code>first</code>,<code>last</code>，那么在<code>(first, last]</code>这个区间内的所有数之和为<code>0</code>。这是为什么呢？</p>
<p>假设现在有一个前缀和数组<code>num</code>，<code>num[first] = num[right]</code>，<code>num[first]</code>代表的是<code>[0, first]</code>区间的数之和，<code>num[last]</code>代表的是<code>[0, last]</code>区间的数之和。那么<code>num[last] - num[first]</code>代表的就是区间<code>(first, last]</code>的数之和，由前面我们可以得到<code>num[first] = num[last]</code>，即，区间<code>(first, last]</code>的数之和为<code>0</code></p>
<p>因此我们可以通过前缀和的思想，再加上哈希来存储前缀和数组中每一个值的最远位置。这样的时间复杂度为$O(n)$</p>
<p>当然，快速找到区间只是第一步，接下来就是下一步。</p>
<p>为了满足返回最终结果链表中连续的数之和不为<code>0</code>，我们可以利用贪心的想法。</p>
<p>我们从头遍历前缀和数组，如果这个数值不唯一，那么我们就获取索引值最大的那个值，然后将两个值之间的数都给删除，删除这些数并不会影响前缀和的性质，为什么呢？参考前面，这个区间的数之和为<code>0</code>，所以并不影响。</p>
<p>删掉这些数字之后我们下次寻找就不在删掉的区间中遍历了，因为如果在这个区间中遍历寻找前缀和数组时，如果找到并进行删除操作，那么删除的数组可能会有重叠部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230611230552.png" alt="Img"></p>
<p>我们要删除橙色部分，但是最后的操作删的其实是蓝色的部分，但是橙色部分的和为<code>0</code>，这是确定的，但是蓝色部分的和呢？我们并不知道，因此我们当我们删除一段区间之后，我们不用再遍历这个区间内的前缀和，直接从删除区间的末尾进行遍历。</p>
<p>根据这样的操作，最后留下来的数就不会形成连续和为<code>0</code>的情况</p>
<p>::: tip 注意<br>刚开始我们首先得确定从数组起点开始的前缀和为<code>0</code>的区间，并对其进行删除操作。否则当遇上输入为<code>[1, -1]</code>时，就会出现与结果不一样的答案。<br>:::</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* removeZeroSumSublists(ListNode* head) &#123;
        ListNode* root = new ListNode(0, head), *p = root;
        vector&lt;int&gt; num;
        num.emplace_back(head-&gt;val);
        head = head-&gt;next;
        while(head != NULL)&#123;
            num.emplace_back(num.back() + head-&gt;val);
            head = head-&gt;next;
        &#125;
        unordered_map&lt;int, int&gt; hash;
        int len = num.size();
        for(int i = 0; i &lt; len; i++)&#123;
            hash[num[i]] = i;
        &#125;
        int idx = -1;
        if(hash.count(0)) idx = hash[0];
        for(int i = 0; i &lt;= idx; i++)&#123;
            num[i] = 0;
        &#125;
        for(int i = idx + 1; i &lt; len; i++)&#123;
            if(hash[num[i]] != i)&#123;
                for(int j = i + 1; j &lt;= hash[num[i]]; j++)&#123;
                    num[j] = 0;
                &#125;
                i = hash[num[i]];
            &#125;
        &#125;
        ListNode *q = p-&gt;next;
        p-&gt;next = NULL;
        for(int i = 0; i &lt; len; i++)&#123;
            if(q-&gt;val &amp;&amp; num[i])&#123;
                ListNode *t = new ListNode(q-&gt;val);
                p-&gt;next = t;
                p = t;
            &#125;
            q = q-&gt;next;
        &#125;
        return root-&gt;next;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1326.灌溉花园的最少水龙头数目</title>
    <url>/posts/3f55d95f.html</url>
    <content><![CDATA[<h1 id="1326-灌溉花园的最少水龙头数目-20230221每日一题"><a href="#1326-灌溉花园的最少水龙头数目-20230221每日一题" class="headerlink" title="1326. 灌溉花园的最少水龙头数目(20230221每日一题)"></a><strong><a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/">1326. 灌溉花园的最少水龙头数目</a>(20230221每日一题)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i -  ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1326.png" alt=""></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="lang-cpp">n = 5, ranges = [3,4,1,1,0,0]
</code></pre>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="lang-cpp">1
</code></pre>
<h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p><code>点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题看似是一道hard难度的题，真实难度感觉是一道medium难度的题。</p>
<p>题目的意思是用多个喷水口来覆盖整个花园，它的表达意思可能让我们难以下手，但是如果我们换一个说法，每一个喷水口不是<code>[i-range[i], i+range[i]]</code>，而是<code>[i, i+range[i]*2]</code>。这样子就能更好的理解了。</p>
<p>接下来的解题步骤就是我们先确定每个水龙头能灌溉的左右边界，然后确定每个左边界能够到达的最右边界。之后我们就从头开始遍历，先确定<code>0</code>位置能够到达的最右边界，然后我们定义<code>right</code>为当前最右边界，<code>right_last</code>为上次最右边界，然后每次从当前最右边界遍历到上次最右边界，如果在这个区间中能够到达的最右边界是小于<code>right</code>的值，那么说明水龙头不能灌溉所有的区间。否则就更新<code>right</code>和<code>right_last</code>这两个值，直到<code>right</code>值大于等于<code>n</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int minTaps(int n, vector&lt;int&gt;&amp; ranges) &#123;
        vector&lt;int&gt; right_most(n+1, 0);
        for(int i = 0; i &lt;= n; i++)&#123;
            int len = ranges[i];
            if(i &gt;= len) right_most[i - len] = i + len;
            else right_most[0] = max(right_most[0], len + i);
        &#125;

        int res = 0, right = 0, right_last = 0;
        while(right &lt; n)&#123;
            int right_tmp = -1;
            for(int i = right; i &gt;= right_last; i--)&#123;
                if(right_most[i] &gt; right)&#123;
                    right_tmp = max(right_tmp, right_most[i]);
                &#125;
            &#125;
            if(right_tmp == -1) return -1;
            res++;
            right_last = right;
            right = right_tmp;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1574.删除最短的子数组使剩余数组有序</title>
    <url>/posts/54f14d01.html</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">1574.删除最短的子数组使剩余数组有序</a></strong></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325131830.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">arr = [1,2,3,10,4,2,3,5]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">3
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
</code></pre>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10^9</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中也说了，要删除的是连续子数组，不然可以用最长上升子数组的做法来做。</p>
<p>删除子数组不外乎有三种删法能使得剩下的数组是有序的。</p>
<ul>
<li>删除前面的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325132852.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325132852.png"></p>
<ul>
<li>删除中间的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325132937.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325132937.png"></p>
<ul>
<li>删除后面的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325133020.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325133020.png"></p>
<p>只有这三种删法才能使得剩下的是有序的。</p>
<p>那怎么删呢？</p>
<p>我的思路是用到双指针，且先找好右边的有序数组，然后开始枚举左边的数，如果左边的数是有序的，那么我们就根据左边的数来寻找右边相应的索引。这样的时间复杂度是$O(n)$。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><ol>
<li>首先我们得找先找右边最长的有序数组，并标记这个有序数组的起始索引<code>j</code></li>
<li>如果<code>j=0</code>，那么说明这个数组本就是有序数组，不用删减</li>
<li>如果<code>j≠0</code>，那么我们就得从头遍历这个数组</li>
<li>在我们遍历的过程中如果发现前面的数组不是有序的，那么立马停止遍历，因为继续遍历也没有用处，已经是无序的再怎么删也还是无序的</li>
<li>我们每遍历一个数<code>num</code>就把这个数和刚刚我们标记的索引的值进行比较，如果<code>num</code>较小或相等，那么我们可以将之前最优解和当前最优解进行比较，当前最优解就是<code>j-num的索引-1</code></li>
<li>如果<code>num</code>较大，那么我们就将<code>j</code>往后推，直到<code>num</code>较小或者<code>j</code>推到末尾，这时再进行计算当前最优解</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int findLengthOfShortestSubarray(vector&lt;int&gt;&amp; arr) &#123;
        int len = arr.size(), j = len - 1;
        while(j &amp;&amp; arr[j -  1] &lt;= arr[j]) j--;
        if(j == 0) return 0;
        int res = j;
        for(int i = 0; i &lt; j; i++)&#123;
            if(i &amp;&amp; arr[i] &lt; arr[i - 1]) &#123;
                res = min(res, len - i);
                break;
            &#125;
            if(j != len &amp;&amp; arr[i] &lt;= arr[j])&#123;
                res = min(res, j - i - 1);
            &#125;else&#123;
                while(j &lt; len &amp;&amp; arr[i] &gt; arr[j]) j++;
                res = min(res , j - i - 1);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1376.通知所有员工所需的时间</title>
    <url>/posts/3d809fe9.html</url>
    <content><![CDATA[<h1 id="LeetCode-1376-通知所有员工所需的时间"><a href="#LeetCode-1376-通知所有员工所需的时间" class="headerlink" title="LeetCode 1376.通知所有员工所需的时间"></a>LeetCode 1376.通知所有员工所需的时间</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230501171724.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-bash">n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-bash">1
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-bash">id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。
上图显示了公司员工的树结构。
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>0 &lt;= headID &lt; n</code></li>
<li><code>manager.length == n</code></li>
<li><code>0 &lt;= manager[i] &lt; n</code></li>
<li><code>manager[headID] == -1</code></li>
<li><code>informTime.length == n</code></li>
<li><code>0 &lt;= informTime[i] &lt;= 1000</code></li>
<li>如果员工 <code>i</code> 没有下属，<code>informTime[i] == 0</code> 。</li>
<li>题目 <strong>保证</strong> 所有员工都可以收到通知。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我们可以看作是一棵多叉树，或者是一个带边权的单向图，我们要求的是找到这个单向图中最远的两个节点的长度。</p>
<p>我们已经知道了起点，我们要找最远的路径，那么我们只要找到这个点到所有点的距离即可，然后选取最大值，因为图中的点最多是1e5，并且每个点都只有一个入度（除了起点），因此不用考虑重复到达某个点的问题。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>既然是需要遍历所有点的距离，那么我们可以用bfs和dfs遍历获取起点到每一个点的距离。</p>
<p>这里我选择使用bfs</p>
<p>值得注意的是，我们在bfs的过程中我们需要维护起点到每个点的时间消耗。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123;
        vector&lt;vector&lt;int&gt;&gt; employ(n);
        vector&lt;int&gt; costT(n, 0);//起点到其他点消耗的时间
        int len = manager.size();
        for(int i = 0; i &lt; len; i++)&#123;
            if(headID == i) continue;
            employ[manager[i]].emplace_back(i);
        &#125;
        int ans = 0;
        queue&lt;int&gt; q;
        q.push(headID);
        while(!q.empty())&#123;
            int v = q.front();
            q.pop();
            for(auto u : employ[v])&#123;
                q.push(u);
                costT[u] = costT[v] + informTime[v];//时间=起点到上一个消耗的时间+上一个点到这个点消耗的时间
            &#125;
        &#125;
        for(int i = 0; i &lt; n; i++)&#123;
            ans = max(ans, costT[i]);
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Daily</tag>
        <tag>Bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1616.分割两个字符串得到回文串</title>
    <url>/posts/b55ae9ab.html</url>
    <content><![CDATA[<h1 id="1616-分割两个字符串得到回文串-Medium"><a href="#1616-分割两个字符串得到回文串-Medium" class="headerlink" title="1616. 分割两个字符串得到回文串(Medium)"></a><strong><a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/">1616. 分割两个字符串得到回文串</a>(Medium)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1616.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">true
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">aprefix = &quot;ula&quot;, asuffix = &quot;cfd&quot;
bprefix = &quot;jiz&quot;, bsuffix = &quot;alu&quot;
那么 aprefix + bsuffix = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot; 是回文串。
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>1 &lt;= a.length, b.length &lt;= 105</code></li>
<li><code>a.length == b.length</code></li>
<li><code>a</code> 和 <code>b</code> 都只包含小写英文字母</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题最暴力的想法，就是现在每个地方切一刀获取两个新形成的字符串，然后再比较每一个字符串是否是回文串，这样的时间复杂度是 $O(n^2)$，耗时比较高。</p>
<p>怎么降低耗时呢？</p>
<p>我的做法就是去除冗余的比较，比如说样例给的两个字符串”ulacfd”,”jizalu”，划在第一刀时形成的字符串”uizalu”,”jlacfd”，和划在第二刀形成的字符串”ulzalu”,”jiacfd”，其中第一个字符串首字母”u“和第二个字符串末字母”u“对比了两次，但是他们在位置上是构成回文的。如果我们先把这些能够构成回文的位置都找到，那么我们就能够减少很多冗余的对比。再给一组例子，“ulbbfc”,”jizalu”，我们已经找到了首尾能够构成回文的字符串了，”ul”,”lu”，但是剩下的中间部分不能由两个字符串拼接而成了，如果能够继续拼接，那么说明获取能够构成回文的字符串应该是”ulb”，”alu”，这很明显是不能构成回文的。</p>
<p>那么接下来应该怎么做呢？</p>
<p>既然剩下的部分不能由两个字符串拼接而成，那么我们就在两个字符串剩下的部分来判断是否是回文串即可，比如“ulbbfc”,”jizalu”这组例子，我们已经获得了目标回文串的首尾”ul“和”lu”，这个首尾能够组成的字符串只能是”ulzalu”，”ulbalu”，”ulbblu”，但是因为中间部分不能由两个字符串拼接，那么只剩下两个字符串”ulzalu”和”ulbblu”。也就是说，我们只要判断”za””bb”是不是回文串即可。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>这道题因为是<code>a$_&#123;prefix&#125;$ + b$_&#123;suffix&#125;$</code>或者<code>b$_&#123;prefix&#125;$ + a$_&#123;suffix&#125;$</code>其中有一个满足就行，那么我们只需要分别做<code>a$_&#123;prefix&#125;$ + b$_&#123;suffix&#125;$</code>和<code>b$_&#123;prefix&#125;$ + a$_&#123;suffix&#125;$</code>即可。即先判断a字符串前和b字符串末能够构成回文的最大长度，然后在两个字符串剩余部分判断是否构成回文，如果最后的字符串不是回文，那么再用相同的方法判断另外一组。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    bool chechAgain(string a, int i, int j)&#123;
        if(i &gt;= j) return true;
        while(i &lt; j)&#123;
            if(a[i] == a[j]) &#123;
                i++;
                j--;
            &#125;else break;
        &#125;
        if(i &lt; j) return false;
        return true;
    &#125;

    bool check(string a, string b)&#123;
        int i = 0, j = a.size() - 1;
        while(i &lt; j)&#123;
            if(a[i] == b[j])&#123;
                i++;
                j--;
            &#125;
            else break;
        &#125;
        return chechAgain(a, i ,j) || chechAgain(b, i, j);
    &#125;

    bool checkPalindromeFormation(string a, string b) &#123;
        return check(a, b) || check(b, a);
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1630.等差子数组</title>
    <url>/posts/fdb0b5f8.html</url>
    <content><![CDATA[<h2 id="1630-等差子数组"><a href="#1630-等差子数组" class="headerlink" title="1630. 等差子数组"></a><strong><a href="https://leetcode.cn/problems/arithmetic-subarrays/description/">1630. 等差子数组</a></strong></h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323124209.png" alt="Problem Description"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-java">nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-java">[true,false,true]
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-java">[true,false,true]
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>n == nums.length</code></li>
<li><code>m == l.length</code></li>
<li><code>m == r.length</code></li>
<li><code>2 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= m &lt;= 500</code></li>
<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>
<li><code>105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先看一下难度，Medium，可以尝试着用暴力，但是要想一下怎么暴力。</p>
<p>单纯的暴力就是，将每一段区间的数都提出来再进行排序，再验证排完序之后的数组是否是等差数列。但是这样的时间复杂度是 $O(n^2logn)$，数据范围小的情况下可以做。</p>
<p>我有一个时间复杂度较小的想法。对每一段区间的步骤如下：</p>
<ol>
<li>找到该段区间的最大值和最小值，如果最大值和最小值之差不是个数<code>-1</code>的倍数，那么说明不能构成等差数列</li>
<li>如果最大值和最小值之差刚好是0，那么说明这个区间中的所有数都相同，那么肯定是等差数列</li>
<li>如果不是0，我们就要开始遍历这个区间的数<ol>
<li>如果该区间的数与最小值之差不是公差的倍数，那说明这个区间的数不能构成等差数列</li>
<li>如果该区间重复出现某个数，说明这个区间的数不能构成等差数列</li>
</ol>
</li>
</ol>
<p>在经历了上述步骤之后，最后我们就能判断每个区间的数是否能构成等差数列了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123;
        int len_nums = nums.size(), len = l.size();
        vector&lt;bool&gt; ans(len);
        for(int i = 0; i &lt; len; i++)&#123;
            int num_max = nums[l[i]], num_min = nums[l[i]];
            for(int j = l[i]; j &lt;= r[i]; j++)&#123;
                num_max = max(num_max, nums[j]);
                num_min = min(num_min, nums[j]);
            &#125;
            if((num_max - num_min) % (r[i] - l[i]) != 0) &#123;
                ans[i] = false;
                continue;
            &#125;
            unordered_map&lt;int, int&gt; hash;
            int e = (num_max - num_min) / (r[i] - l[i]);
            bool flag = true;
            if(e == 0)&#123;
                ans[i] = true;
                continue;
            &#125;
            for(int j = l[i]; j &lt;= r[i]; j++)&#123;
                if(hash[nums[j]] || (nums[j] - num_min) % e != 0)&#123;
                    flag = false;
                    break;
                &#125;else&#123;
                    hash[nums[j]] = 1;
                &#125;
            &#125;
            ans[i] = flag;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1637.两点之间不包含任何点的最宽垂直区域</title>
    <url>/posts/8e39a6b9.html</url>
    <content><![CDATA[<h2 id="1637-两点之间不包含任何点的最宽垂直区域"><a href="#1637-两点之间不包含任何点的最宽垂直区域" class="headerlink" title="1637. 两点之间不包含任何点的最宽垂直区域"></a><strong><a href="https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/description/">1637. 两点之间不包含任何点的最宽垂直区域</a></strong></h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230330182639.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><pre><code class="lang-cpp">[[8,7],[9,9],[7,4],[9,7]]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">1
</code></pre>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230330182733.png" alt=""></p>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>n == points.length</code></li>
<li><code>2 &lt;= n &lt;= 1e5</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>0 &lt;= xi, yi &lt;= 1e9</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题乍看是一道中等题，但其实是一道简单题。</p>
<p><strong>最宽垂直区域</strong>用另一种说法就是两个点的横坐标的差。题意这样一转换，难度就降低了。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>将点根据横坐标进行从大到小进行排序，然后遍历一边即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        sort(points.begin(), points.end(), [&amp;](vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;
            return A[0] &lt; B[0];
        &#125;);
        int res = 0;
        for(int i = 1; i &lt; points.size(); i++)&#123;
            res = max(res, points[i][0] - points[i - 1][0]);
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1641.统计字典序元音字符串的数目</title>
    <url>/posts/9207185a.html</url>
    <content><![CDATA[<h2 id="1641-统计字典序元音字符串的数目"><a href="#1641-统计字典序元音字符串的数目" class="headerlink" title="1641.统计字典序元音字符串的数目"></a><a href="https://leetcode.cn/problems/count-sorted-vowel-strings/description/">1641.<strong>统计字典序元音字符串的数目</strong></a></h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329150717.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">n = 2
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">15
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">仅由元音组成的 15 个字典序字符串为
[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;]
注意，&quot;ea&quot; 不是符合题意的字符串，因为 &#39;e&#39; 在字母表中的位置比 &#39;a&#39; 靠后
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>• <code>1 &lt;= n &lt;= 50</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看这道题，第一眼是一道中等题，不太好暴力，再看数据范围，好像又可以暴力，毕竟范围是<code>[1,50]</code>。暴力的做法就是用<code>dfs</code>搜索所有可能，但事后面自己列了一下数组，发现有一种更简单的方法</p>
<p>首先，如果<code>m=1</code>，那么数组就是<code>[1,1,1,1,1]</code>，那如果<code>m=2</code>的时候，字母<code>’a’</code>后面能跟的就是<code>m-1</code>数组中的所有组合，因为题目前要求是相同或者小，因此<code>’a’</code>字母后面能跟<code>m-1</code>数组的所有组合，那么<code>’e’</code>字母的后面就只能跟<code>n-1</code>数组中的除了<code>’a’</code>开头的其他组合。以此类推，我们不断更新<code>m</code>直到<code>m=n</code>，这个时候的数组就是以每一种元音字母作为开头它的种数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int countVowelStrings(int n) &#123;
        vector&lt;int&gt; res(5, 1);
        for(int i = 0; i &lt; n - 1; i++)&#123;
            for(int j = 0; j &lt; 4; j++)&#123;
                res[j] = accumulate(res.begin() + j, res.end(), 0);
            &#125;
        &#125;
        return accumulate(res.begin(), res.end(), 0);
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数学推导</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1769.移动所有球到每个盒子所需的最小操作数</title>
    <url>/posts/53590df.html</url>
    <content><![CDATA[<h1 id="1769-移动所有球到每个盒子所需的最小操作数-20221202每日一题"><a href="#1769-移动所有球到每个盒子所需的最小操作数-20221202每日一题" class="headerlink" title="1769. 移动所有球到每个盒子所需的最小操作数(20221202每日一题)"></a><strong><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/">1769. 移动所有球到每个盒子所需的最小操作数</a>(20221202每日一题)</strong></h1><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#39;0&#39;</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>&#39;1&#39;</code> 表示盒子里有 <strong>一个</strong> 小球。</p>
<p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>
<p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p>
<p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h2 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h2><pre><code class="lang-cpp">boxes = &quot;110&quot;
</code></pre>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h2><pre><code class="lang-cpp">[1,1,3]
</code></pre>
<ul>
<li><code>n == boxes.length</code></li>
<li><code>1 &lt;= n &lt;= 2000</code></li>
<li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据题目的意思，这是让我们求把所有的球移到一个位置所需要的最少次数，一次只能把一个球移到邻居。知道这个步骤之后，我们只要知道每个位置的左边的球和右边的球分别移到这个位置所需要多少次即可。那么我们怎么计算呢？如果每计算一个索引值时都遍历一次数组，那需要$O(n^2)$的时间复杂度，虽然本题中n的范围是<code>[1,2000]</code>，时间是足够的，但是这里有另一个更低的时间复杂度的方法。我们需要维护两个数组来维护数据，一个数组来维护这个位置左边所有的球到这个位置需要的次数和右边所有的球到这个位置需要的次数，怎么维护呢？这里就涉及到前缀和的思想。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; minOperations(string boxes) &#123;
        int len = boxes.size();
        vector&lt;int&gt; l(len, 0), r(len, 0);
        int balls = 0;
        if(boxes.front() == &#39;1&#39;) balls++;
        for(int i = 1; i &lt; len; i++)&#123;
            l[i] = l[i - 1] + balls;
            if(boxes[i] == &#39;1&#39;) balls++;
        &#125;
        balls = 0;
        if(boxes.back() == &#39;1&#39;) balls++;
        for(int i = len - 2; i &gt;= 0; i--)&#123;
            r[i] = r[i + 1] + balls;
            if(boxes[i] == &#39;1&#39;) balls++;
        &#125;
        for(int i = 0; i &lt; len; i++)&#123;
            l[i] += r[i];
        &#125;
        return l;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 209.长度最小的子数组</title>
    <url>/posts/598a88dc.html</url>
    <content><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/209.png" alt="Problem Description"></p>
<h2 id="Sample1"><a href="#Sample1" class="headerlink" title="Sample1"></a>Sample1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h3><pre><code class="lang-cpp">target = 7, nums = [2,3,1,2,4,3]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">2
</code></pre>
<h2 id="Sample2"><a href="#Sample2" class="headerlink" title="Sample2"></a>Sample2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h3><pre><code class="lang-cpp">target = 4, nums = [1,4,4]
</code></pre>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">1
</code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这个题目的数组长度范围是<code>[1,1e5]</code>，如果使用暴力的方法，也就是遍历所有的子数组，此时的时间复杂度是 $O(n^2)$，这个时候是有可能超时的，那么我们怎么来降低耗时呢？这个时候我们就可以利用滑动窗口的思路，即先记录一段子数组的总和，如果总和大于<code>target</code>，那么我们就可以慢慢减去这个子数组的最前面的数字，直到子数组的和小于<code>target</code>，在减的过程中我们统计这个子数组的长度与当前最优解进行比较，如果子数组的长度优于当前最优解时，我们就替换当前最优解。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们先用一个<code>idx</code>变量来记录这个数组的左端，然后遍历数组。在遍历数组的时候，我们用一个变量<code>sum</code>来记录从<code>idx</code>到<code>i</code>子数组总和。当这个总和<code>sum</code>的值大于等于<code>target</code>时，我们就慢慢删减<code>idx</code>上的数，同时把<code>idx</code>后移一位，直到<code>sum</code>小于<code>target</code>，在删减的同时更新最优解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;
        int res = nums.size() + 1;
        int idx = -1, sum = 0;
        for(int i = 0; i &lt; nums.size(); i++)&#123;
            sum += nums[i];
            while(sum &gt;= target)&#123;
                res = min(i - idx, res);
                idx++;
                sum -= nums[idx];
            &#125;
        &#125;
        if(res == nums.size() + 1) return 0;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2389. 和有限的最长子序列</title>
    <url>/posts/25b2a3da.html</url>
    <content><![CDATA[<h1 id="LeetCode-2389-和有限的最长子序列"><a href="#LeetCode-2389-和有限的最长子序列" class="headerlink" title="LeetCode 2389. 和有限的最长子序列"></a>LeetCode 2389. 和有限的最长子序列</h1><h1 id="2389-和有限的最长子序列"><a href="#2389-和有限的最长子序列" class="headerlink" title="2389. 和有限的最长子序列"></a><strong><a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/description/">2389. 和有限的最长子序列</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/2.png" alt="Problem Description"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-sql">nums = [4,5,2,1], queries = [3,10,21]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-sql">[2,3,4]
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。
- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。
- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。
</code></pre><p>数据范围是</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == queries.length</code></li>
<li><code>1 &lt;= n, m &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], queries[i] &lt;= 1e6</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们注意的第一点就是他给我们划重点的地方，我们要求的是子序列的最大长度</p>
<ul>
<li><p>子序列</p>
<p>  是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组</p>
</li>
</ul>
<p>题目让我们求子序列的最大长度，刚开始我以为是子串，需要连续，如果需要连续的话这道题的难度就会成倍地增长。如果是子序列那难度就会大大降低。因为我们是求子序列的总和，总和不用参考数组的顺序，那么我们可以随意的往子序列（最开始为空）中加入数字，直到这个总和大于<code>query</code>。</p>
<p>那么我们应该怎么加才能让这个子序列数组<code>size</code>最大呢？肯定是优先往里面加入最小的数，比如说现在的<code>nums</code>是<code>[4,5,2,1]</code>，<code>query</code>为<code>4</code>。如果我们往子序列中加入<code>4</code>，总和已经达到了要求，这个时候的<code>size</code>是<code>1</code>。但是如果我们往子序列中添加<code>1</code>，子序列的总和为<code>1</code>，还可以继续往里面添加，那么我们再选剩下的最小数<code>2</code>，这个时候子序列的总和为<code>3</code>，继续添加剩下的最小数<code>4</code>，总和达到了<code>7</code>，超过了<code>query</code>，那么我们就回退，<code>size</code>为<code>2</code>。这个例子我们就可以得出可以优先往里面添加最小数才能使得目标子序列的<code>size</code>最大。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>为了让添加最小数，我们可以先对数组进行排序，这样我们就能识别挑完最小数之后剩下的数中的最小数。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123;
        sort(nums.begin(), nums.end());
        vector&lt;int&gt; res(queries.size());
        int len = queries.size();
        for(int i = 0; i &lt; len; i++)&#123;
            int t = 0;
            for(; t &lt; nums.size(); t++)&#123;
                queries[i] -= nums[t];
                if(queries[i] &lt; 0) break;
            &#125;
            res[i] = t;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<p>为了避免我们对每个query都要进行一次累加，我们可以用前缀和的方式统计前<code>n</code>个较小数的总和，方便后面的寻找目标值。这样我们的时间复杂度就从 $O(m^2 <em> n)$降低到了 $O(m </em> n)$。</p>
<p>还可以进一步优化</p>
<p>因为我们现在已经获得了前缀和，还是一个排序后的数组的前缀和，那么这个前缀和数组也是一个有序数组。那么我们可以在这个有序数组中找到第一个<code>&gt;query</code>的值的索引，这样我们就把时间复杂度从 $O(m*n)$降到了 $O(nlogm)$。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int Binary_Search(vector&lt;int&gt; &amp;nums, int target)&#123;
        int left = -1, right = nums.size();
        while(left + 1 &lt; right)&#123;
            int mid = (left + right) &gt;&gt; 1;
            if(nums[mid] &gt; target)&#123;
                right = mid;
            &#125;else&#123;
                left = mid;
            &#125;
        &#125;
        return left;
    &#125;

    vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123;
        sort(nums.begin(), nums.end());
        int len_nums = nums.size(), len_queries = queries.size();
        vector&lt;int&gt; qzh(len_nums, 0), ans(len_queries, 0);
        qzh[0] = nums[0];
        for(int i = 1; i &lt; nums.size(); i++)&#123;
            qzh[i] = qzh[i - 1] + nums[i];
        &#125;
        for(int i = 0; i &lt; len_queries; i++)&#123;
            ans[i] = Binary_Search(qzh, queries[i]);
            ans[i]++;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>前缀和</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 242.有效的字母异位词</title>
    <url>/posts/24a74496.html</url>
    <content><![CDATA[<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a><strong><a href="https://leetcode.cn/problems/valid-anagram/">242.有效的字母异位词</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230417210119.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">s = &quot;anagram&quot;, t = &quot;nagaram&quot;
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">true
</code></pre>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 1e4</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果两个字符串互为字母异位词，那么这两个字母通过相同的排序条件排序之后，就是同一个字符串。因此我们可以判断这两个字符串排序完之后是否相同即可。但是排序的时间复杂度为$O(nlogn)$.时间复杂度不是很优秀，因此我们可以换一种思路。</p>
<p>既然这两个字符串排序完之后相等，那么这两个字符串每一个字母的个数都相同，因此我们只需要统计每个字符串的每种字母个数，如果两个字符串每种字母的个数都相同，那么这两个字符串就像等，否则就不是互为字母异位词。这个的时间复杂度为$O(n)$</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们分别用两个数组来存储每个字符串的每种字母的个数，然后遍历两个数组，如果对应索引的字母个数都相同，那么这连个字符串互为字母异位词。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    bool isAnagram(string s, string t) &#123;
        int a[26] = &#123;0&#125;, b[26] = &#123;0&#125;;
        for(auto ss : s)    a[ss - &#39;a&#39;]++;
        for(auto tt : t)    b[tt - &#39;a&#39;]++;
        for(int i = 0; i &lt; 26; i++)
            if(a[i] != b[i]) return false;
        return true;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2441 与对应负数同时存在的最大正整数</title>
    <url>/posts/2cd6a016.html</url>
    <content><![CDATA[<h2 id="难度-1168分"><a href="#难度-1168分" class="headerlink" title="难度 1168分"></a>难度 1168分</h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230513235239.png" alt="Img"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>nums = [-1,2,-3,3]
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>3
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>3 是数组中唯一一个满足题目要求的 k 。
</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums[i] != 0</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的意思简洁明了，让我们在数组中找到一个正整数，并且它的相反数也在这个数组内，用另一种话来讲，就是在一个数组中找到两个数使得这两个数相等。<br>那我们应该怎么找呢？</p>
<ul>
<li>暴力点的方法就是用$O(n^2)$的时间复杂度用两层for循环找，数据范围是1000，不会超时。</li>
<li>次一点的方法就是用$O(nlogn)$的时间复杂度，先排序再利用双指针来寻找两个数相加为0</li>
<li>最后一个方法就是用$O(n)$的时间复杂度，利用哈希表来存储已经遍历过的数字，之后每遍历一个点的时候就判断它的相反数是否已经出现过即可</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int findMaxK(vector&lt;int&gt;&amp; nums) &#123;
        unordered_map&lt;int, int&gt; hash;
        int res = -1;
        for(auto num : nums)&#123;
            if(hash[-1 * num]) res = max(res, abs(num));
            hash[num] = 1;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2460.对数组执行操作</title>
    <url>/posts/1a627862.html</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230605210512.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>nums = [1,2,2,1,1,0]
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>[1,4,2,0,0,0]
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>执行以下操作：
- i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。
- i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,4,0,1,1,0] 。
- i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。
- i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。
- i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。
执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。
</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>2 &lt;= nums.length &lt;= 2000</li>
<li>0 &lt;= nums[i] &lt;= 1000</li>
</ul>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>模拟。我们开辟一个新的初始化为<code>0</code>的数组进行存储需要返回的数值。我们在<code>nums</code>数组中每遍历到相同的邻居时，我们就将它存储到目标数组中，并对目标数组的索引进行<code>+1</code>操作。最后我们再将<code>nums</code>数组中的最后一位添加到目标数组中，这个时候不用考虑该数字是否为0。</p>
<ul>
<li>如果这个数字为0，将它加入末尾之后不影响末尾都是0的要求</li>
<li>如果这个数字不为0，它也不影响末尾都是0的要求</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-C++">class Solution &#123;
public:
    vector&lt;int&gt; applyOperations(vector&lt;int&gt;&amp; nums) &#123;
        int idx = 0, len = nums.size();
        vector&lt;int&gt; arr(len, 0);
        for(int i = 0; i &lt; len - 1; i++)&#123;
            if(nums[i] == 0) continue;
            else if(nums[i] == nums[i + 1])&#123;
                nums[i + 1] = 0;
                arr[idx++] = nums[i] * 2;
            &#125;else &#123;
                arr[idx++] = nums[i];
            &#125;
        &#125;
        arr[idx] = nums.back();
        return arr;
    &#125;
&#125;;
</code></pre>
<pre><code class="lang-C++">// O(1)的空间复杂度
class Solution &#123;
public:
    vector&lt;int&gt; applyOperations(vector&lt;int&gt;&amp; nums) &#123;
        int idx = 0, len = nums.size();
        for(int i = 0; i &lt; len - 1; i++)&#123;
            if(nums[i] == nums[i + 1])&#123;
                nums[i] *= 2;
                nums[i + 1] = 0;
            &#125;
        &#125;

        for(int i = 0; i &lt; len; i++)&#123;
            if(nums[i]) nums[idx++] = nums[i];
        &#125;
        for(int i = idx; i &lt; len; i++)&#123;
            nums[i] = 0;
        &#125;
        return nums;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 454.四数相加 II</title>
    <url>/posts/345aa0d2.html</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230418212548.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">2
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">两个元组如下：
1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>n == nums3.length</code></li>
<li><code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚开始的时候我想着这个数据真小，才<code>200</code>，因此我打算直接比完全暴力又那么不暴力一点的做法，用哈希存储前三个数组能够组成的和的个数，最后再遍历第四个数组即可。但是这样没想到超时了！后来一想，这样的时间复杂度是$O(n^3)$，这里有四个数组，完全可以用更小的时间复杂度来做。我们可以将四个数组两两分组，时间复杂度为$O(n^2)$，这样的话我们只要进行两次的两个数组之间的一一对应即可。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们用hash表来存储第一和第二两个数组每一种组合的和的个数，再组合另外两个数组的元素，每组合一次，就在hash表中查看是否有这个和的相反数，如果有，则加入这个相反数的二元组的个数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;
        unordered_map&lt;int, int&gt; hash;
        int ans = 0;
        for(auto num1 : nums1)&#123;
            for(auto num2 : nums2)&#123;
                hash[num1 + num2]++;
            &#125;
        &#125;
        for(auto num1 : nums3)&#123;
            for(auto num2 : nums4)&#123;
                ans += hash[-num1 - num2];
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 481.神奇数字</title>
    <url>/posts/16343545.html</url>
    <content><![CDATA[<h1 id="481-神奇字符串-20221031每日一题"><a href="#481-神奇字符串-20221031每日一题" class="headerlink" title="481. 神奇字符串(20221031每日一题)"></a><a href="https://leetcode.cn/problems/magical-string/">481. 神奇字符串</a>(20221031每日一题)</h1><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/481-1.png" alt="Problem Description"></p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><pre><code class="lang-cpp">6
</code></pre>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><pre><code class="lang-cpp">3
</code></pre>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题给出一个一维数组，后面的数会根据前面的数而定值，那么我们只需要模拟一下即可，那么怎么模拟呢？</p>
<p>定义这个一维数组为<code>arr</code>，那么我们可以看到。<code>arr[2]</code>的数字要根据<code>arr[1]</code>来定值，<code>arr[3]</code>的数字要根据<code>arr[2]</code>来定值，因为<code>arr[0]</code>为<code>1</code>，<code>arr[1]</code>为<code>2</code>，而因为<code>arr[1]</code>为<code>2</code>，那么<code>arr[1]</code>和<code>arr[2]</code>需要相同的数字，即<code>arr[2] = arr[1]</code>，之后<code>arr[3]</code>的值不能与<code>arr[2]</code>相等，否则就成为了<code>arr[1]=arr[2]=arr[3]</code>，这个时候<code>arr[1]</code>的值需要为<code>3</code>才能解释的通，但是<code>arr</code>的值只能是<code>1</code>或者<code>2</code>，那么我们就要将改变<code>arr[3]</code>的值与前面的值不同。</p>
<p>因此我们需要定义一个索引值<code>idx</code>，来表示当前相同数字所需要的连贯个数，用一个变量<code>f</code>来表示当前数组的数字，每加入一个数字时，我们就对<code>arr[idx]</code>进行减一操作，当<code>arr[idx]</code>为<code>0</code>时，我们就需要对<code>idx</code>进行<code>++</code>操作，并且改变<code>f</code>的值，使得数字之间不相同。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">class Solution &#123;
public:
    int magicalString(int n) &#123;
        if(n &lt;= 3) return 1;
        vector&lt;int&gt; arr(n);
        arr[0] = 1;
        arr[1] = 2;
        arr[2] = 2;
        int ones = 1, idx = 2, f = 1;
        for(int i = 3; i &lt; n; i++)&#123;
            if(f == 1) ones++;
            arr[i] = f;
            arr[idx]--;
            if(arr[idx] == 0) &#123;
                f = 3 - f;
                idx++;
            &#125;
        &#125;
        return ones;
    &#125;
&#125;;
</code></pre>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/481-2.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2469. 温度转换</title>
    <url>/posts/e80ecef2.html</url>
    <content><![CDATA[<h2 id="2469-温度转换"><a href="#2469-温度转换" class="headerlink" title="2469. 温度转换"></a><strong><a href="https://leetcode.cn/problems/convert-the-temperature/description/">2469. 温度转换</a></strong></h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230321132248.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">celsius = 36.50
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">[309.65000,97.70000]
</code></pre>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>• <code>0 &lt;= celsius &lt;= 1000</code></p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>单纯的输入输出</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;double&gt; convertTemperature(double celsius) &#123;
        vector&lt;double&gt; res(2, 0);
        res[0] = celsius + 273.15;
        res[1] = celsius * 1.80 + 32.00;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 49.字母异位词分组</title>
    <url>/posts/9170754a.html</url>
    <content><![CDATA[<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a><strong><a href="https://leetcode.cn/problems/group-anagrams/description/">49.字母异位词分组</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230418223356.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]
</code></pre>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>1 &lt;= strs.length &lt;= 1e4</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，我们得知道什么是字母异位词。两个字符串互为字母异位词当且仅当这两个字符串中所有的相同的字母的个数相等。</p>
<p>之前我们用判断两个字符串是否是互为字母异位词可以用判断相同字母个数是否相等来做，但是当涉及到多个字符串分类的时候，这个方法就不是那么方便了。换一种想法，两个字符串互为字母异位词，那么这两个字符串根据相同的优先级对字符进行排序之后就是相同的字符串了，因此我们可以对所有的字符串进行从小到大排序，然后记录每一种排完序之后的字符串的组别，最后我们将相同的字符串进行归类即可。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>用哈希表来判断每一种排完序之后的字符串是否已经出现过，如果出现过，那么我们就将这个字符串归入到相应的类别中，如果未出现过，那么我们就增加一个类别，并将这个字符串压入这个类别。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string, int&gt; hash;
        int len = strs.size();
        vector&lt;int&gt; index(len);
        int idx = 0;
        for(int i = 0; i &lt; len; i++)&#123;
            string tmp = strs[i];
            sort(tmp.begin(), tmp.end());
            if(hash[tmp]) index[i] = hash[tmp];
            else &#123;
                index[i] = ++idx;
                hash[tmp] = idx;
            &#125;
        &#125;
        vector&lt;vector&lt;string&gt;&gt; ans(idx);
        for(int i = 0; i &lt; len; i++)&#123;
            ans[index[i] - 1].emplace_back(strs[i]);
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 707.设计链表</title>
    <url>/posts/9ad52be0.html</url>
    <content><![CDATA[<h1 id="LeetCode-707-设计链表-mid"><a href="#LeetCode-707-设计链表-mid" class="headerlink" title="LeetCode 707.设计链表(mid)"></a>LeetCode 707.设计链表(mid)</h1><h1 id="707-设计链表（20220923每日一题）"><a href="#707-设计链表（20220923每日一题）" class="headerlink" title="707 设计链表（20220923每日一题）"></a>707 设计链表（20220923每日一题）</h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/Untitled.png" alt="Problem Description"></p>
<p>从题目中我们可以看到本题有以下几个功能：</p>
<ol>
<li>获取链表中位列index的值</li>
<li>在链表的头部添加节点</li>
<li>在链表的尾部添加节点</li>
<li>在链表中的指定索引地添加节点</li>
<li>删除指定索引的节点</li>
</ol>
<p>题目让我们不能使用内置的LinkedList库，那么我们可以用数组和链表来维护。由于该题有频繁的增加节点和删除节点，那么用数组来维护需要耗费大量的时间来维护index，因此我们选择链表来维护本题的“链表”。</p>
<h2 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h2><p>由于是一个链表，那么节点中所需要的元素至少有两个，一个值val，和一个指向下一个节点的*next，最好就是添加一个构造函数，这样方便快速生成新节点</p>
<pre><code class="lang-cpp">struct List&#123;
        int val;
        List *next;
        List(int val) : val(val), next(NULL)&#123;&#125;
    &#125;;
</code></pre>
<h2 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h2><p>当我们创建一个链表的时候，我们需要对其进行初始化，即构造函数，我们要对其成员进行一系列的初始化，在本题中我们需要初始化的元素只有结构体List，以及一个链表的长度，这个长度方便我们之后判断是否可以删除某个节点或者是否可以将节点加入指定的index</p>
<pre><code class="lang-cpp">MyLinkedList() &#123;
        this-&gt;root = new List(-1);
        this-&gt;len = 0;
    &#125;
</code></pre>
<p>我们创建的链表是自带头节点的链表，这类链表方便进行头插法（但是这题我的思路还是尾插法）</p>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>提供一个索引值index，返回索引所在的节点的val值，首先我们要先判断这个索引值index是否有效，如果无效则直接返回-1。</p>
<pre><code class="lang-cpp">int get(int index) &#123;
        if(index &gt;= this-&gt;len || index &lt; 0) return -1;
        List *head = this-&gt;root-&gt;next;
        while(index--)&#123;
            head = head-&gt;next;
        &#125;

        return head-&gt;val;
    &#125;
</code></pre>
<h2 id="在链表头部添加节点"><a href="#在链表头部添加节点" class="headerlink" title="在链表头部添加节点"></a>在链表头部添加节点</h2><p>在添加节点的三个功能中，添加头部节点是最方便的，因为相比于其他两个，头部添加节点不需要找位置，可以直接添加。</p>
<pre><code class="lang-cpp">void addAtHead(int val) &#123;
        List *node = new List(val);
        node-&gt;next = this-&gt;root-&gt;next;
        this-&gt;root-&gt;next = node;
        this-&gt;len++;
    &#125;
</code></pre>
<h2 id="在链表尾部添加节点"><a href="#在链表尾部添加节点" class="headerlink" title="在链表尾部添加节点"></a>在链表尾部添加节点</h2><p>添加尾部节点，如果我们用一个尾部标记tail来维护尾部节点，那么这个我们也能够快速添加，但是我没有用tail来维护，那么我们就要遍历到最后链表的最后一位以便于添加节点。</p>
<pre><code class="lang-cpp">void addAtTail(int val) &#123;
        List *head = this-&gt;root;
        while(head-&gt;next != NULL) head = head-&gt;next;
        List *node = new List(val);
        head-&gt;next = node;
        this-&gt;len++;
    &#125;
</code></pre>
<h2 id="在给定索引值前添加节点"><a href="#在给定索引值前添加节点" class="headerlink" title="在给定索引值前添加节点"></a>在给定索引值前添加节点</h2><p>这部分内容相比于前两个来说，只能够通过遍历来获取要添加的位置。</p>
<p>题目中对给定索引值添加节点指定了要求，首先，如果这个索引值大于链表的长度，那么我们将取消这次添加节点。如果这个索引值小于0，那么我们就将这个节点添加在头部，其余的我们需要遍历来获取节点添加的位置。</p>
<pre><code class="lang-cpp">void addAtIndex(int index, int val) &#123;
        if(index &gt; this-&gt;len) return;
        List *node = new List(val);
        List *head = this-&gt;root;
        while(index--)&#123;
            head = head-&gt;next;
        &#125;
        node-&gt;next = head-&gt;next;
        head-&gt;next = node;
        this-&gt;len++;
    &#125;
</code></pre>
<h2 id="删除指定索引值的节点"><a href="#删除指定索引值的节点" class="headerlink" title="删除指定索引值的节点"></a>删除指定索引值的节点</h2><p>题目中对删除节点指定了要求，如果索引值index有效，那么我们可以顺利删除，否则，我们将因为没有对应的节点可以删除而退出这个删除函数</p>
<pre><code class="lang-cpp">void deleteAtIndex(int index) &#123;
        if(index &lt; 0 || index &gt;= this-&gt;len) return;
        List *head = this-&gt;root;
        while(index--)&#123;
            head = head-&gt;next;
        &#125;
        List *tmp = head-&gt;next;
        head-&gt;next = head-&gt;next-&gt;next;
        delete tmp;
        this-&gt;len--;
    &#125;
</code></pre>
<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><pre><code class="lang-cpp">class MyLinkedList &#123;
    struct List&#123;
        int val;
        List *next;
        List(int val) : val(val), next(NULL)&#123;&#125;
    &#125;;
    List *root;
    int len;
public:
    MyLinkedList() &#123;
        this-&gt;root = new List(-1);
        this-&gt;len = 0;
    &#125;

    int get(int index) &#123;
        if(index &gt;= this-&gt;len || index &lt; 0) return -1;
        List *head = this-&gt;root-&gt;next;
        while(index--)&#123;
            head = head-&gt;next;
        &#125;

        return head-&gt;val;
    &#125;

    void addAtHead(int val) &#123;
        List *node = new List(val);
        node-&gt;next = this-&gt;root-&gt;next;
        this-&gt;root-&gt;next = node;
        this-&gt;len++;
    &#125;

    void addAtTail(int val) &#123;
        List *head = this-&gt;root;
        while(head-&gt;next != NULL) head = head-&gt;next;
        List *node = new List(val);
        head-&gt;next = node;
        this-&gt;len++;
    &#125;

    void addAtIndex(int index, int val) &#123;
        if(index &gt; this-&gt;len) return;
        List *node = new List(val);
        List *head = this-&gt;root;
        while(index--)&#123;
            head = head-&gt;next;
        &#125;
        node-&gt;next = head-&gt;next;
        head-&gt;next = node;
        this-&gt;len++;
    &#125;

    void deleteAtIndex(int index) &#123;
        if(index &lt; 0 || index &gt;= this-&gt;len) return;
        List *head = this-&gt;root;
        while(index--)&#123;
            head = head-&gt;next;
        &#125;
        List *tmp = head-&gt;next;
        head-&gt;next = head-&gt;next-&gt;next;
        delete tmp;
        this-&gt;len--;
    &#125;
&#125;;

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj-&gt;get(index);
 * obj-&gt;addAtHead(val);
 * obj-&gt;addAtTail(val);
 * obj-&gt;addAtIndex(index,val);
 * obj-&gt;deleteAtIndex(index);
 */
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 788.旋转数字</title>
    <url>/posts/28252a46.html</url>
    <content><![CDATA[<h1 id="LeetCode-788-旋转数字-Mid"><a href="#LeetCode-788-旋转数字-Mid" class="headerlink" title="LeetCode 788.旋转数字(Mid)"></a>LeetCode 788.旋转数字(Mid)</h1><h1 id="788-旋转数字（20220925每日一题）"><a href="#788-旋转数字（20220925每日一题）" class="headerlink" title="788 旋转数字（20220925每日一题）"></a>788 旋转数字（20220925每日一题）</h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目中已经给出了大致意思，要想数字每个位上的数都旋转后还能成为数字，那么这个数字必须包含且只能包含数字0，1，2，5，6，8，9。那么为什么前十个数中1，2，8，10不包含在旋转数字中呢？因为这4个数字旋转之后还是1，2，8，10，数值不变，这违反了旋转数字的定义。从这我们可以看出，要想数字旋转之后数值要改变，不能只包含1，2，8，0，还必须至少包含2，5，6，9中的一个，那么我们只要判断从1到n中的数字中有几个数是由上述8个数字组成，并且至少包含一个2，5，6，9.</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int rotatedDigits(int n) &#123;
        int res = 0;
        vector&lt;int&gt; f(10, 0);
        f[2] = 1;
        f[5] = 1;
        f[6] = 1;
        f[9] = 1;

        f[1] = 2;
        f[0] = 2;
        f[8] = 2;
        for(int i = 1; i &lt;= n; i++)&#123;
            int t = i;
            int a = 0, b = 0;
            while(t)&#123;
                if(f[t % 10] == 1) a = 1;
                else if(f[t % 10] == 2) b = 1;
                else break;
                t /= 10;
            &#125;
            if(!t &amp;&amp; a) res++;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 77. 组合</title>
    <url>/posts/d1540be5.html</url>
    <content><![CDATA[<h1 id="LeetCode-77-组合"><a href="#LeetCode-77-组合" class="headerlink" title="LeetCode 77. 组合"></a>LeetCode 77. 组合</h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><strong><strong><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></strong></strong></h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/77.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>这道题的意思就是一道排列组合的问题，即求 $C^k_n$这种数学问题，但是我们不是求值，而是求排列组合中每一种的组合。这样的题显然是一种枚举问题，遇到枚举问题 $一般$是用dfs和bfs的方法。在这道题中，我用了一个剪枝策略来加速寻找每一种组合。</p>
<p>如果剩下的数字个数加上当前数组大小小于要求值k，则返回</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; res;
public:
    void dfs(vector&lt;int&gt; arr, int index, int n, int sum, int k)&#123;
        if(sum == k)&#123;
            this-&gt;res.emplace_back(arr);
            return;
        &#125;
        if(index &gt; n) return;
        if(sum + n - index + 1 &lt; k) return;
        dfs(arr, index + 1, n, sum, k);
        arr.emplace_back(index);
        dfs(arr, index + 1, n, sum + 1, k);
    &#125;

    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        vector&lt;int&gt; arr;
        dfs(arr, 1, n, 0, k);
        return this-&gt;res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>Dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 791. 自定义字符串排序</title>
    <url>/posts/375eda24.html</url>
    <content><![CDATA[<h1 id="791-自定义字符串排序-20221113-每日一题"><a href="#791-自定义字符串排序-20221113-每日一题" class="headerlink" title="791. 自定义字符串排序(20221113 每日一题)"></a><strong><a href="https://leetcode.cn/problems/custom-sort-string/">791. 自定义字符串排序</a>(20221113 每日一题)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定两个字符串 <code>order</code> 和 <code>s</code> 。<code>order</code> 的所有单词都是 <strong>唯一</strong> 的，并且以前按照一些自定义的顺序排序。对 <code>s</code> 的字符进行置换，使其与排序的 <code>order</code> 相匹配。更具体地说，如果在 <code>order</code> 中的字符 <code>x</code> 出现字符 <code>y</code> 之前，那么在排列后的字符串中， <code>x</code> 也应该出现在 <code>y</code> 之前。返回 <em>满足这个性质的 <code>s</code> 的任意排列</em> 。</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">order = &quot;cba&quot;, s = &quot;abcd&quot;
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">&quot;cbad&quot;
</code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中给了我们两个字符串，一个优先级字符串，一个需要处理的字符串。从题目我们可以得出，我们需要处理的是有优先级定义的字符，对于其余字符我们可以不做处理，可以放在字符串最前面、可以放在字符串最后面、可以穿插在字符串之间。那么我们怎么处理这个有优先级的字符呢？</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>第一种想法就是我们先对$order$字符串中的字符定义优先级，其余字符的优先级都定义为最高优先级，然后对$s$字符串中的字符根据我们刚刚定义的优先级进行排序。但是这样有一个问题，这个想法涉及到排序，那么复杂度是$O(nlogn)$级别的，如果字符串长度太长会有一定的影响（但是题目中已经明确给出了字符串长度小于等于200，那这个思路也是可行的）。</p>
<h3 id="2（优化）"><a href="#2（优化）" class="headerlink" title="2（优化）"></a>2（优化）</h3><p>第二种想法就是一种$O(n)$的思路，我们没有必要使用排序来获得最终字符串，我们首先统计字符串$s$中每个字符有多少个，然后遍历$order$字符串，遍历到一个字符我们就将$s$中所有该字符加入目标字符串中，最后将没有出现在$order$字符串中但是出现在$s$字符串中的字符加入目标字符串即可。这个想法我们只要遍历两遍字符串$s$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    string customSortString(string order, string s) &#123;
        int O[26] = &#123;0&#125;;
        int letters[26] = &#123;0&#125;;
        string res;
        for(int i = 0; i &lt; s.size(); i++) letters[s[i] - &#39;a&#39;]++;
        for(int i = 0; i &lt; order.size(); i++)&#123;
            O[order[i] - &#39;a&#39;] = 1;
            while(letters[order[i] - &#39;a&#39;])&#123;
                res += order[i];
                letters[order[i] - &#39;a&#39;]--;
            &#125;
        &#125;
        for(int i = 0; i &lt; 26; i++)&#123;
            if(!O[i])&#123;
                while(letters[i]) &#123;
                    res += char(&#39;a&#39; + i);
                    letters[i]--;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 811. 子域名访问计数</title>
    <url>/posts/57efb66a.html</url>
    <content><![CDATA[<h1 id="LeetCode-811-子域名访问计数"><a href="#LeetCode-811-子域名访问计数" class="headerlink" title="LeetCode 811. 子域名访问计数"></a>LeetCode 811. 子域名访问计数</h1><h1 id="811-子域名访问计数-20221005每日一题"><a href="#811-子域名访问计数-20221005每日一题" class="headerlink" title="**811. 子域名访问计数(20221005每日一题)"></a><strong>**<a href="https://leetcode.cn/problems/subdomain-visit-count/">811. 子域名访问计数</a>(20221005每日一题)</strong></h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/811.png" alt="ProblemDescription"></p>
<p>网站域名 “<a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“ 由多个子域名组成。顶级域名为 “com” ，二级域名为 “<a href="http://leetcode.com/">leetcode.com</a>“ ，最低一级为 “<a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“。当访问域名 <code>&quot;discuss.leetcode.com&quot;</code>时，同时也会隐式访问其父域名 <code>&quot;leetcode.com&quot;</code> 以及 <code>&quot;com&quot;</code>。</p>
<p>计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。</p>
<p>例如，”9001 <a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“ 就是一个 计数配对域名 ，表示 <a href="http://discuss.leetcode.com/">discuss.leetcode.com</a> 被访问了 9001 次。</p>
<p>给你一个 <strong>计数配对域名</strong> 组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的 <strong>计数配对域名</strong>，并以数组形式返回。可以按 <strong>任意顺序</strong>返回答案。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们需要获得所有的域名以及他们的子域名，这个时候我们最好的想法就是用一个hash来存储所有出现过的域名，如果用其他方法不太现实。用hash来存储时我们不仅要考虑到出现的域名，我们还要考虑到这些域名出现的次数。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>对于每个字符串，首先，我们先正序遍历，找到这个网站出现的个数，然后再逆序遍历找到所有的子域名，找完所有的子域名之后记录每个子域名在当前情况下访问了几次，然后通过hash表进行累加。最后我们遍历hash表获取所有的域名以及他们的访问次数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-jsx">class Solution &#123;
public:
    vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) &#123;
        unordered_map&lt;string, int&gt; hash;
        for(auto c : cpdomains)&#123;
            int i = 0;
            string num;
                        //统计访问次数
            for(; i &lt; c.size(); i++)&#123;
                if(c[i] == &#39; &#39;) break;
                num += c[i];
            &#125;
            int times = stoi(num);
            string com;
                        //统计域名
            for(int j = c.size() - 1; j &gt; i; j--)&#123;
                if(c[j] == &#39;.&#39;)&#123;
                    hash[com] += times;
                &#125;
                com = c[j] + com;
            &#125;
            hash[com] += times;
        &#125;
        vector&lt;string&gt; res;
                //遍历hash表获取每个子域名以及访问次数
        for(auto ha : hash)&#123;
            string t = to_string(ha.second) + &#39; &#39; + ha.first;
            res.emplace_back(t);
        &#125;

        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 809. 情感丰富的文字</title>
    <url>/posts/c10480a9.html</url>
    <content><![CDATA[<h1 id="809-情感丰富的文字"><a href="#809-情感丰富的文字" class="headerlink" title="809. 情感丰富的文字"></a><a href="https://leetcode.cn/problems/expressive-words/description/">809. 情感丰富的文字</a></h1><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code>, <code>&quot;hi&quot; -&gt; &quot;hiii&quot;</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：”h”, “eee”, “ll”, “ooo”。对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 <code>c</code> ），然后往其中添加相同的字母 <code>c</code> 使其长度达到 3 或以上。</p>
<p>例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 <code>s = &quot;helllllooo&quot;</code>，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>。</p>
<p>输入一组查询单词，输出其中可扩张的单词数量。</p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><pre><code class="lang-cpp">s = &quot;heeellooo&quot;
words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]
</code></pre>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><pre><code class="lang-cpp">1
</code></pre>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>第一想法是利用双指针，但是双指针在这题代码写着比较麻烦我就放弃了，之后就打算用暴力的方法。首先我先记录字符串<code>s</code>中的连续字符以及个数，然后分别记录words中每个字符串中的连续字符以及个数，把他们分别存储到各自的数组中，如果两个数组的长度不一样，说明这words中的字符串不能扩充为字符串<code>s</code>。那么当数组长度一样时，我们就比较相同索引下的字符是否相等以及字符个数的比较。</p>
<p>如果字符不相等，说明该字符串不能扩充为<code>s</code>。假设<code>s</code>为<code>”aaabbb”</code>，这个时候存储<code>s</code>的数组为<code>[&#123;’a’, 3&#125;, &#123;’b’, 3&#125;]</code>，<code>words</code>中存在一个字符串为<code>”aaaccc”</code>，那么存储该字符串的数组为<code>[&#123;’a’, 3&#125;, &#123;’c’, 3&#125;]</code>。虽然两个字符串对应的数组相同，但是第二个字符串的第二个字符为<code>’c’</code>，不能变为<code>’b’</code>，因此该字符串不能转变为<code>s</code>。</p>
<p>再者，题目中有对扩张的要求。扩张的操作：选择一个字幕组（包含字母<code>c</code>），然后往其中添加相同的字母<code>c</code>使其长度达到3或以上。那么我们就可以的出，<code>”o”</code>不能转换成<code>”oo”</code>，因为<code>”oo”</code>的字符串长度小于3。但是<code>”oo”</code>可以转变成<code>”ooo&quot;</code>，因为<code>“ooo”</code>的长度等于3，这符合扩张的操作。因此我们可以得出如果<code>s</code>中相同的字符的长度大于3，并且这个长度大于<code>words</code>对应字符串对应索引的字符长度，那么就可以被扩张，反之，有一个特例，即上述提到的<code>”o”</code>和<code>”oo”</code>之间的转化。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>首先我们对<code>s</code>进行操作，即用数组记录每一个连续字符的字符以及他的长度。之后我们对<code>words</code>中的每一个字符串进行相同的操作，然后比较两个数组。如果符合上述要求，那么<code>words</code>中的字符串就可以扩充为<code>s</code>，反之，不能。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">class Solution &#123;
public:
    int expressiveWords(string s, vector&lt;string&gt;&amp; words) &#123;
        int res = 0;
        vector&lt;pair&lt;char, int&gt; &gt; str, tmp;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            if(str.empty()) &#123;
                str.emplace_back(pair&lt;char, int&gt; &#123;s[i], 1&#125;);
            &#125;else if(s[i] == str.back().first)&#123;
                str.back().second++;
            &#125;else&#123;
                str.emplace_back(pair&lt;char, int&gt; &#123;s[i], 1&#125;);
            &#125;
        &#125;

        for(auto word : words)&#123;
            tmp.clear();
            for(int i = 0; i &lt; word.size(); i++)&#123;
                if(tmp.empty() || word[i] != tmp.back().first)&#123;
                    tmp.emplace_back(pair&lt;char, int&gt; &#123;word[i], 1&#125;);
                &#125;else &#123;
                    tmp.back().second++;
                &#125;
            &#125;

            if(tmp.size() != str.size()) continue;
            int flag = 0;
            for(int i = 0; i &lt; str.size(); i++)&#123;
                if(str[i].first != tmp[i].first || ((str[i].second - tmp[i].second) == 1 &amp;&amp; str[i].second &lt; 3) || str[i].second - tmp[i].second &lt; 0) &#123;
                    flag = 1;
                    break;
                &#125;
            &#125;
            if(!flag) &#123;
                res++;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 831.隐藏个人信息</title>
    <url>/posts/ccbe430.html</url>
    <content><![CDATA[<h2 id="831-隐藏个人信息"><a href="#831-隐藏个人信息" class="headerlink" title="831.隐藏个人信息"></a><strong><a href="https://leetcode.cn/problems/masking-personal-information/">831.隐藏个人信息</a></strong></h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230401204338.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230401204410.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input1"><a href="#Input1" class="headerlink" title="Input1"></a>Input1</h3><pre><code class="lang-cpp">s = &quot;LeetCode@LeetCode.com&quot;
</code></pre>
<h3 id="Output1"><a href="#Output1" class="headerlink" title="Output1"></a>Output1</h3><pre><code class="lang-cpp">&quot;l*****e@leetcode.com&quot;
</code></pre>
<h3 id="Input2"><a href="#Input2" class="headerlink" title="Input2"></a>Input2</h3><pre><code class="lang-cpp">s = &quot;1(234)567-890&quot;
</code></pre>
<h3 id="Output2"><a href="#Output2" class="headerlink" title="Output2"></a>Output2</h3><pre><code class="lang-cpp">&quot;***-***-7890&quot;
</code></pre>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><code>s</code> 是一个 <strong>有效</strong> 的电子邮件或者电话号码</li>
<li>如果 <code>s</code> 是一个电子邮件：<ul>
<li><code>8 &lt;= s.length &lt;= 40</code></li>
<li><code>s</code> 是由大小写英文字母，恰好一个 <code>&#39;@&#39;</code> 字符，以及 <code>&#39;.&#39;</code> 字符组成</li>
</ul>
</li>
<li>如果 <code>s</code> 是一个电话号码：<ul>
<li><code>10 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 是由数字、空格、字符 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;+&#39;</code> 组成</li>
</ul>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道很简单的构造体，那么现在的问题就是应该怎么构造了。</p>
<p>首先，这个构造主要分为两种，一种是电子邮件，另一种是电话号码。</p>
<p>那么我们先来谈论怎么构造电子邮件：</p>
<p>题目的要求是让我们隐藏个人信息，即域名前面的自定义昵称给隐藏了。具体的是保留昵称的一头一尾，且要变成小写引文字母，其它位置都用“<strong>*</strong>”表示，不管其头尾之间有多少个字符都用“<strong>*</strong>”表示。处理完电子邮件的昵称部分，剩下的部分就简单了。我们只要将剩下的部分的大写字母变成小写字母即可，其它位置的字符不变。</p>
<p>构造电话号码：</p>
<p>题目的要求是根据电话号码的不同位数制定不同的开头，因此我们得先知道电话号码的位数。解决了位数我们就已经解决了隐藏完个人信息之后的电话号码的开头部分，末尾部分就是电话号码的后四位，这是固定的。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>这道题分为两种构造，我们得对不同的个人信息构造出不同的结果。因此<strong>第一步</strong>，我们得先判断这个个人信息是电子邮箱还是电话号码。根据提示我们得知，电话号码没有字母以及‘@’这个字符，因此我们只要根据所给字符串有没有’@’即可。这样我们既能判断是否是电子邮箱，也能确定‘@’的位置。</p>
<p>如果字符串存在‘@’，那么说明这个字符串是电子邮箱。由上面可知，我们确定了是电子邮箱的话我们就确定了‘@’字符的位置，这样我们就能确定昵称的一头一尾，那么我们就解决了构造隐藏个人信息字符串的昵称部分，注意将这一头一尾的字符大写变小写（如果字符是大写字母的话）。剩下部分我们只要遍历一遍即可，边遍历边判断是否是大写字母，如果是大写字母，那就把它变成小写，否则不变。</p>
<p>如果字符串不存在‘@’，那么说明这个字符串是电话号码。由上面可知，隐藏个人信息后的电话号码的开头部分是根据电话号码的位数而决定的，因此第一步就是确定电话号码的位数。确定完电话位数之后就确定目标字符串的开头，之后我们从后往前遍历个人信息字符串，获取最后<strong>四个数字字符</strong>，并把这四个数字字符加到末尾即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    string maskPII(string s) &#123;
        int flag = -1;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            if(s[i] == &#39;@&#39;) &#123;
                flag = i;
                break;
            &#125;
        &#125;

        string res;
        if(flag != -1)&#123;
            if(s[0] &gt;= &#39;A&#39; &amp;&amp; s[0] &lt;= &#39;Z&#39;) res += s[0] + 32;
            else res += s[0];
            res += &quot;*****&quot;;
            for(int i = flag - 1; i &lt; s.size(); i++)&#123;
                if(s[i] &gt;= &#39;A&#39; &amp;&amp; s[i] &lt;= &#39;Z&#39;) res += s[i] + 32;
                else res += s[i];
            &#125;
        &#125;else&#123;
            int nums = 0;
            for(int i = 0; i &lt; s.size(); i++)&#123;
                if(s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;) nums++;
            &#125;
            switch(nums)&#123;
                case 11:
                    res += &quot;+*-&quot;;
                    break;
                case 12:
                    res += &quot;+**-&quot;;
                    break;
                case 13:
                    res += &quot;+***-&quot;;
                    break;
            &#125;
            res += &quot;***-***-&quot;;
            string ans;
            for(int i = s.size() - 1; i &gt;= 0; i--)&#123;
                if(s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39; &amp;&amp; ans.size() &lt; 4)&#123;
                    ans += s[i];
                &#125;
            &#125;
            reverse(ans.begin(), ans.end());
            res += ans;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 895. 最大频率栈</title>
    <url>/posts/b7832ff7.html</url>
    <content><![CDATA[<h1 id="895-最大频率栈-20221130每日一题"><a href="#895-最大频率栈-20221130每日一题" class="headerlink" title="895. 最大频率栈(20221130每日一题)"></a><strong><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">895. 最大频率栈</a>(20221130每日一题)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>
<p>实现 <code>FreqStack</code> 类:</p>
<ul>
<li><code>FreqStack()</code> 构造一个空的堆栈。</li>
<li><code>void push(int val)</code> 将一个整数 <code>val</code> 压入栈顶。</li>
<li><code>int pop()</code> 删除并返回堆栈中出现频率最高的元素。<ul>
<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
</li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h3><pre><code class="lang-cpp">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">[null,null,null,null,null,null,null,5,7,5,4]
</code></pre>
<ul>
<li><code>0 &lt;= val &lt;= 1e9</code></li>
<li><code>push</code> 和 <code>pop</code> 的操作数不大于 <code>2 * 1e4</code>。</li>
<li>输入保证在调用 <code>pop</code> 之前堆栈中至少有一个元素。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中涉及到两个要点，一个是栈，一个是频率，即出现次数。题目要求我们实时弹出频率最高的那个元素，如果频率相同的元素，那就弹出先压入的元素。</p>
<p>那么我们怎么来确定每个元素的频率呢？考虑到元素范围是[0,1e9],那么如果使用数组来维护每个元素的频率，那就有可能会爆内存。后面显示push和pop的操作数不大于2e4，那么就代表元素种类最多是2e4，我们可以用哈希表来存。每push进一个元素的时候，我们就对其对应的出现次数进行+1操作，每pop一次时，我们对其对应的出现次数进行-1操作。这样我们就完成了对频率的维护。</p>
<p>剩下的问题是如何弹出频率最高的元素。我们目前已经完成了对push进来的数和pop出去的数的频率维护，我们要优先弹出频率最高的数。那么我们可以用数组来存储栈，数组的索引值代表着出现的频率，那么每当进行pop操作时，我们就优先弹出数组末尾的stack，因为数组末尾stack中存储的数都是频率最高的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class FreqStack &#123;
private:
    vector&lt;stack&lt;int&gt;&gt; vst;
    unordered_map&lt;int, int&gt; hash;

public:
    FreqStack() &#123;
        vst.clear();
    &#125;

    void push(int val) &#123;
        if(hash[val] == vst.size())&#123;
            vst.push_back(&#123;&#125;);
        &#125;
        vst[hash[val]].push(val);
        hash[val]++;
    &#125;

    int pop() &#123;
        while(vst.back().empty())&#123;
            vst.pop_back();
        &#125;
        int e = vst.back().top();
        vst.back().pop();
        hash[e]--;
        return e;
    &#125;
&#125;;

/**
 * Your FreqStack object will be instantiated and called as such:
 * FreqStack* obj = new FreqStack();
 * obj-&gt;push(val);
 * int param_2 = obj-&gt;pop();
 */
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 870. 优势洗牌</title>
    <url>/posts/672638a9.html</url>
    <content><![CDATA[<h1 id="870-优势洗牌-20221008每日一题"><a href="#870-优势洗牌-20221008每日一题" class="headerlink" title="870. 优势洗牌 (20221008每日一题)"></a><a href="https://leetcode.cn/problems/advantage-shuffle/">870. 优势洗牌</a> (20221008每日一题)</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/870.png" alt="Problem Description"></p>
<p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p>
<p>返回 nums1的<strong>任意</strong>排列，使其相对于 <code>nums2</code>的优势最大化。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们重排序<code>nums1</code>数组里的数字，使得<code>nums1</code>与<code>nums2</code>相同下标下<code>nums1</code>中的数比<code>nums2</code>中的数大，我们要求的是最大化情况下<code>nums1</code>数组中数字的排列情况。</p>
<p>这道题类似于田忌赛马，田忌赛马中有下等马、中等马、上等马，我们用我方的中等马配对对方的下等马，用上等马配对对方的中等马，用下等马配对对方的上等马。</p>
<p>在这里我们可以把数字看作马匹的好坏，我们需要用<code>nums1</code>中的较好的马匹配<code>nums2</code>中较差的马，用<code>nums1</code>中较差的马匹配nums2中最好的马。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>首先我们需要先排序，将<code>nums1</code>和<code>nums2</code>分别进行从小到大的顺序进行排序，其中<code>nums2</code>排序之后我们要记录每个数原来的索引值。这样方便将<code>nums1</code>的数放到对应的位置。</p>
<p>我们依次从<code>nums1</code>和<code>nums2</code>拿出<code>n1</code>和<code>n2</code></p>
<ul>
<li>如果<code>n1&gt;n2</code>，那么<code>n1</code>就相当于上等马，<code>n2</code>相等于中等马或者下等马，这个时候我们就在<code>n2</code>对应的索引值上放入<code>n1</code>的值。</li>
<li>如果<code>n1≤n2</code>，那么<code>n1</code>就相当于下等马，我们将其与<code>nums2</code>中的最优秀的马进行对比。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    static bool cmp(pair&lt;int, int&gt; &amp;A, pair&lt;int, int&gt; &amp;B)&#123;
        return A.first &lt; B.first;
    &#125;

    vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        int len = nums1.size();
        vector&lt;pair&lt;int, int&gt; &gt; arr(len);
        vector&lt;int&gt; res(len);
        for(int i = 0; i &lt; len; i++)&#123;
            arr[i] = pair&lt;int, int&gt; &#123;nums2[i], i&#125;;
        &#125;
        sort(nums1.begin(), nums1.end());
        sort(arr.begin(), arr.end(), this-&gt;cmp);

        int idx = 0, index = len - 1;
        for(int i = 0; i &lt; len; i++)&#123;
            if(nums1[i] &gt; arr[idx].first)&#123;
                res[arr[idx].second] = nums1[i];
                idx++;
            &#125;else &#123;
                res[arr[index].second] = nums1[i];
                index--;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/870-1.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 904. 水果成篮</title>
    <url>/posts/f4d40e11.html</url>
    <content><![CDATA[<h1 id="904-水果成篮-20221017-每日一题"><a href="#904-水果成篮-20221017-每日一题" class="headerlink" title="904. 水果成篮(20221017 每日一题)"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a>(20221017 每日一题)</h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/904-1.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目给我们一个数组，让我们找到最长的子串，使得这个子串中所包含的数字种类最多只有两个。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解决这种题，简单的就是利用双指针，一个在前，一个在后，在前的指针负责往队列里加数字，如果加完数字之后发现队列里的数字种类大于两种，那么我们就用后指针来弹出队列的数字，直到队列的数字种类小于等于2。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;
        int first = 0, last = 1;
        unordered_map&lt;int, int&gt; hash;
        hash[fruits[0]]++;
        int sum = 1, res = 0;
        while(last &lt; fruits.size())&#123;
            hash[fruits[last]]++;
            if(hash[fruits[last]] == 1)&#123;
                res = max(res, last - first);
                sum++;
                while(sum &gt; 2)&#123;
                    hash[fruits[first]]--;
                    if(hash[fruits[first]] == 0)&#123;
                        sum--;
                    &#125;
                    first++;
                &#125;
            &#125;
            last++;
        &#125;
        res = max(res, last - first);
        return res;
    &#125;
&#125;;
</code></pre>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/904-2.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 927. 三等分</title>
    <url>/posts/88c35860.html</url>
    <content><![CDATA[<h1 id="LeetCode-927-三等分"><a href="#LeetCode-927-三等分" class="headerlink" title="LeetCode 927. 三等分"></a>LeetCode 927. 三等分</h1><h1 id="927-三等分-20221006每日一题"><a href="#927-三等分-20221006每日一题" class="headerlink" title="**927. 三等分 (20221006每日一题)"></a><strong>**<a href="https://leetcode.cn/problems/three-equal-parts/">927. 三等分</a> (20221006每日一题)</strong></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/927.png" alt="Problem Description"></p>
<p>给定一个由 <code>0</code>和 <code>1</code>组成的数组 <code>arr</code> ，将数组分成  <strong>3 个非空的部分</strong>，使得所有这些部分表示相同的二进制值。</p>
<p>如果可以做到，请返回<strong>任何</strong><code>[i, j]</code>，其中 <code>i+1 &lt; j</code>，这样一来：</p>
<ul>
<li><code>arr[0], arr[1], ..., arr[i]</code> 为第一部分；</li>
<li><code>arr[i + 1], arr[i + 2], ..., arr[j - 1]</code> 为第二部分；</li>
<li><code>arr[j], arr[j + 1], ..., arr[arr.length - 1]</code> 为第三部分。</li>
<li>这三个部分所表示的二进制值相等。</li>
</ul>
<p>如果无法做到，就返回 <code>[-1, -1]</code></p>
<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。</p>
<p>这道题我将数组直接看作一个字符串，然后题目要求我们将这个字符串分成三份，这三份所形成的二进制的值要想等。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二进制的值的大小取决于该二进制中有效1的多少以及有效位数，如果有效位数越大，那么值也越大。</p>
<p>首先，我们得先确定这三部分的字符串是否可能会相等，最简单的方法就是判断1的个数，如果1的个数不是3的倍数，那么这个数组再怎么分割也不可能形成三个相等的二进制。因此我们可以先从1的个数来着手判断是否能分成三等份。</p>
<p>接下来我们将字符串分成三等份，每份中的1的个数相同，然后我们将相邻之间的0都放到前一份作为后导0，为什么这样放呢？是因为如果放到前导0毫无作用，前导0在值上面不起作用，放后导0如果值超过了，可以将后导0放到后一部分作为前导0降低二进制的值。</p>
<p>这样分完之后，我们统计三部份每份的后导0，因为最后一部分的0不能分给其他作为前导0，因此如果前两部分的后导0的个数只要有一个小于最后一份的后导0个数，那么这三等份就不可能是相等的，如果前两部分的后导0个数大于最后一份的，那么我们就将多余的0往后移作为前导0。</p>
<p>这样处理完之后，我们将每个二进制字符串的前导0删掉，这样剩下来的就是二进制的有效数，我们对比三个字符串，如果都相等，那么这个二进制数组可以三等分相等的二进制。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) &#123;
        vector&lt;int&gt; res(2, -1);
        int sum = 0;
        for(auto &amp; a : arr) sum += a;
        if(sum % 3) return res;
        if(sum == 0)&#123;
            res[0] = 0, res[1] = 2;
            return res;
        &#125;
        int zero[3] = &#123;0&#125;, tmp = 0, len[3];
        int idx = 0;
        string str[3];
        //先把二进制根据1分配，后面的分配后导0
        for(int i = 0; i &lt; arr.size(); i++)&#123;
            if(arr[i])&#123;
                tmp++;
                if(tmp == sum / 3 + 1) &#123;
                    idx++;
                    tmp = 1;
                &#125;
            &#125;
            str[idx] += char(&#39;0&#39; + arr[i]);
        &#125;
        for(int i = 0; i &lt; 3; i++)&#123;
            len[i] = str[i].size();
        &#125;
        for(int i = 0; i &lt; 3; i++)&#123;
            for(int j = str[i].size() - 1; j &gt;= 0; j--)&#123;
                if(str[i][j] == &#39;0&#39;) zero[i]++;
                else break;
            &#125;
        &#125;
        if(zero[0] &lt; zero[2] || zero[1] &lt; zero[2]) return res;
        for(int i = 0; i &lt; 3; i++)&#123;
            while(str[i][0] == &#39;0&#39;) str[i].erase(str[i].begin() + 0);
        &#125;
        for(int i = 0; i &lt; 2; i++)&#123;
            for(int j = 0; j &lt; zero[i] - zero[2]; j++) str[i].pop_back();
        &#125;
        if(str[0] != str[1] || str[0] != str[2]) return res;
        res[0] = len[0] - (zero[0] - zero[2]) - 1;
        res[1] = len[1] - (zero[1] - zero[2]) + len[0];
        return res;
    &#125;
&#125;;
</code></pre>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/927-1.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 周赛321</title>
    <url>/posts/edf0bb09.html</url>
    <content><![CDATA[<h1 id="LeetCode-周赛321"><a href="#LeetCode-周赛321" class="headerlink" title="LeetCode 周赛321"></a>LeetCode 周赛321</h1><h1 id="6245-找出中枢整数-Easy"><a href="#6245-找出中枢整数-Easy" class="headerlink" title="6245. 找出中枢整数(Easy)"></a><strong><a href="https://leetcode.cn/problems/find-the-pivot-integer/">6245. 找出中枢整数</a>(Easy)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给你一个正整数 <code>n</code> ，找出满足下述条件的 <strong>中枢整数</strong> <code>x</code> ：</p>
<ul>
<li><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</li>
</ul>
<p>返回中枢整数 **<code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h3><pre><code class="lang-cpp">n = 8
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">6
</code></pre>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>• <code>1 &lt;= n &lt;= 1000</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>作为周赛的前三题，直接暴力做即可，并且数据范围是<code>1</code>到<code>1000</code>，那么我们只要直接遍历一遍即可</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们用两个变量来存储<code>[1,x]</code>的总和，和<code>[x,n]</code>的总和。</p>
<p>然后每向后移一位，我们就增加前缀和并在后缀和减去相应的数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int pivotInteger(int n) &#123;
        int a = 0, b = (1 + n) * n / 2;
        for(int i = 1; i &lt;= n; i++)&#123;
            a += i;
            if(a == b) return i;
            b -= i;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<h1 id="6246-追加字符以获得子序列-Easy"><a href="#6246-追加字符以获得子序列-Easy" class="headerlink" title="6246. 追加字符以获得子序列(Easy)"></a><strong><a href="https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/">6246. 追加字符以获得子序列</a>(Easy)</strong></h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p>
<p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p>
<p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p>
<h2 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h3><pre><code class="lang-cpp">s = &quot;coaching&quot;, t = &quot;coding&quot;
</code></pre>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">4
</code></pre>
<h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题当时用的双指针的做法，为什么用双指针呢？因为我们要求子序列，那么我们就先求出当前t中在s的最长子序列，用双指针的做法，我们就能较快地求出这个长度。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int appendCharacters(string s, string t) &#123;
        int i = 0, j = 0;
        int len1 = s.size(), len2 = t.size();
        while(i &lt; len1 &amp;&amp; j &lt; len2)&#123;
            if(s[i] == t[j])&#123;
                i++;
                j++;
            &#125;else&#123;
                i++;
            &#125;
        &#125;
        return len2 - j;//j代表t在s中的连续最长子序列
    &#125;
&#125;;
</code></pre>
<h1 id="6247-从链表中移除节点-Medium"><a href="#6247-从链表中移除节点-Medium" class="headerlink" title="6247. 从链表中移除节点(Medium)"></a><strong><a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/">6247. 从链表中移除节点</a>(Medium)</strong></h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表的头节点 <code>head</code> 。</p>
<p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 <strong>严格更大</strong> 值的节点，则移除 <code>node</code> 。</p>
<p>返回修改后链表的头节点 <strong><code>head</code> </strong>。</p>
<h2 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input:"></a>Input:</h3><pre><code class="lang-cpp">head = [5,2,13,3,8]
</code></pre>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">[13,8]
</code></pre>
<ul>
<li>给定列表中的节点数目在范围 <code>[1, 105]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>在打周赛的过程中，看见这道题，第一反应，链表，那么我们就可以将这个链表存储到数组中进行操作。因为函数只传入链表头，不管我们对他的操作。</p>
<p>然后题目要求我们删除<code>node</code>，如果这个<code>node</code>的右侧有比这个<code>node</code>所存储的值更大的，那么我们还一种思路，就是从后往前遍历，找到当前已遍历过的数字中的最大值，依次把它放进数组。然后根据数组里的数字开始创造目标链表。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>首先我们将链表的数依次存储到数组<code>nums</code>中，然后再根据题目的规定从后往前遍历找到对应的数字，最后再将数组里的数字组合成链表。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* removeNodes(ListNode* head) &#123;
        vector&lt;int&gt; nums;
        while(head)&#123;
            nums.emplace_back(head-&gt;val);
            head = head-&gt;next;
        &#125;

        vector&lt;int&gt; arrs;
        int flag = 0;
        for(int i = nums.size() - 1; i &gt;= 0; i--)&#123;
            if(nums[i] &gt;= flag) &#123;
                arrs.emplace_back(nums[i]);
                flag = nums[i];
            &#125;
        &#125;
        reverse(arrs.begin(), arrs.end());
        ListNode* root = new ListNode(arrs[0]);
        ListNode* tmp, *p = root;
        for(int i = 1; i &lt; arrs.size(); i++)&#123;
            tmp = new ListNode(arrs[i]);
            p-&gt;next = tmp;
            p = p-&gt;next;
        &#125;
        return root;
    &#125;
&#125;;
</code></pre>
<h1 id="6248-统计中位数为-K-的子数组-Hard"><a href="#6248-统计中位数为-K-的子数组-Hard" class="headerlink" title="6248. 统计中位数为 K 的子数组(Hard)"></a><strong><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">6248. 统计中位数为 K 的子数组</a>(Hard)</strong></h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>
<p>统计并返回 <code>num</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。<ul>
<li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>
</ul>
</li>
<li>子数组是数组中的一个连续部分。</li>
</ul>
<h2 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input:"></a>Input:</h3><pre><code class="lang-cpp">nums = [3,2,1,4,5], k = 4
</code></pre>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output:"></a>Output:</h3><pre><code class="lang-cpp">3
</code></pre>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 1e5</code></li>
<li><code>1 &lt;= nums[i], k &lt;= n</code></li>
<li><code>nums</code> 中的整数互不相同</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>看到数据是<code>1e5</code>，那么这道题就不能用 $O(n^2)$的时间复杂度做，所以暴力的方法行不通。</p>
<p>那么我们可以考虑到前缀和的思路，记录<code>k</code>左边和右边的数组中大于<code>k</code>和小于<code>k</code>的数分别有多少，因为<code>nums</code>中的整数互不相同，那么这个操作的存在是有意义的。在这个限制条件下，这道题的难度就大大降低了。</p>
<h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><p>首先我们得找到这个<code>k</code>的索引值<code>idx</code>，这样我们就能将整个数组分为两部分，一部分是<code>k</code>的左边，另一部分是<code>k</code>的右边。</p>
<p>然后我们用前缀和的思想，我们在<code>[idx - 1, 0]</code>统计每个数据。假设我们遍历到位置<code>index1</code>，那么我们只要统计<code>[index1, idx - 1]</code>中大于<code>k</code>的数字个数<code>a</code>和小于<code>k</code>的数字个数<code>b</code>。根据前缀和的思路，我们统计完前半部分的所有前缀和<code>a-b</code>的值的个数。</p>
<p>之后我们遍历<code>k</code>的右边，我们每遍历到一个索引<code>index2</code>，我们就记录<code>[idx + 1, index2]</code>范围内大于<code>k</code>的数字个数与小于<code>k</code>的数字个数之差x，然后根据<code>x</code>的值找到<code>k</code>值左边对应的差值的个数。因为我们要保障<code>k</code>是<code>[index1,index2]</code>的中位数，那么我们只要保证<code>[index1,index2]</code>中小于<code>k</code>的数字个数为等于大于<code>k</code>的数字个数或者小于<code>k</code>的数字个数比大于<code>k</code>的数字个数小<code>1</code>即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int countSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;
        int res = 1;
        int idx = -1;
        for(int i = 0; i &lt; nums.size(); i++)&#123;
            if(nums[i] == k)&#123;
                idx = i;
                break;
            &#125;
        &#125;
        unordered_map&lt;int, int&gt; hash;
        hash[0] = 1;
        int a = 0, b = 0;
        for(int i = idx - 1; i &gt;= 0; i--)&#123;
            if(nums[i] &gt; k) a++;
            else b++;
            hash[a - b]++;
        &#125;
        int x = 0, y = 0;
        res += hash[1];
        res += hash[0] - 1;
        // for(auto it : hash)&#123;
        //     cout &lt;&lt; it.first &lt;&lt; &#39; &#39; &lt;&lt; it.second &lt;&lt; endl;
        // &#125;
        for(int i = idx + 1; i &lt; nums.size(); i++)&#123;
            if(nums[i] &gt; k) x++;
            else y++;
            // if(a - b == 1) res++;
            res += hash[y - x];
            res += hash[y - x + 1];
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>双指针</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 915.分割数组</title>
    <url>/posts/2acaafb0.html</url>
    <content><![CDATA[<h1 id="LeetCode-915-分割数组（Medium）"><a href="#LeetCode-915-分割数组（Medium）" class="headerlink" title="LeetCode 915.分割数组（Medium）"></a>LeetCode 915.分割数组（Medium）</h1><h1 id="915-分割数组（20221024每日一题）"><a href="#915-分割数组（20221024每日一题）" class="headerlink" title="915. 分割数组（20221024每日一题）"></a><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a>（20221024每日一题）</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/915-1.png" alt="Problem Description"></p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">nums = [5,0,3,8,6]
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">3
</code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们将一个数组分为左右两部分，并且左半边的最大值要小于等于右半边的最小值，那么我们需要用两个数组 $b, s$来维护这个最大值喝最小值， $b[i]$代表我维护的是在<code>[1,i</code>]之间的最大值，<code>s[i]</code>代表我维护的是在<code>[i,]</code>的最小值，之后我们只要遍历一次数组，当<code>b[i]&gt;s[i + 1]</code>的时候我们就能找到我们想要找到的分界点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int partitionDisjoint(vector&lt;int&gt;&amp; nums) &#123;
        int len = nums.size();
        vector&lt;int&gt; b(len, 0), s(len, 0);
        b[0] = nums[0];
        for(int i = 1; i &lt; len; i++) b[i] = max(b[i - 1], nums[i]);
        s[len - 1] = nums[len - 1];
        for(int i = len - 2; i &gt;= 0; i--) s[i] = min(s[i + 1], nums[i]);
        for(int i = 0; i &lt; len - 1; i++)&#123;
            if(b[i] &lt;= s[i + 1]) return i + 1;
        &#125;
        return len;
    &#125;
&#125;;
</code></pre>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/915-2.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 周赛336</title>
    <url>/posts/6a8f1feb.html</url>
    <content><![CDATA[<h1 id="LeetCode周赛336"><a href="#LeetCode周赛336" class="headerlink" title="LeetCode周赛336"></a>LeetCode周赛336</h1><h1 id="6315-统计范围内的元音字符串数-Easy"><a href="#6315-统计范围内的元音字符串数-Easy" class="headerlink" title="6315. 统计范围内的元音字符串数(Easy)"></a><strong><a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/description/">6315. 统计范围内的元音字符串数</a>(Easy)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p>
<p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code> 。</p>
<p>返回 <strong><code>words[i]</code> 是元音字符串的数目，其中 </strong><code>i</code> 在闭区间 <code>[left, right]</code> 内。</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">words = [&quot;are&quot;,&quot;amy&quot;,&quot;u&quot;], left = 0, right = 2
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">2
</code></pre>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
<li><code>words[i]</code> 仅由小写英文字母组成</li>
<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们直接从下标为<code>left</code>的字符串遍历到下标为<code>right</code>的字符串，在遍历的时候我们需要检验每个字符串是否符合要求。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们先用哈希表来存储元音字母，然后检验每个字符串的开头字母和结尾字母是不是元音字母即可。</p>
<p>时间复杂度是 $O(n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int vowelStrings(vector&lt;string&gt;&amp; words, int left, int right) &#123;
        int res = 0;
        unordered_map&lt;char, int&gt; hash;
        hash[&#39;a&#39;] = 1;
        hash[&#39;e&#39;] = 1;
        hash[&#39;i&#39;] = 1;
        hash[&#39;o&#39;] = 1;
        hash[&#39;u&#39;] = 1;
        for(int i = left; i &lt;= right; i++)&#123;
            if(hash[words[i][0]] &amp;&amp; hash[words[i].back()]) res++;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="6316-重排数组以得到最大前缀分数-Medium"><a href="#6316-重排数组以得到最大前缀分数-Medium" class="headerlink" title="6316. 重排数组以得到最大前缀分数(Medium)"></a><strong><a href="https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/">6316. 重排数组以得到最大前缀分数</a>(Medium)</strong></h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。你可以将 <code>nums</code> 中的元素按 <strong>任意顺序</strong> 重排（包括给定顺序）。</p>
<p>令 <code>prefix</code> 为一个数组，它包含了 <code>nums</code> 重新排列后的前缀和。换句话说，<code>prefix[i]</code> 是 <code>nums</code> 重新排列后下标从 <code>0</code> 到 <code>i</code> 的元素之和。<code>nums</code> 的 <strong>分数</strong> 是 <code>prefix</code> 数组中正整数的个数。</p>
<p>返回可以得到的最大分数</p>
<h2 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">[2,-1,0,1,-3,3,-3]
</code></pre>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">6
</code></pre>
<h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><ul>
<li><code>1 &lt;= nums.length &lt;= 1e5</code></li>
<li><code>-1e6 &lt;= nums[i] &lt;= 1e6</code></li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题让我们求前<code>n</code>个数使得这<code>n</code>个数的和大于<code>0</code>，要使得<code>n</code>最大，那么我们要保证这个和是整数，那么我们肯定希望这<code>n</code>个数里面的正数愈多越好，因此我们优先把正数放在前面。如果没有正数了，有<code>0</code>肯定优先加入<code>0</code>，这样不会影响这<code>n</code>个数之和的正负性，之后才添加负数，那么怎么添加呢？肯定不是添加最小的负数，因为你添加一个最小的负数说不定等价于添加<code>2</code>个甚至更多的负数，因此我们优先添加最大的负数，直到和变为非正数。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>对数组从大到小进行排序，然后依次遍历累加直到和为非正数。注意到<code>nums[i]</code>的范围是<code>[-1e6,1e6]</code>，个数为<code>1e5</code>，所以我们要注意累加的和的变量类型，<code>1e11</code>的数是超了<code>int</code>的。</p>
<p>排序的时间复杂度为 $O(nlogn)$，累加的时间复杂度为 $O(n)$。因此总的时间复杂度为 $O(nlogn)$。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int maxScore(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end(), [&amp;](int &amp;A, int &amp;B)&#123;
            return A &gt; B;
        &#125;);
        long long tmp = 0;
        int len = nums.size();
        for(int i = 0; i &lt; len; i++)&#123;
            tmp += nums[i];
            if(tmp &lt;= 0) return i;
        &#125;
        return len;
    &#125;
&#125;;
</code></pre>
<h1 id="6317-统计美丽子数组数目-Medium"><a href="#6317-统计美丽子数组数目-Medium" class="headerlink" title="6317. 统计美丽子数组数目(Medium)"></a><strong><a href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/">6317. 统计美丽子数组数目</a>(Medium)</strong></h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组<code>nums</code> 。每次操作中，你可以：</p>
<ul>
<li>选择两个满足 <code>0 &lt;= i, j &lt; nums.length</code> 的不同下标 <code>i</code> 和 <code>j</code> 。</li>
<li>选择一个非负整数 <code>k</code> ，满足 <code>nums[i]</code> 和 <code>nums[j]</code> 在二进制下的第 <code>k</code> 位（下标编号从 <strong>0</strong> 开始）是 <code>1</code> 。</li>
<li>将 <code>nums[i]</code> 和 <code>nums[j]</code> 都减去 <code>2k</code> 。</li>
</ul>
<p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code> 的数组，那么我们称它是一个 <strong>美丽</strong> 的子数组。</p>
<p>请你返回数组 <code>nums</code> 中 <strong>美丽子数组</strong> 的数目。</p>
<p>子数组是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p>
<h2 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">[4,3,1,2,4]
</code></pre>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">2
</code></pre>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目的意思是让我们求美丽子数组的个数，美丽子数组中的数字在二进制每一位上都是偶数，比如<code>[3,1,2]</code>中，用二进制表示是<code>[11,1,10]</code>，二进制中每一位都有两个<code>[2,2]</code>，两个<code>2</code>分别代表有<code>2</code>个 $2^1$和2个 $2^0$。因为只有个数是偶数时我们才能在删减操作使得数组中的数都为<code>0</code>，如果数组是<code>[3,1,1]</code>，二进制表示是<code>[11,1,1]</code>，二进制中每一位的表示是<code>[1,3]</code>，表示有<code>1</code>个 $2^1$和<code>3</code>个 $2^0$，这样的数组进行删减操作之后还会剩下<code>1</code>个 $2^1$和<code>1</code>个 $2^0$，得不到完美数组。</p>
<p>相当于我们要使美丽数组中的数异或和为<code>0</code>.</p>
<ul>
<li><p>异或</p>
<p>  异或的性质就是两个数相同时为<code>0</code>，不同时为<code>1</code>即</p>
<p>  0 ^ 0 = 0</p>
<p>  1 ^ 0 = 1</p>
<p>  0 ^ 1 = 1</p>
<p>  1 ^ 1 = 0</p>
</li>
</ul>
<p>那么这道题就可以转换成有多少个子数组的异或和为<code>0</code>.</p>
<h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><p>这边我是参考了前缀和的思想。</p>
<p>先用一个数组来维护从头到当前位置所有数的异或和，比如用样例给的数组<code>[4,3,1,2,4]</code>，那么他的前缀异或和就是<code>[4,7,6,4,0]</code>。记录完之后我们就要开始统计每一个异或和他在前缀异或和中出现了多少次。</p>
<p>要求美丽子数组的话我们就需要统计后面出现多少次与当前相同的异或和。为什么要找到相同的呢？比如说上面给的样例，有两个相同的异或和<code>4</code>，第一个<code>4</code>的异或和是<code>nums[0]</code>，第二个异或和是<code>nums[0]^nums[1]^nums[2]^nums[3]</code>。相同的两个数字进行异或操作之后的结果是<code>0</code>，那么<code>nums[0]^(nums[0]^nums[1]^nums[2]^nums[3])</code>之和也是<code>0</code>，<code>nums[0]^(nums[0]^nums[1]^nums[2]^nums[3])=0</code>等价于<code>nums[0]^nums[0]^nums[1]^nums[2]^nums[3]=0</code>，因为相同的数异或之后等于<code>0</code>，那么<code>nums[0]</code>可以消除，因此上面的等式等价于<code>nums[1]^nums[2]^nums[3]=0</code>，这样就有了一个美丽子数组。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-sql">class Solution &#123;
public:
    long long beautifulSubarrays(vector&lt;int&gt;&amp; nums) &#123;
        int len = nums.size();
        vector&lt;int&gt; num(len, 0);
        num[0] = nums[0];
        for(int i = 1; i &lt; len; i++)&#123;
            num[i] = num[i - 1] ^ nums[i];
        &#125;
        unordered_map&lt;int ,int&gt; hash;//记录每个异或和出现的个数
        for(int i = 0; i &lt; len; i++)&#123;
            hash[num[i]]++;
        &#125;
        long long res = hash[0];
        for(int i = 0; i &lt; len; i++)&#123;
            hash[num[i]]--;//进行删减操作是为了不让前面的异或和影响到后面的累加
            res += hash[num[i]];
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="2589-完成所有任务的最少时间-Hard"><a href="#2589-完成所有任务的最少时间-Hard" class="headerlink" title="2589. 完成所有任务的最少时间(Hard)"></a><strong><a href="https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/">2589. 完成所有任务的最少时间</a>(Hard)</strong></h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>你有一台电脑，它可以 <strong>同时</strong> 运行无数个任务。给你一个二维整数数组 <code>tasks</code> ，其中 <code>tasks[i] = [starti, endi, durationi]</code> 表示第 <code>i</code> 个任务需要在 <strong>闭区间</strong> 时间段 <code>[starti, endi]</code> 内运行 <code>durationi</code> 个整数时间点（但不需要连续）。</p>
<p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p>
<p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p>
<h2 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-sql">[[2,3,1],[4,5,1],[1,5,2]]
</code></pre>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-sql">2
</code></pre>
<h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><ul>
<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>
<li><code>tasks[i].length == 3</code></li>
<li><code>1 &lt;= starti, endi &lt;= 2000</code></li>
<li><code>1 &lt;= durationi &lt;= endi - starti + 1</code></li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>参考灵神大佬说的话，像这种区间题一般都是根据右端点从小到大进行排序。</p>
<p>这道题在写的时候想到排序，但是没考虑到数据范围就没有莽上去A，不应该。看了直播回放之后自己写一次AC。</p>
<p>这道题主要是贪心的想法，我们根据排序之后区间从头开始遍历，我们每遍历一个区间的时候，我们得优先把CPU时间选在末尾，因为我们不能保障左端点之间能够有交集，但是我们能保证右端能够产生交集，而要减少CPU运行时间，交集的区间要越大越好，因此我们优先把CPU时间放在每个区间的右端。</p>
<h2 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h2><p>根据右端进行排序，然后依次遍历，我们遍历到每个区间时，先考虑这段区间之中有多少个区间已经有CPU在使用了，然后将还需要的时间划分到区间的右端，最后统计有多少时间使用CPU即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-sql">class Solution &#123;
public:
    int findMinimumTime(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) &#123;
        sort(tasks.begin(), tasks.end(), [&amp;](vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;
            return A[1] &lt; B[1];
        &#125;);
        vector&lt;int&gt; f(2001, 0);
        int len = tasks.size();
        int res = 0;
        for(int i = 0; i &lt; len; i++)&#123;
            int tmp = 0;
            for(int j = tasks[i][0]; j &lt;= tasks[i][1]; j++)&#123;
                tmp += f[j];
            &#125;
            if(tmp &gt;= tasks[i][2]) continue;
            tmp = tasks[i][2] - tmp;
            // cout &lt;&lt; tmp &lt;&lt; endl;
            for(int j = tasks[i][1]; j &gt;= tasks[i][0]; j--)&#123;
                if(!f[j])&#123;
                    f[j] = 1;
                    tmp--;
                    res++;
                    if(!tmp) break;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>周赛</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 周赛345</title>
    <url>/posts/bcc7d896.html</url>
    <content><![CDATA[<h1 id="6430-找出转圈游戏输家"><a href="#6430-找出转圈游戏输家" class="headerlink" title="6430.找出转圈游戏输家"></a><a href="https://leetcode.cn/contest/weekly-contest-345/problems/find-the-losers-of-the-circular-game/">6430.找出转圈游戏输家</a></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514112241.png" alt="Img"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code>n = 5, k = 2
</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code>[4,5]
</code></pre><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code>以下为游戏进行情况：
1）第 1 个朋友接球，第 1 个朋友将球传给距离他顺时针方向 2 步的玩家 —— 第 3 个朋友。
2）第 3 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 2 个朋友。
3）第 2 个朋友将球传给距离他顺时针方向 6 步的玩家 —— 第 3 个朋友。
4）第 3 个朋友接到两次球，游戏结束。
</code></pre><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们用哈希表来存储每个朋友是否接到过球，因为第二次接球的时候游戏就结束了，因此我们不用记录每个朋友接过多少次球，只要记录是否接过球即可。然后每传一次球，就将相应的位置的哈希值置为<code>1</code>，直到该位置本身就是<code>1</code>时退出传球。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; circularGameLosers(int n, int k) &#123;
        vector&lt;int&gt; ans;
        vector&lt;int&gt; t(n, 0);
        t[0] = 1;
        int f = 0;
        for(int i = 1; ; i++)&#123;
            if(t[(i * k + f) % n]) break;
            else &#123;
                t[(i * k + f) % n] = 1;
                f = (i * k + f) % n;
            &#125;
        &#125;
        for(int i = 0; i &lt; n; i++) &#123;
            if(!t[i])&#123;
                ans.emplace_back(i + 1);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="6431-相邻值的按位异或"><a href="#6431-相邻值的按位异或" class="headerlink" title="6431. 相邻值的按位异或"></a><a href="https://leetcode.cn/contest/weekly-contest-345/problems/neighboring-bitwise-xor/">6431. 相邻值的按位异或</a></h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514120633.png" alt="Img"></p>
<h2 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><pre><code>derived = [1,1,0]
</code></pre><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><pre><code>true
</code></pre><h3 id="Explain-1"><a href="#Explain-1" class="headerlink" title="Explain"></a>Explain</h3><pre><code>能够派生得到 [1,1,0] 的有效原始二进制数组是 [0,1,0] ：
derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 
derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1
derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0
</code></pre><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>n == derived.length</code></li>
<li><code>1 &lt;= n &lt;= 1e5</code></li>
<li><code>derived</code> 中的值不是 0 就是 1 。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚开始看到这道题的时候愣了一下，因为不知道如何下手，但是一看到这个题是一个二进制，我就当作模拟来做了<br>开始做题目之前，我们先熟悉一下什么是异或，下面我会提供一个异或表<br>| a | b | a⊕b |<br>| — | — | — |<br>| 0 | 0 | 0 |<br>| 0 | 1 | 1 |<br>| 1 | 0 | 1 |<br>| 1 | 1 | 0 |</p>
<p>由此我们看到如果我们知道了数值<code>a</code>的值和异或的值，那么<code>b</code>的值就是唯一的，根据这个特性我们就可以解决这个问题</p>
<p>我们先假设original数组中的第一个数是<code>0</code>，然后我们根据提供的derived数组慢慢往后推original每一个位置的值(因为我们已经知道了异或的值和一个异或的参数)，直到最后一个数，然后根据最后一个数推第一个数，因为题目中有说明，derived的最后一个数是original数组中的最后一个数和第一个数异或得到，因此我们推到最后可以获得original的第一个数，如果和我们假设的数一样，那么说明构造成功，否则就重新假设第一个数是<code>1</code>再构造一遍。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    bool doesValidArrayExist(vector&lt;int&gt;&amp; derived) &#123;
        int f = 0, len = derived.size();
        for(int i = 0; i &lt; len; i++)&#123;
            if(derived[i] == 0)&#123;
                continue;
            &#125;else&#123;
                if(f == 1) f = 0;
                else f = 1;
            &#125;
        &#125;
        if(f == 0) return true;
        f = 1;
        for(int i = 0; i &lt; len; i++)&#123;
            if(derived[i] == 0)&#123;
                continue;
            &#125;else&#123;
                if(f == 1) f = 0;
                else f = 1;
            &#125;
        &#125;
        if(f == 1) return true;
        return false;
    &#125;
&#125;;
</code></pre>
<h1 id="6433-矩阵中移动的最大次数"><a href="#6433-矩阵中移动的最大次数" class="headerlink" title="6433. 矩阵中移动的最大次数"></a><a href="https://leetcode.cn/contest/weekly-contest-345/problems/maximum-number-of-moves-in-a-grid/">6433. 矩阵中移动的最大次数</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514122530.png" alt=""></p>
<h2 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514122603.png" alt="Img"></p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><pre><code>grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
</code></pre><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><pre><code>3
</code></pre><h3 id="Explain-2"><a href="#Explain-2" class="headerlink" title="Explain"></a>Explain</h3><pre><code>可以从单元格 (0, 0) 开始并且按下面的路径移动：
- (0, 0) -&gt; (0, 1).
- (0, 1) -&gt; (1, 2).
- (1, 2) -&gt; (2, 3).
可以证明这是能够移动的最大次数。
</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 1000</code></li>
<li><code>4 &lt;= m * n &lt;= 1e5</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 1e6</code></li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>做题第一要点，得看清题意，做完之后和群内大佬聊天，发现很多人都是因为题意没有理清就做，然后贡献了一发wa<br>题目中已经很明确的说了，是在<strong>第一列的任一位置</strong>，而不是在任意位置，因此起点只能在第一列<br>然后根据题目的意思，我们可以知道移动的三个方向如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514122455.png" alt="Img"></p>
<p>知道这些后我们应该怎么做呢？如果我们单纯的暴力bfs做的话，搜索树节点将会非常多，会导致我们超时（第一次提交的时候因为这个导致TLE），那我们应该怎么节省时间呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514123358.png" alt="Img"></p>
<p>我想到了之前学dp的时候有一个记忆化搜索，这道题也可以使用，因为我们遍历是从左往右一列一列的遍历，所以不同的点遍历到相同的点时所需的步数是一样的，就像上图的<code>2-&gt;4</code>和<code>3-&gt;4</code>，都只需要一步，如果<code>2-&gt;4</code>已经遍历下去，那么<code>3-&gt;4</code>之后还需要遍历吗？不需要，因为就算遍历下去，这条路径的最优解也就是之前已经遍历过的最优解，属于是重复遍历，因此我们可以对每一个节点进行标记，如果一个点之前遍历过了就可以直接停止往下遍历。<br>这样的话，因为每一个点最多遍历一次，因此时间复杂度最高也就是$O(m*n)$。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>我们用dfs的方法进行搜索获取全局最优解。</p>
<p>首先用一个二维数组对grid图进行标记，0为未曾到达过，1为已经遍历过，如果我们到达一个点时，这个点的标记是1，那么说明我们可以停止在这条路径上继续搜索。<br>每到达一个点的时候，我们根据路径的三个方向继续往下搜索，直到不能继续搜索。<br>搜索要注意的有以下两点</p>
<ol>
<li>搜索的起点是第一列</li>
<li>搜索的路径中数字是逐渐变大的</li>
</ol>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; f;
    int ans;
    int rows, cols;
    int dx[3] = &#123;-1, 0, 1&#125;;

    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int row, int col)&#123;
        if(f[row][col]) return;
        f[row][col] = 1;
        ans = max(ans, col);
        for(int i = 0; i &lt; 3; i++)&#123;
            if(dx[i] + row &gt;= 0 &amp;&amp; dx[i] + row &lt; rows &amp;&amp; col + 1 &lt; cols &amp;&amp; grid[dx[i] + row][col + 1] &gt; grid[row][col])&#123;
                dfs(grid, row + dx[i], col + 1);
            &#125;
        &#125;
    &#125;

    int maxMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        rows = grid.size(), cols = grid[0].size();
        ans = 0;
        f.assign(grid.begin(), grid.end());
        for(int i = 0; i &lt; rows; i++)&#123;
            for(int j = 0; j &lt; cols; j++) f[i][j] = 0;
        &#125;
        for(int i = 0; i &lt; rows; i++)&#123;
            dfs(grid, i, 0);
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="6432-统计完全连通分量的数量"><a href="#6432-统计完全连通分量的数量" class="headerlink" title="6432. 统计完全连通分量的数量"></a><a href="https://leetcode.cn/contest/weekly-contest-345/problems/count-the-number-of-complete-components/">6432. 统计完全连通分量的数量</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514124139.png" alt="Img"></p>
<h2 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a>Sample</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230514124156.png" alt="Img"></p>
<h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><pre><code>n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
</code></pre><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><pre><code>3
</code></pre><h3 id="Explain-3"><a href="#Explain-3" class="headerlink" title="Explain"></a>Explain</h3><pre><code>如上图所示，可以看到此图所有分量都是完全连通分量。
</code></pre><h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h3><ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li><code>ai != bi</code><br>不存在重复的边</li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>在做题目之前我们得搞清楚两个概念</p>
<p>什么是连通分量</p>
<blockquote>
<p>如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 连通分量</p>
</blockquote>
<p>什么是完全连通分量</p>
<blockquote>
<p>如果连通分量中每对节点之间都存在一条边，则称其为 完全连通分量</p>
</blockquote>
<p>知道上述的要求之后，我们就可以开始球了，如果是求连通分量应该怎么求？很明显，使用并查集，我们利用并查集就可以知道哪些点是相邻的。<br>那如果要求完全连通分量呢？我们已经知道了并查集可以求连通分量，那么我们只要在此基础上遍历同一个集合中的所有点的邻居数量即可，如果每一个点的邻居数量刚好是集合大小-1，那么就说明这个集合中的点集是完全连通分量</p>
<h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><p>我们首先遍历edges数组，遍历的时候不断合并边的两端，合并的时候也要合并两个端点所在集合的集合size<br>通过并查集，我们已经能获取所有点集和每个点集的size大小了，因此我们再遍历一次所有点，如果这个点的邻居数量不是点集大小-1，那么我们就将这个点集标记为<code>-1</code>，说明这个点集不可能是完全连通分量。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">//并查集模板
int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点
int find(int x)
&#123;
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;

// 初始化，假定节点编号是1~n
for (int i = 1; i &lt;= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
</code></pre>
<pre><code class="lang-cpp">//维护size的并查集
int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点
int find(int x)
&#123;
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
&#125;

// 初始化，假定节点编号是1~n
for (int i = 1; i &lt;= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
</code></pre>
<pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; p, size;

    int find(int x)&#123;
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    &#125;

    int countCompleteComponents(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;
        int len = edges.size();
        vector&lt;int&gt; sum(n);
        p.resize(n);
        size.resize(n);

        for(int i = 0; i &lt; n; i++) &#123;
            p[i] = i;
            size[i] = 1;
        &#125;

        for(int i = 0; i &lt; len; i++)&#123;
            sum[edges[i][0]]++;
            sum[edges[i][1]]++;
            int a = find(edges[i][0]);
            int b = find(edges[i][1]);
            if(a != b) &#123;
                size[b] += size[a];
                p[a] = b;
            &#125;
        &#125;

        vector&lt;int&gt; f(n, 0);
        for(int i = 0; i &lt; n; i++)&#123;
            if(p[i] != i) f[i] = -1;
            if(sum[i] != size[p[i]] - 1) f[p[i]] = -1;
        &#125;
        int ans = 0;
        for(int i = 0; i &lt; n; i++)&#123;
            if(f[i] != -1) ans++;
        &#125;

        return ans;

    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>周赛</tag>
        <tag>并查集</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 周赛339</title>
    <url>/posts/fa30027a.html</url>
    <content><![CDATA[<h1 id="LeetCode-周赛339"><a href="#LeetCode-周赛339" class="headerlink" title="LeetCode 周赛339"></a>LeetCode 周赛339</h1><h1 id="6362-最长平衡子字符串"><a href="#6362-最长平衡子字符串" class="headerlink" title="6362.最长平衡子字符串"></a><strong><a href="https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/">6362.最长平衡子字符串</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230402130249.png" alt=""></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">s = &quot;01000111&quot;
</code></pre>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">6
</code></pre>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">最长的平衡子字符串是 &quot;000111&quot; ，长度为 6 。
</code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题刚开始没看清题意，以为1可以在0的前面以及可以混插而不是0和1分开，如果是这样的话，我们只要记录字符串中0的个数和1的个数，最后返回数量较小的两倍即可。</p>
<p>但是上面的Sample和我最开始的思路不同。所以我就仔细看了看题目。</p>
<p>题目中明确提出了，在平衡子字符串中，<strong>所有的<code>0</code>都在<code>1</code>之前</strong>。因此我就换了一种做法，把字符串分若干段，再综合每一段的最大值取最优解。</p>
<p>那么问题来了，怎么分段呢？根据上面的要求，所有的0都在1之前，那么只要出现1在0之前，就分一个段落。</p>
<p>分完段落求结果即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int findTheLongestBalancedSubstring(string s) &#123;
        int res = 0, tmp0 = 0, tmp1 = 0;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            if(i != 0 &amp;&amp; s[i] == &#39;0&#39; &amp;&amp; s[i - 1] == &#39;1&#39;)&#123;
                res = max(res, min(tmp0, tmp1) * 2);
                tmp0 = 0;
                tmp1 = 0;
            &#125;
            if(s[i] == &#39;0&#39;) tmp0++;
            else tmp1++;
        &#125;
        res = max(res, min(tmp0, tmp1) * 2);
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="6363-转换二维数组"><a href="#6363-转换二维数组" class="headerlink" title="6363.转换二维数组"></a><strong>6363.转换二维数组</strong></h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230402131000.png" alt=""></p>
<h2 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">nums = [1,3,4,1,2,3,1]
</code></pre>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">[[1,3,4,2],[1,3],[1]]
</code></pre>
<h3 id="Explain-1"><a href="#Explain-1" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">根据题目要求可以创建包含以下几行元素的二维数组：
- 1,3,4,2
- 1,3
- 1
nums 中的所有元素都有用到，并且每一行都由不同的整数组成，所以这是一个符合题目要求的答案。
可以证明无法创建少于三行且符合题目要求的二维数组。
</code></pre>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题的数据量不到200，直接暴力贪心即可。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们先统计数组中每个数的个数，然后就开始循环遍历数组。</p>
<p>在每次循环中我们用一个一维数组来标记每个数是否已经被压入数组中，每压入一个数时，我们就在之前用来记录数组中每个数的个数的数组中的对应位置将其减1，如果是0，那么说明该数已经不能再被使用。最后如果记录个数的数组中所有值都是0，那么就停止循环。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; findMatrix(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        unordered_map&lt;int, int&gt; hash;
        vector&lt;int&gt; tmp;
        for(auto num : nums) hash[num]++;
        int len = nums.size(), k = 0;
        while(1)&#123;
            vector&lt;int&gt; f(201, 0);
            for(int num : nums)&#123;
                if(hash[num] &amp;&amp; !f[num])&#123;
                    f[num] = 1;
                    hash[num]--;
                    tmp.emplace_back(num);
                &#125;
            &#125;
            if(!tmp.empty())&#123;
                res.emplace_back(tmp);
            &#125;else break;
            tmp.clear();
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="6364-老鼠和奶酪"><a href="#6364-老鼠和奶酪" class="headerlink" title="6364.老鼠和奶酪"></a><strong><a href="https://leetcode.cn/problems/mice-and-cheese/">6364.老鼠和奶酪</a></strong></h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230402131723.png" alt=""></p>
<h2 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><pre><code class="lang-cpp">reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
</code></pre>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><pre><code class="lang-cpp">15
</code></pre>
<h3 id="Explain-2"><a href="#Explain-2" class="headerlink" title="Explain"></a>Explain</h3><pre><code class="lang-cpp">这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。
总得分为 4 + 4 + 3 + 4 = 15 。
15 是最高得分。
</code></pre>
<h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>1 &lt;= n == reward1.length == reward2.length &lt;= 1e5</code></li>
<li><code>1 &lt;= reward1[i], reward2[i] &lt;= 1000</code></li>
<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题的意思就是在老鼠1只能吃k个的情况下两只老鼠最多能吃多少个。</p>
<p>贪心，直接贪即可，那么怎么贪呢？</p>
<p>老鼠1只能吃k个，那我们肯定让老鼠1吃分高的，但是如果老鼠1吃的相对高的分老鼠2对应的分也高应该怎么办呢？我们就让老鼠1吃分相对于老鼠2的分较高的。那么怎么体现这个相对呢？很简单，我们只要做差即可，差值越大，那么说明老鼠1吃这个蛋糕得到的分就越划算。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>首先我们对每个蛋糕对应的老鼠1和老鼠2的得分进行做差，然后从大到小进行排序。要想使最后的分数最高，那么我们只要让老鼠1吃排完序后的前k个蛋糕即可。剩余的蛋糕老鼠2吃。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">class Solution &#123;
public:
    int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) &#123;
        int len = reward1.size();
        vector&lt;pair&lt;int, int&gt;&gt; nums(len);
        for(int i = 0; i &lt; len; i++)&#123;
            nums[i] = pair&lt;int, int&gt; &#123;i, reward1[i] - reward2[i]&#125;;
        &#125;
        sort(nums.begin(), nums.end(), [&amp;](pair&lt;int, int&gt; &amp;A, pair&lt;int, int&gt; &amp;B)&#123;
            return A.second &gt; B.second;
        &#125;);
        int res = 0;
        for(int i = 0; i &lt; len; i++)&#123;
            if(i &lt; k) res += reward1[nums[i].first];
            else res += reward2[nums[i].first];
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>排序</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 面试题17.09. 第k个数</title>
    <url>/posts/478d69b2.html</url>
    <content><![CDATA[<h1 id="LeetCode-面试题17-09-第k个数"><a href="#LeetCode-面试题17-09-第k个数" class="headerlink" title="LeetCode 面试题17.09. 第k个数"></a>LeetCode 面试题17.09. 第k个数</h1><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1709.png" alt="Problem Description"></p>
<p>这道题让我们从一个只包含质因子3，5，7数字的数组中，根据从小到大排序，获取第k个数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚开始的想法，就是根据一个优先队列，让较小的数优先弹出，但是这种做法比较麻烦的就是你的优先队列需要维护的长度是k*3，而优先队列的复杂度是O(log n)，再结合需要经过3k次的插入以及多次弹出，复杂度不够理想。</p>
<p>后面看了一个大佬的做法，利用三指针，用三个指针p3,p5,p7分别记录上次乘以质因子3、5、7的数组index，然后比较num[p3] <em> 3, num[p5] </em> 5, num[p7] * 7三者的大小，谁最小就更新哪个质因子的指针。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int getKthMagicNumber(int k) &#123;
        int *nums = new int[k + 1];
        nums[0] = 1;
        int p3 = 0, p5 = 0, p7 = 0;
        for(int i = 1; i &lt; k; i++)&#123;
            nums[i] = min(nums[p3] * 3, min(nums[p5] * 5, nums[p7] * 7));
            if(nums[i] == nums[p3] * 3) p3++;
            else if(nums[i] == nums[p5] * 5) p5++;
            else if(nums[i] == nums[p7] * 7) p7++;
        &#125;
        return nums[k - 1];
    &#125;
&#125;;
</code></pre>
<p>这里出现了一个问题，当时我没有考虑到去重，这边的顺序是1,3,5,7,9,15,15,21,21,….。会有重复的数字，我们在每次比较中，要将每个最小值的质因子的指针更新。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int getKthMagicNumber(int k) &#123;
        int *nums = new int[k + 1];
        nums[0] = 1;
        int p3 = 0, p5 = 0, p7 = 0;
        for(int i = 1; i &lt; k; i++)&#123;
            nums[i] = min(nums[p3] * 3, min(nums[p5] * 5, nums[p7] * 7));
            if(nums[i] == nums[p3] * 3) p3++;
            if(nums[i] == nums[p5] * 5) p5++;
            if(nums[i] == nums[p7] * 7) p7++;
        &#125;
        return nums[k - 1];
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多线程开发</title>
    <url>/posts/610d7d3d.html</url>
    <content><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><ul>
<li>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的UNIX进程只是多线程程序的一个特例，该进程只包含一个线程）</li>
<li>进程是CPU分配资源的最小单位，线城市操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程（LWP：Light Weight Process），在Linux环境下线程的本质仍是进程</li>
<li>查看指定进程的LWP号: ps -Lf pid</li>
</ul>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li>进程间的信息难以共享。由于出去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息共享</li>
<li>调用fork()来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制注入内存页表和文件描述符表之类的多种进程属性，这意味着fork()调用在时间上的开销依然不菲</li>
<li>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可</li>
<li>创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</li>
</ul>
<h3 id="线程和进程虚拟地址空间"><a href="#线程和进程虚拟地址空间" class="headerlink" title="线程和进程虚拟地址空间"></a>线程和进程虚拟地址空间</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230504153052.png" alt=""></p>
<h3 id="线程之间共享和非共享资源"><a href="#线程之间共享和非共享资源" class="headerlink" title="线程之间共享和非共享资源"></a>线程之间共享和非共享资源</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230504153152.png" alt=""></p>
<h3 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h3><ol>
<li><p>获取线程ID</p>
<p> <code>pthread_t pthread_self(void);</code></p>
<ul>
<li>功能：获取当前的线程的线程ID</li>
</ul>
</li>
<li><p>比较线程</p>
<p> <code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p>
<ul>
<li>功能：比较两个线程ID是否相等</li>
</ul>
</li>
<li><p>线程创建</p>
<p> <code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code></p>
<ul>
<li>功能：创建一个子线程</li>
<li>参数：<ul>
<li><code>thread</code>：传出参数，线程创建成功后，子线程的线程ID被写入该变量中</li>
<li><code>attr</code>：需要设置线程的属性，一般是默认，NULL</li>
<li><code>start_routine</code>：函数指针，子线程需要处理的逻辑代码</li>
<li><code>arg</code>：给第三个参数使用，传参</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功 返回0</li>
<li>失败 返回错误号。这个错误号和之前的errno不太一样。获取错误号的信息：<code>char *strerror(int errnum);</code></li>
</ul>
<p>函数示例</p>
<pre><code class="lang-cpp">void* callback(void *arg)&#123;
  printf(&quot;child thread... arg=%d\n&quot;, *(int *)arg);
  return NULL;
&#125;

int main()&#123;

  // 创建一个子线程
  pthread_t tid;
  int num = 10;
  int ret = pthread_create(&amp;tid, NULL, callback, (void *) &amp;num);

  if(ret != 0)&#123;
      char *errstr = strerror(ret);
      printf(&quot;%s\n&quot;, errstr);
  &#125;

  sleep(3);

  for(int i = 0; i &lt; 5; i++)&#123;
      printf(&quot;%d\n&quot;, i);
  &#125;

  return 0;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>终止线程</p>
<p> <code>void pthread_exit(void *retval);</code></p>
<ul>
<li>功能：终止一个线程，在哪个线程调用，就表示终止哪个线程</li>
<li><p>参数</p>
<ul>
<li><code>retval</code>：需要传递一个指针，作为返回值，可以在<code>pthread_join()</code>中获得</li>
</ul>
<p>函数示例：</p>
<pre><code class="lang-cpp">void * callback(void *arg)&#123;
  printf(&quot;child thread %ld\n&quot;, pthread_self());
  return NULL;
&#125;

int main()&#123;

  // 创建一个子线程
  pthread_t tid;

  int ret = pthread_create(&amp;tid, NULL, callback, NULL);

  if(ret != 0)&#123;
      char *strerr = strerror(ret);
      printf(&quot;%s\n&quot;, strerr);
      // exit(0);
  &#125;

  // 主线程

  printf(&quot;tid: %ld, parent thread %ld\n&quot;, tid, pthread_self());

  for(int i = 0; i &lt; 4; i++)&#123;
      printf(&quot;%d\n&quot;, i);
  &#125;

  // 让主线程退出
  pthread_exit(NULL);
  // 当主线程退出时，不会影响其它线程
      printf(&quot;main exit\n&quot;);//不会打印

  return 0;
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<ol>
<li>连接线程</li>
</ol>
<p><code>int pthread_join(pthread_t thread, void **retval);</code></p>
<ul>
<li>功能：和一个已经终止的线程连接（为什么要连接？是为了释放结束线程的资源）。回收子线程的资源<ul>
<li>特点：<ul>
<li>这个函数是阻塞函数，调用一次只能回收一个子线程</li>
<li>一般在主线程中使用</li>
</ul>
</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>thread：需要回收子线程的ID</li>
<li><p>retval：二级指针，接收子线程退出时的返回值</p>
<ul>
<li><p>为什么要用二级指针</p>
<p>  在 <strong><code>pthread_join</code></strong> 函数中，第二个参数需要传递一个指向线程返回值的指针。由于线程的返回值类型是 <strong><code>void *</code></strong>，因此需要传递一个指针来存储线程的返回值。</p>
<p>  但是，线程返回值的指针需要在调用 <strong><code>pthread_join</code></strong> 函数之前分配内存空间。如果将指针作为参数传递给 <strong><code>pthread_join</code></strong> 函数，则无法在函数内部为其分配内存空间。</p>
<p>  为了解决这个问题，<strong><code>pthread_join</code></strong> 函数使用了一个指向指针的指针，也就是二级指针。在调用 <strong><code>pthread_join</code></strong> 函数之前，需要在调用线程的代码中为返回值指针分配内存空间，并将其地址赋值给二级指针。这样，在调用 <strong><code>pthread_join</code></strong> 函数时，可以传递指向二级指针的指针作为第二个参数，并在函数内部通过该指针来操作返回值指针。</p>
<p>  因此，<strong><code>pthread_join</code></strong> 函数的第二个参数是一个二级指针，以便在函数内部对返回值指针进行操作，而不需要在函数外部为其分配内存空间。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功 返回0</li>
<li>失败 返回错误号，用strerror接收错误信息</li>
</ul>
</li>
</ul>
<p>函数示例</p>
<pre><code class="lang-cpp">int value = 10;

void * callback(void *arg)&#123;
    printf(&quot;child thread %ld\n&quot;, pthread_self());
    sleep(3);

    // return NULL;

    // int value = 10;
    pthread_exit((void*)&amp;value);
&#125;

int main()&#123;

    // 创建一个子线程
    pthread_t tid;

    int ret = pthread_create(&amp;tid, NULL, callback, NULL);

    if(ret != 0)&#123;
        char *strerr = strerror(ret);
        printf(&quot;%s\n&quot;, strerr);
        // exit(0);
    &#125;

    // 主线程

    printf(&quot;tid: %ld, parent thread %ld\n&quot;, tid, pthread_self());

    for(int i = 0; i &lt; 4; i++)&#123;
        printf(&quot;%d\n&quot;, i);
    &#125;

    // 主线程调用pthread_join()回收子线程的资源
    int *thread_value;
    ret = pthread_join(tid, (void **)&amp;thread_value);

    if(ret != 0)&#123;
        char *strerr = strerror(ret);
        printf(&quot;%s\n&quot;, strerr);
        // exit(0);
    &#125;
    printf(&quot;exit data: %d\n&quot;, *thread_value);
    printf(&quot;回收子线程资源成功!\n&quot;);

    // 让主线程退出
    pthread_exit(NULL);
    // 当主线程退出时，不会影响其它线程

    return 0;
&#125;
</code></pre>
<ol>
<li><p>线程分离</p>
<p> <code>int pthread_detach(pthread_t thread);</code></p>
<ul>
<li>功能：分离一个线程。被分离的线程在终止的时候会自动释放资源，返回系统<ol>
<li>不能多次分离，会产生不可预料的行为</li>
<li>不能去连接已经分离的线程，如果连接，则会报错</li>
</ol>
</li>
<li>参数<ul>
<li>thread：需要分离的线程ID</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功 返回0</li>
<li>失败 返回错误ID</li>
</ul>
<p>函数示例：</p>
<pre><code class="lang-cpp">void *callback()&#123;

  printf(&quot;child thread...\n&quot;);

  return NULL;
&#125;

int main()&#123;

  pthread_t tid;
  int ret = pthread_create(&amp;tid, NULL, callback, NULL);

  if(ret != 0)&#123;
      char *strerr = strerror(ret);
      printf(&quot;%s\n&quot;, strerr);
  &#125;

  // 输出主线程和子线程的id
  printf(&quot;child thread : %ld, main thread : %ld\n&quot;, tid, pthread_self());

  // 设置子线程分离后，对分离的子线程进行连接 pthread_join();
  ret = pthread_detach(tid);

  if(ret != 0)&#123;
      char *strerr = strerror(ret);
      printf(&quot;%s\n&quot;, strerr);
  &#125;

  ret = pthread_join(tid, NULL);
  if(ret != 0)&#123;
      char *strerr = strerror(ret);
      printf(&quot;%s\n&quot;, strerr);
  &#125;

  pthread_exit(NULL);

  return 0;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>线程取消</p>
<p> <code>int pthread_cancel(pthread_t thread);</code></p>
<ul>
<li>功能：取消线程（让线程终止）<ul>
<li>取消某个线程，可以终止某个线程的运行，但是并不是马上终止，而是当子线程执行到一个取消点，线程才会终止调用</li>
<li>取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点</li>
</ul>
</li>
<li>参数<ul>
<li>thread：需要取消的线程号</li>
</ul>
</li>
<li>返回值<ul>
<li>成功 返回0</li>
<li>失败 返回错误编号</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><ol>
<li><p>初始化线程属性变量</p>
<p> <code>int pthread_attr_init(pthread_attr_t *attr);</code></p>
</li>
<li><p>释放线程属性资源</p>
<p> <code>int pthread_attr_destroy(pthread_attr_t *attr);</code></p>
</li>
<li><p>获取线程分离的状态属性</p>
<p> <code>int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</code></p>
</li>
<li><p>设置线程分离的状态属性</p>
<p> <code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></p>
</li>
</ol>
<p>函数示例</p>
<pre><code class="lang-cpp">void *callback()&#123;

    printf(&quot;child thread...\n&quot;);

    return NULL;
&#125;

int main()&#123;

    pthread_t tid;

    // 创建一个线程属性的变量
    pthread_attr_t attr;

    // 初始化属性变量
    pthread_attr_init(&amp;attr);

    // 设置属性
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);

    // 获取线程的栈的大小

    size_t size;
    pthread_attr_getstacksize(&amp;attr, &amp;size);

    printf(&quot;stacksize is %ld\n&quot;, size);

    // 创建一个子线程
    int ret = pthread_create(&amp;tid, NULL, callback, NULL);

    if(ret != 0)&#123;
        char *strerr = strerror(ret);
        printf(&quot;%s\n&quot;, strerr);
    &#125;

    // 输出主线程和子线程的id
    printf(&quot;child thread : %ld, main thread : %ld\n&quot;, tid, pthread_self());

    // 释放线程属性资源
    pthread_attr_destroy(&amp;attr);

    pthread_exit(NULL);

    return 0;
&#125;
</code></pre>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便携的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其它线程修改的变量</li>
<li>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同意共享资源的其他线程不应中断该片段的执行</li>
<li>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li>
</ul>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><ul>
<li>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex时mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问</li>
<li>互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。</li>
<li>一旦线程锁定互斥量，随机成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能有多个相关变量组成）会使用不同的互斥量，每一线程在访问统一资源时将采用如下协议：<ul>
<li>针对共享资源锁定互斥量</li>
<li>访问共享资源</li>
<li>对互斥量解锁</li>
</ul>
</li>
<li>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230504225849.png" alt=""></p>
<h3 id="互斥量函数介绍"><a href="#互斥量函数介绍" class="headerlink" title="互斥量函数介绍"></a>互斥量函数介绍</h3><ol>
<li><p>初始化互斥量</p>
<p> <code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></p>
<ul>
<li>参数：<ul>
<li>mutex：需要初始化的互斥量变量</li>
<li>attr：互斥量的相关属性，一般NULL，默认</li>
</ul>
</li>
<li>restrict：修饰符，被修饰的指针，不能由另外的一个指针进行操作</li>
</ul>
</li>
<li><p>释放互斥量的资源</p>
<p> <code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
</li>
<li><p>加锁</p>
<p> <code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p>
<p> 阻塞的，如果有一个线程已经枷锁了，那么其他线程只能阻塞等待</p>
</li>
<li><p>尝试加锁</p>
<p> <code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<p> 如果加锁失败，不会阻塞，会直接返回</p>
</li>
<li><p>解锁</p>
<p> <code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p>
</li>
</ol>
<p>函数示例</p>
<pre><code class="lang-cpp">// 创建一个互斥量

pthread_mutex_t mutex;

int tickets = 1000;

void *sellticket(void *args)&#123;
    // 卖票
    while(1)&#123;
        // 加锁
        pthread_mutex_lock(&amp;mutex);
        if(tickets &gt; 0)&#123;
            // usleep(500);
            printf(&quot;%ld 正在卖第 %d 门票\n&quot;, pthread_self(), 1001 - tickets);
            tickets--;
                       // 解锁
            pthread_mutex_unlock(&amp;mutex);
        &#125;else&#123;
                       // 解锁
            pthread_mutex_unlock(&amp;mutex);
            break;
        &#125;
    &#125;
    return NULL;
&#125;

int main()&#123;

    //  初始化互斥量
    pthread_mutex_init(&amp;mutex, NULL);

    // 创建三个子线程
    pthread_t tid1, tid2, tid3;

    pthread_create(&amp;tid1, NULL, sellticket, NULL);
    pthread_create(&amp;tid2, NULL, sellticket, NULL);
    pthread_create(&amp;tid3, NULL, sellticket, NULL);

    // 回收子线程的资源
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);

    // 设置线程分离
    // pthread_detach(tid1);
    // pthread_detach(tid2);
    // pthread_detach(tid3);

    pthread_exit(NULL); // 退出主线程

    // 释放互斥量资源
    pthread_mutex_destroy(&amp;mutex);

    return 0;
&#125;
</code></pre>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。</li>
<li>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁</li>
<li><p>死锁的几种场景：</p>
<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li><p>多线程多锁，抢占锁资源</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230505131235.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</li>
<li>在对数据的读写操作中，更多的是读操作，写操作比较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现</li>
<li>读写锁的特点：<ul>
<li>如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作</li>
<li>如果有其他线程写数据，则其他线程都不要允许读、写操作</li>
<li>写是独占的，写的优先级更高</li>
</ul>
</li>
</ul>
<p>读写锁函数</p>
<ol>
<li><p>初始化读写锁</p>
<p> <code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p>
</li>
<li><p>释放锁资源</p>
<p> <code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>上读锁</p>
<p> <code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>尝试上读锁</p>
<p> <code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)</code></p>
</li>
<li><p>上写锁</p>
<p> <code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>尝试上写锁</p>
<p> <code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>解锁</p>
<p> <code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p>
</li>
</ol>
<p>函数示例</p>
<pre><code class="lang-cpp">int num = 1;
// pthread_mutex_t mutex;
pthread_rwlock_t rwlock;

void *writeNum(void *args)&#123;

    while(1)&#123;
        pthread_rwlock_wrlock(&amp;rwlock);
        num++;
        printf(&quot;++write, tid : %ld, num : %d\n&quot;, pthread_self(), num);
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(100);
    &#125;

    return NULL;
&#125;

void *readNum(void *args)&#123;

    while(1)&#123;
        // num++;
        pthread_rwlock_rdlock(&amp;rwlock);
        printf(&quot;===read, tid : %ld, num : %d\n&quot;, pthread_self(), num);
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(100);
    &#125;

    return NULL;
&#125;

int main()&#123;

    // 创建3个写线程，5个读线程

    pthread_rwlock_init(&amp;rwlock, NULL);

    pthread_t wtids[3], rtids[5];

    for(int i = 0; i &lt; 3; i++)&#123;
        pthread_create(&amp;wtids[i], NULL, writeNum, NULL);
    &#125;

    // 设置线程分离
    for(int i = 0; i &lt; 3; i++)&#123;
        pthread_detach(wtids[i]);
    &#125;

    for(int i = 0; i &lt; 5; i++)&#123;
        pthread_create(&amp;rtids[i], NULL, readNum, NULL);
    &#125;

    for(int i = 0; i &lt; 5; i++)&#123;
        pthread_detach(rtids[i]);
    &#125;

    pthread_exit(NULL);

    pthread_rwlock_destroy(&amp;rwlock);

    return 0;
&#125;
</code></pre>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ol>
<li><p>初始化条件变量</p>
<p> <code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></p>
</li>
<li><p>释放条件变量</p>
<p> <code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p>
</li>
<li><p>等待条件响应</p>
<p> <code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></p>
</li>
<li><p>设置等待时间</p>
<p> <code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p>
</li>
<li><p>唤醒个别等待线程</p>
<p> <code>int pthread_cond_signal(pthread_cond_t *cond);</code></p>
</li>
<li><p>唤醒所有等待线程</p>
<p> <code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p>
</li>
</ol>
<p>函数示例</p>
<pre><code class="lang-cpp">struct node&#123;
    int num;
    struct node *next;
&#125;;

// 头节点
struct node *head = NULL;

// 创建一个互斥量

pthread_mutex_t mutex;

// 创建条件变量
pthread_cond_t cond;

void * producer(void *args)&#123;

    // 不断的创建新的节点，添加到链表中
    while(1)&#123;

        pthread_mutex_lock(&amp;mutex);
        struct node *newNode = (struct node*)malloc(sizeof(struct node));
        newNode-&gt;next = head;
        head=newNode;
        newNode-&gt;num = (int)(rand()) * 1000;
        printf(&quot;add node, num : %d, tid : %ld\n&quot;, newNode-&gt;num, pthread_self());

        // 只要生产一个，就通知消费者消费
        pthread_cond_signal(&amp;cond);

        pthread_mutex_unlock(&amp;mutex);
        usleep(100);
    &#125;

    return NULL;
&#125;

void *customer(void *args)&#123;

    while(1)&#123;
        // 保存头节点的指针
        pthread_mutex_lock(&amp;mutex);
        struct node *tmp = head;

        // 判断是否有数据
        if(head == NULL)&#123;
            // 没有数据 需要等待
            pthread_mutex_unlock(&amp;mutex);
            pthread_cond_wait(&amp;cond, &amp;mutex);
        &#125;else&#123;
            head = head-&gt;next;
            printf(&quot;delete node, num : %d, tid : %ld\n&quot;, tmp-&gt;num, pthread_self());
            free(tmp);
            pthread_mutex_unlock(&amp;mutex);
            usleep(100);
        &#125;


    &#125;
    return NULL;
&#125;

int main()&#123;

    // 创建5个生产者线程，5个消费者线程

    pthread_t ptids[5], ctids[5];

    pthread_mutex_init(&amp;mutex, NULL);
    pthread_cond_init(&amp;cond, NULL);

    for(int i = 0; i &lt; 5; i++)&#123;
        pthread_create(&amp;ptids[i], NULL, producer, NULL);
        pthread_detach(ptids[i]);
    &#125;

    for(int i = 0; i &lt; 5; i++)&#123;
        pthread_create(&amp;ctids[i], NULL, customer, NULL);
        pthread_detach(ctids[i]);
    &#125;

    // while(1)&#123;
    //     sleep(10);
    // &#125;

    while(1)&#123;
        sleep(10);
    &#125;

    pthread_mutex_destroy(&amp;mutex);
    pthread_cond_destroy(&amp;cond);

    pthread_exit(NULL);

    return 0;
&#125;
</code></pre>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol>
<li><p>初始化</p>
<p> <code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></p>
</li>
<li><p>释放资源</p>
<p> <code>int sem_destroy(sem_t *sem);</code></p>
</li>
<li><p>对信号量进行加锁，调用一次对信号量的值-1，如果值为0，则阻塞</p>
<p> <code>int sem_wait(sem_t *sem);</code></p>
</li>
<li><p>尝试-1</p>
<p> <code>int sem_trywait(sem_t *sem);</code></p>
</li>
<li><p>设置等待时间（存疑）</p>
<p> <code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></p>
</li>
<li><p>对信号量解锁，调用一次对信号量的值+1</p>
<p> <code>int sem_post(sem_t *sem);</code></p>
</li>
<li><p>获取信号量的值</p>
<p> <code>int sem_getvalue(sem_t *sem, int *sval);</code></p>
</li>
</ol>
<p>函数示例：</p>
<pre><code class="lang-cpp">struct node&#123;
    int num;
    struct node *next;
&#125;;

// 头节点
struct node *head = NULL;

// 创建一个互斥量

pthread_mutex_t mutex;
// 创建两个信号量
sem_t psem, csem;

void * producer(void *args)&#123;
    // 不断的创建新的节点，添加到链表中
    while(1)&#123;
        sem_wait(&amp;psem);
        pthread_mutex_lock(&amp;mutex);
        struct node *newNode = (struct node*)malloc(sizeof(struct node));
        newNode-&gt;next = head;
        head=newNode;
        newNode-&gt;num = (int)(rand()) * 1000;
        printf(&quot;add node, num : %d, tid : %ld\n&quot;, newNode-&gt;num, pthread_self());
        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;csem);
        usleep(100);
    &#125;

    return NULL;
&#125;

void *customer(void *args)&#123;

    while(1)&#123;
        // 保存头节点的指针
        sem_wait(&amp;csem);
        pthread_mutex_lock(&amp;mutex);
        struct node *tmp = head;

        head = head-&gt;next;
        printf(&quot;delete node, num : %d, tid : %ld\n&quot;, tmp-&gt;num, pthread_self());
        free(tmp);
        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;psem);
        usleep(100);

    &#125;
    return NULL;
&#125;

int main()&#123;

    // 创建5个生产者线程，5个消费者线程

    pthread_t ptids[5], ctids[5];

    pthread_mutex_init(&amp;mutex, NULL);

    sem_init(&amp;psem, 0, 8);
    sem_init(&amp;csem, 0, 0);

    for(int i = 0; i &lt; 5; i++)&#123;
        pthread_create(&amp;ptids[i], NULL, producer, NULL);
        pthread_detach(ptids[i]);
    &#125;

    for(int i = 0; i &lt; 5; i++)&#123;
        pthread_create(&amp;ctids[i], NULL, customer, NULL);
        pthread_detach(ctids[i]);
    &#125;

    // while(1)&#123;
    //     sleep(10);
    // &#125;

    while(1)&#123;
        sleep(10);
    &#125;

    pthread_mutex_destroy(&amp;mutex);

    pthread_exit(NULL);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>多线程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-条件查询&amp;排序查询</title>
    <url>/posts/8fbff935.html</url>
    <content><![CDATA[<p>本篇博客常用数据表</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220437.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220453.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220506.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220522.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220534.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220543.png" alt="Img"></p>
<p><strong>语法</strong></p>
<pre><code class="lang-SQL">SELECT 查询列表 FROM 表名 WHERE 筛选条件;
</code></pre>
<p>分类：</p>
<ol>
<li>按条件表达式筛选<br> 条件运算符：&gt; &lt; = != &lt;&gt; &gt;= &lt;= </li>
<li>按逻辑表达式筛选<br> 逻辑运算符：&amp;&amp; || ! and or not</li>
<li>模糊查询<br> like, between and, in, is null</li>
</ol>
<h2 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h2><p><strong>案例</strong>：查询工资&gt;12000的员工信息</p>
<pre><code class="lang-SQL">SELECT * FROM employees WHERE salary &gt; 12000;
</code></pre>
<p><strong>案例</strong>：查询部门编号不等于90号的员工名和部门编号</p>
<pre><code class="lang-SQL">SELECT last_name, department_id FROM employees WHERE department_id &lt;&gt; 90;
</code></pre>
<h2 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h2><p><strong>案例</strong>：查询工资在10000到20000之间的员工名、工资以及奖金</p>
<pre><code class="lang-SQL">SELECT last_name, salary, ISNULL(commission_pct, 0.0) * salary
FROM employees
WHERE salary &gt;= 10000 and salary &lt;= 20000;
</code></pre>
<p><strong>案例</strong>：查询部门编号不是在90到110之间，或者工资高于15000的员工信息</p>
<pre><code class="lang-SQL">SELECT * 
FROM employees
WHERE (department_id &lt; 90 or department_id &gt; 110) or (salary &gt; 15000);
</code></pre>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><strong>通配符</strong></p>
<ul>
<li>%：任意多个字符</li>
<li>_：任意单个字符</li>
</ul>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p><strong>案例</strong>：查询员工名中包含字符<code>a</code>的员工信息</p>
<pre><code class="lang-SQL">SELECT *
FROM employees
WHERE last_name LIKE &#39;%a%&#39;;
</code></pre>
<p><strong>案例</strong>：查询员工字名中第三个字符为<code>e</code>，第五个字符为<code>a</code>的员工名和工资</p>
<pre><code class="lang-SQL">SELECT first_name, salary
FROM employees
WHERE first_name LIKE &#39;__e_a%&#39;;
</code></pre>
<h3 id="BETWEEN-AND"><a href="#BETWEEN-AND" class="headerlink" title="BETWEEN AND"></a>BETWEEN AND</h3><ul>
<li>使用<code>between and</code>可以提高语句的简洁度</li>
<li>包含临界值</li>
<li>临界值不能调换顺序</li>
</ul>
<p><strong>案例</strong>：查询员工编号在100到120之间的员工信息</p>
<pre><code class="lang-SQL">SELECT *
FROM employees
WHERE employee_id BETWEEN 100 AND 120;
</code></pre>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>含义：判断某字段的值是否属于<code>in</code>列表中的某一项<br>特点：</p>
<ol>
<li>使用<code>in</code>提高语句简洁度</li>
<li><code>in</code>列表中的值类型必须统一或兼容</li>
</ol>
<p><strong>案例</strong>：查询员工的工种编号是IT_PROT, AD_VP, AD_PRES中的一个员工名和工种编号</p>
<pre><code class="lang-SQL">SELECT last_name, job_id
FROM employees
WHERE job_id IN (&#39;IT_PROT&#39;, &#39;AD_VP&#39;, &#39;AD_PRES&#39;);
</code></pre>
<h3 id="IS-NULL"><a href="#IS-NULL" class="headerlink" title="IS NULL"></a>IS NULL</h3><blockquote>
<p>= 或 &lt;&gt; 不能用于判断null值<br>IS NULL或IS NOT NULL可以判断NULL值</p>
</blockquote>
<p><strong>案例</strong>：查询没有奖金的员工名和奖金率</p>
<pre><code class="lang-SQL">SELECT last_name, commission_pct
FROM employees
WHERE commission_pct IS NOT NULL;
</code></pre>
<blockquote>
<p>安全等于 &lt;=&gt;</p>
</blockquote>
<p><strong>案例</strong>：查询没有奖金的员工名和奖金率</p>
<pre><code class="lang-SQL">SELECT last_name, commission_pct
FROM employees
WHERE commission_pct &lt;=&gt; NULL;
</code></pre>
<h3 id="IS-NULL-和-lt-gt-的对比"><a href="#IS-NULL-和-lt-gt-的对比" class="headerlink" title="IS NULL 和 &lt;=&gt;的对比"></a>IS NULL 和 &lt;=&gt;的对比</h3><p><code>IS NULL</code>: 仅仅可以判断<code>NULL</code>值，建议使用<br><code>&lt;=&gt;</code>: 既可以判断<code>NULL</code>值，也可以判断普通的数值</p>
<h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>语法：</p>
<pre><code class="lang-SQL">SELECT 查询列表
FROM 表
[WHERE 筛选条件]
ORDER BY 排序列表 [ASC|DESC];
</code></pre>
<p>特点：</p>
<pre><code>- `ASC`代表升序，`DESC`代表降序，默认升序
- `ORDER BY`子句中可以支持单个字段、多个字段、表达式、函数、别名
- `ORDER BY`子句一般是放在查询语句的最后面，`LIMIT`子句除外
</code></pre><p><strong>案例</strong>：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</p>
<pre><code class="lang-SQL">SELECT *
FROM employees
WHERE email LIKE &#39;%e%&#39;
ORDER BY LENGTH(email) DESC, department_id ASC;
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-vector 上</title>
    <url>/posts/c57b077f.html</url>
    <content><![CDATA[<h2 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h2><p>容器：<code>vector</code></p>
<p>算法：<code>for_each</code></p>
<p>迭代器：<code>vector&lt;int&gt;::iterator</code></p>
<p>示例：</p>
<pre><code class="lang-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;

void MyPrint(int val)&#123;
    cout &lt;&lt; val &lt;&lt; endl;
&#125;

void test01() &#123;

    //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型
    vector&lt;int&gt; v;
    //向容器中放数据
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);

    //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
    //v.begin()返回迭代器，这个迭代器指向容器中第一个数据
    //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置
    //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型

    vector&lt;int&gt;::iterator pBegin = v.begin();
    vector&lt;int&gt;::iterator pEnd = v.end();

    //第一种遍历方式：
    while (pBegin != pEnd) &#123;
        cout &lt;&lt; *pBegin &lt;&lt; endl;
        pBegin++;
    &#125;


    //第二种遍历方式：
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; endl;
    &#125;
    cout &lt;&lt; endl;

    //第三种遍历方式：
    //使用STL提供标准遍历算法  头文件 algorithm
    for_each(v.begin(), v.end(), MyPrint);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="vector存放自定义数据类型"><a href="#vector存放自定义数据类型" class="headerlink" title="vector存放自定义数据类型"></a>vector存放自定义数据类型</h2><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例</strong>:</p>
<pre><code class="lang-cpp">#include &lt;vector&gt;
#include &lt;string&gt;

//自定义数据类型
class Person &#123;
public:
    Person(string name, int age) &#123;
        mName = name;
        mAge = age;
    &#125;
public:
    string mName;
    int mAge;
&#125;;
//存放对象
void test01() &#123;

    vector&lt;Person&gt; v;

    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);
    Person p5(&quot;eee&quot;, 50);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);

    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;
    &#125;
&#125;

//放对象指针
void test02() &#123;
    vector&lt;Person*&gt; v;

    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);
    Person p5(&quot;eee&quot;, 50);

    v.push_back(&amp;p1);
    v.push_back(&amp;p2);
    v.push_back(&amp;p3);
    v.push_back(&amp;p4);
    v.push_back(&amp;p5);

    for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        Person * p = (*it);
        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器"></a>vector容器嵌套容器</h2><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

//容器嵌套容器
void test01() &#123;
    vector&lt; vector&lt;int&gt; &gt;  v;

    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;
    vector&lt;int&gt; v4;

    for (int i = 0; i &lt; 4; i++) &#123;
        v1.push_back(i + 1);
        v2.push_back(i + 2);
        v3.push_back(i + 3);
        v4.push_back(i + 4);
    &#125;

    //将容器元素插入到vector v中
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);

    for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;
            cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++提高</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<pre><code>$ test
</code></pre>]]></content>
  </entry>
  <entry>
    <title>STL-vector 下</title>
    <url>/posts/b27c37e9.html</url>
    <content><![CDATA[<h2 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h2><p><strong>功能</strong>：</p>
<p>vector数据结构和<strong>数组非常相似</strong>，也成为<strong>单端数组</strong></p>
<p><strong>vector与普通数组的区别</strong>：</p>
<p>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></p>
<p><strong>动态扩展</strong>：</p>
<p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p>
<h2 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h2><p><strong>功能描述</strong>：</p>
<p>创建vector容器</p>
<p>函数原型：</p>
<ul>
<li><code>vector&lt;T&gt; v;</code>//采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());</code>//将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>//构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>//拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()&#123;
    vector&lt;int&gt; v1; //无参构造
    for (int i = 0; i &lt; 10; i++)    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);

    vector&lt;int&gt; v2(v1.begin(), v1.end());
    printVector(v2);

    vector&lt;int&gt; v3(10, 100);
    printVector(v3);

    vector&lt;int&gt; v4(v3);
    printVector(v4);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331131647.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  vector的多种构造方式没有可比性，灵活使用即可</p>
</li>
</ul>
<h2 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h2><p><strong>功能描述：</strong></p>
<p>给vector容器进行赋值</p>
<p>函数原型：</p>
<ul>
<li><code>vector &amp;operator=(const vector &amp;vec);</code>//重载等号操作符</li>
<li><code>assign(beg, end);</code>//将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>//将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//赋值操作
void test01()&#123;
    vector&lt;int&gt; v1; //无参构造
    for (int i = 0; i &lt; 10; i++)    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);

    vector&lt;int&gt;v2;
    v2 = v1;
    printVector(v2);

    vector&lt;int&gt;v3;
    v3.assign(v1.begin(), v1.end());
    printVector(v3);

    vector&lt;int&gt;v4;
    v4.assign(10, 100);
    printVector(v4);
&#125;

int main() &#123;
    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331131810.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  vector赋值方式比较简单，使用operator=，或者assign都可以</p>
</li>
</ul>
<h2 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h2><p><strong>功能描述</strong>：</p>
<p>对vector容量的容器和大小操作</p>
<p>函数原型：</p>
<ul>
<li><code>empty();</code>//判断容器是否为空</li>
<li><code>capacity();</code>//容器的容量</li>
<li><code>size();</code>//返回容器中元素的个数</li>
<li><code>resize(int num);</code>//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li><code>resize(int num, elem);</code>//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。//如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()&#123;
    vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 10; i++)    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);
    if (v1.empty())    &#123;
        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;
    &#125;    else    &#123;
        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;
        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;
    &#125;

    //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充
    v1.resize(15,10);
    printVector(v1);

    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除
    v1.resize(5);
    printVector(v1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331131911.png" alt=""></p>
<ul>
<li>总结<ul>
<li>判断是否为空 ——— empty</li>
<li>返回元素个数 ——— size</li>
<li>返回容器容量 ——— capacity</li>
<li>重新指定大小 ——— resize</li>
</ul>
</li>
</ul>
<h2 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h2><p><strong>功能描述：</strong></p>
<p>对vector容器进行插入、删除操作</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(elem);</code>//尾部插入元素elem</li>
<li><code>pop_back();</code>//删除最后一个元素</li>
<li><code>insert(cosnt_iterator pos, elem);</code>//迭代器指向位置pos插入元素elem</li>
<li><code>insert(const_iterator pos, int count, elem);</code>//迭代器指向位置pos插入count个元素elem</li>
<li><code>erase(const_iterator pos);</code>//删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>//删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//插入和删除
void test01()&#123;
    vector&lt;int&gt; v1;
    //尾插
    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(30);
    v1.push_back(40);
    v1.push_back(50);
    printVector(v1);
    //尾删
    v1.pop_back();
    printVector(v1);
    //插入
    v1.insert(v1.begin(), 100);
    printVector(v1);

    v1.insert(v1.begin(), 2, 1000);
    printVector(v1);

    //删除
    v1.erase(v1.begin());
    printVector(v1);

    //清空
    v1.erase(v1.begin(), v1.end());
    v1.clear();
    printVector(v1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331133324.png" alt=""></p>
<ul>
<li>总结<ul>
<li>尾插 ——— push_back()</li>
<li>尾删 ——— pop_back()</li>
<li>插入 ——— insert(位置迭代器)</li>
<li>删除 ——— erase(位置迭代器)</li>
<li>清空 ——— clear</li>
</ul>
</li>
</ul>
<h2 id="vector数据存储"><a href="#vector数据存储" class="headerlink" title="vector数据存储"></a>vector数据存储</h2><p><strong>功能描述：</strong></p>
<p>对vector中的数据的存取操作</p>
<p>函数原型：</p>
<ul>
<li><code>at(int idx);</code>//返回索引idx所指的数据</li>
<li><code>operator[];</code>//返回索引idx所指的数据</li>
<li><code>front();</code>//返回容器中第一个数据元素</li>
<li><code>back();</code>//返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void test01()&#123;
    vector&lt;int&gt;v1;
    for (int i = 0; i &lt; 10; i++)    &#123;
        v1.push_back(i);
    &#125;

    for (int i = 0; i &lt; v1.size(); i++)    &#123;
        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    for (int i = 0; i &lt; v1.size(); i++)    &#123;
        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;
    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331133417.png" alt=""></p>
<ul>
<li>总结<ul>
<li>除了用迭代器获取vector容器元素，[]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
</li>
</ul>
<h2 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h2><p><strong>功能描述：</strong></p>
<p>实现两个容器内元素进行互换</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>// 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()&#123;
    vector&lt;int&gt;v1;
    for (int i = 0; i &lt; 10; i++)    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);

    vector&lt;int&gt;v2;
    for (int i = 10; i &gt; 0; i--)    &#123;
        v2.push_back(i);
    &#125;
    printVector(v2);

    //互换容器
    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;
    v1.swap(v2);
    printVector(v1);
    printVector(v2);
&#125;

void test02()&#123;
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 100000; i++) &#123;
        v.push_back(i);
    &#125;

    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

    v.resize(3);

    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

    //收缩内存
    vector&lt;int&gt;(v).swap(v); //匿名对象

    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331133519.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
</li>
</ul>
<h2 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h2><p><strong>功能描述：</strong></p>
<p>减少vector在动态扩展容量时的扩展次数</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="lang-cpp">#include &lt;vector&gt;

void test01()&#123;
    vector&lt;int&gt; v;

    //预留空间
    v.reserve(100000);

    int num = 0;
    int* p = NULL;
    for (int i = 0; i &lt; 100000; i++) &#123;
        v.push_back(i);
        if (p != &amp;v[0]) &#123;
            p = &amp;v[0];
            num++;
        &#125;
    &#125;

    cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331133605.png" alt=""></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++提高</category>
      </categories>
  </entry>
  <entry>
    <title>vim常用命令</title>
    <url>/posts/8c31560b.html</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>命令行模式下的文本编辑器</li>
<li>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</li>
<li><p>使用方式：vim filename</p>
<p> 如果已有该文件，则打开它</p>
<p> 如果没有该文件，则打开一个新的文件，并命名为filename</p>
</li>
</ol>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ol>
<li><p>一般命令模式</p>
<p> 默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</p>
</li>
<li><p>编辑模式</p>
<p> 在一般命令模式里按下<code>i</code>，会进入编辑模式</p>
<p> 按下<code>ESC</code>会退出编辑模式，返回到一般命令模式。</p>
</li>
<li><p>命令行模式</p>
<p> 在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。</p>
<p> 可以查找、替换、保存、退出、配置编辑器等。</p>
</li>
</ol>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>i</th>
<th>进入编辑模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ESC</td>
<td>进入一般命令模式</td>
</tr>
<tr>
<td>h 或 左箭头键</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 向下箭头</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td>k 或 向上箭头</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td>l 或 向右箭头</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>n<Space></td>
<td>n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</td>
</tr>
<tr>
<td>0 或 功能键[Home]</td>
<td>光标移动到本行开头</td>
</tr>
<tr>
<td>$ 或 功能键[End]</td>
<td>光标移动到本行末尾</td>
</tr>
<tr>
<td>G</td>
<td>光标移动到最后一行</td>
</tr>
<tr>
<td>:n 或 nG</td>
<td>n为数字，光标移动到第n行</td>
</tr>
<tr>
<td>gg</td>
<td>光标移动到第一行，相当于1G</td>
</tr>
<tr>
<td>n<Enter></td>
<td>n为数字，光标向下移动n行</td>
</tr>
<tr>
<td>/word</td>
<td>向光标之下寻找第一个值为word的字符串</td>
</tr>
<tr>
<td>?word</td>
<td>向光标之上寻找第一个值为word的字符串</td>
</tr>
<tr>
<td>n</td>
<td>重复前一个查找操作</td>
</tr>
<tr>
<td>N</td>
<td>反向重复前一个查找操作</td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g</td>
<td>将全文的word1替换为word2</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc</td>
<td>将全文的word1替换为word2，且在替换前要求用户确认</td>
</tr>
<tr>
<td>v</td>
<td>选中文本</td>
</tr>
<tr>
<td>d</td>
<td>删除选中的文本</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>y</td>
<td>复制选中的文本</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>将复制的数据在光标的下一行/下一个位置粘贴</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
<tr>
<td>Ctrl + r</td>
<td>取消撤销</td>
</tr>
<tr>
<td>大于号 &gt;</td>
<td>将选中的文本整体向右缩进一次</td>
</tr>
<tr>
<td>小于号 &lt;</td>
<td>将选中的文本整体向左缩进一次</td>
</tr>
<tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:w!</td>
<td>强制保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存并推出</td>
</tr>
<tr>
<td>:set paste</td>
<td>设置成粘贴模式，取消代码自动缩进</td>
</tr>
<tr>
<td>:set nopaste</td>
<td>取消粘贴模式，开启代码自动缩进</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>隐藏行号</td>
</tr>
<tr>
<td>gg=G</td>
<td>将全文代码格式化</td>
</tr>
<tr>
<td>:noh</td>
<td>关闭查找关键词高亮</td>
</tr>
<tr>
<td>Ctrl + q</td>
<td>当vim卡死时，可以取消当前正在执行的命令</td>
</tr>
</tbody>
</table>
</div>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件</p>
<p>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</p>
<ol>
<li>找到正在打开该文件的程序，并推出</li>
<li>直接删掉该swp文件即可</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>tmux常用命令</title>
    <url>/posts/c3f7601e.html</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>分屏</li>
<li>允许断开terminal连接后，继续运行进程</li>
</ol>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</p>
<p>示例：</p>
<p>tmux:</p>
<p>&emsp;&emsp;session0:</p>
<p>&emsp;&emsp;&emsp;&emsp;window0:</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;pane0</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;pane1</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;pane2</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;…</p>
<p>&emsp;&emsp;&emsp;&emsp;window1:</p>
<p>&emsp;&emsp;&emsp;&emsp;window2:</p>
<p>&emsp;&emsp;&emsp;&emsp;…</p>
<p>&emsp;&emsp;session1</p>
<p>&emsp;&emsp;session2</p>
<p>&emsp;&emsp;…</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li>tmux：新建一个session，其中包含一个window，window包含一个pane，pane里打开了一个shell对话框</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按<code>%</code>:将当前pane左右平分成两个pane</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按<code>”</code>:将当前pane上下平分成两个pane</li>
<li><code>Ctrl + d</code>: 关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session</li>
<li>鼠标点集可以选pane</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按下方向键：选择相邻的pane</li>
<li>鼠标拖动pane之间的分割线，可以调整分割线的位置</li>
<li>按下<code>Ctrl + a</code>的同时按方向键，可以调整pane之间分割线的位置（鼠标按着分界线也可以位置）</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按<code>d</code>：挂起当前session</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按<code>z</code>：将当前pane全屏/取消全屏</li>
<li><code>tmux a</code>: 打开之前挂起的session</li>
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>s</code>：选择其他session</p>
<p>方向键 ——— 上：选择上一项 session/window/pane</p>
<p>方向键 ——— 下：选择下一项 session/window/pane</p>
<p>方向键 ——— 右：展开当前项 session/window</p>
<p>方向键 ——— 左：闭合当前项 session/window</p>
</li>
<li><p>按下<code>Ctrl + a</code>后手指松开，然后按<code>c</code>：在当前session种创建一个新的window</p>
</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按<code>w</code>：选择其他window，操作方法与（12）完全相同</li>
<li>按下<code>Ctrl + a</code>后手指松开，然后按<code>PageUp</code>：翻阅当前pane的内容</li>
<li>鼠标滚轮：翻阅当前pane内的内容</li>
<li>在tmux中选中文本时，需要按住<code>shift</code>键</li>
<li>tmux中复制/粘贴文本的通用方式<ol>
<li>按下<code>Ctrl + a</code>后松开手指，然后按<code>[</code></li>
<li>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</li>
<li>按下<code>Ctrl + a</code>后松开手指，然后按<code>]</code>，会将剪贴板中的内容粘贴到光标处</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>shell语法</title>
    <url>/posts/4652f0c6.html</url>
    <content><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>shell是我们通过命令行与操作系统沟通的语言</p>
<p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便服用</p>
<p>Linux中常见的shell脚本有很多种，常见的有：</p>
<ul>
<li>Bourne Shell(/usr/bin/sh或/bin/sh)</li>
<li>Bourne Again Shell(/bin/bash)</li>
<li>C Shell(/usr/bin/csh)</li>
<li>K Shell(/usr/bin/ksh)</li>
<li>zsh</li>
<li>…</li>
</ul>
<p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。</p>
<p>文件开头需要些 <code>#! /bin/bash</code>，指明bash为脚本解释器</p>
<h3 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h3><p>新建一个test.sh文件，内容如下：</p>
<pre><code class="lang-bash">#! /bin/bash
echo &quot;Hello World!&quot;
</code></pre>
<h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><p>作为可执行文件</p>
<pre><code class="lang-bash">chmod +x test.sh
./test.sh
# 绝对路径下执行
# 家目录路径下执行
</code></pre>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>每行中<code>#</code>之后的内容进行注释</p>
<pre><code class="lang-bash"># 这是一行注释
echo &#39;hello world&#39; # 这也是注释
</code></pre>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>格式</p>
<pre><code class="lang-bash">:&lt;&lt;EOF
第一行注释
第二行注释
第三行注释
EOF
</code></pre>
<p>其中<code>EOF</code>可以换成其他任意字符串。例如：</p>
<pre><code class="lang-bash">:&lt;&lt;abc
第一行注释
第二行注释
第三行注释
abc

:&lt;&lt;!
第一行注释
第二行注释
第三行注释
!
</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量，不需要加<code>$</code>符号，例如：</p>
<pre><code class="lang-bash">name1=&#39;gotomove&#39; # 单引号定义字符串
name2=&quot;gotomove&quot; # 双引号定义字符串
name3=gotomove # 也可以不加引号，同样表示字符串
</code></pre>
<p><strong>注意：<code>=</code>号两边不能加空格，否则会报错</strong></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用变量，需要加上<code>$</code>符号，或者<code>$&#123;&#125;</code>符号。花括号是可选的，主要为了帮助解释器识别变量边界。</p>
<pre><code class="lang-bash">name=gotomove
echo $name # 输出gotomove
echo $&#123;name&#125; # 输出gotomove
echo $&#123;name&#125;bash # 输出gotomovebash
</code></pre>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用<code>readonly</code>或者<code>declare</code>可以将变量变为只读</p>
<pre><code class="lang-bash">name=gotomove
readonly name
declare -r name # 两种写法均可

name=abc # 会报错，因为此时name只读
</code></pre>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p><code>unset</code>可以删除变量</p>
<pre><code class="lang-bash">name=gotomove
unset name
echo $name # 输出空行
</code></pre>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ol>
<li>自定义变量（局部变量）子进程不能访问的变量</li>
<li>环境变量（全局变量）子进程可以访问的变量</li>
</ol>
<p>自定义变量改成环境变量：</p>
<pre><code class="lang-bash">name=gotomove # 定义变量
export name # 第一种方法
declare -x name #第二种方法
</code></pre>
<p>环境变量改为自定义变量</p>
<pre><code class="lang-bash">export name=gotomove # 定义环境变量
declare +x name # 改为自定义变量
</code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p>单引号与双引号的区别：</p>
<ul>
<li>单引号中的内容跟会原样输出，不会执行、不会取变量</li>
<li>双引号中的内容可以执行、可以取变量</li>
</ul>
<pre><code class="lang-bash">name=gotomove # 不用引号
echo &#39;hello, $name \&quot;hh\&quot;&#39; # 单引号字符串，输出hello, $name \&quot;hh\&quot;
echo &quot;hello, $name \&quot;hh\&quot;&quot; # 双引号字符串，输出hello, gotomove &quot;hh&quot;
</code></pre>
<p>获取字符串长度<br>```bash<br>name=”gotomove”<br>echo $</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell语法</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和 三数之和</title>
    <url>/posts/34f50de6.html</url>
    <content><![CDATA[<h1 id="两数之和-三数之和"><a href="#两数之和-三数之和" class="headerlink" title="两数之和 三数之和"></a>两数之和 三数之和</h1><h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><strong><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组</a></strong></h1><p>双指针的具体原理可以看<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solutions/87919/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/">大佬的题解</a>。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;
        int left = 0, right = numbers.size() - 1;
        vector&lt;int&gt; res(2, 0);
        while(left &lt; right)&#123;
            if(numbers[left] + numbers[right] == target)&#123;
                res[0] = left + 1;
                res[1] = right + 1;
                return res;
            &#125;else if(numbers[left] + numbers[right] &lt; target) left++;
            else right--;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><strong><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></strong></h1><p>这道题就是让我们求在给定数组中是否有两个数之和等于第三个数</p>
<p>一般做法是嵌套三层for循环分别来代表a,b,c三个数然后求得有多少个abc三元组。这样的时间复杂度为 $O(n^3)$，当n很大时是不理想的。这个时候我们就要换一种思路。</p>
<p>为了方便后面的操作，我们先对数组进行排序。</p>
<p>然后从头往后遍历，每次遍历时先确定三元组中的一个数，另外两个数就在该数的后面选。选后面两个数的操作就不用嵌套两层for循环，而是使用双指针的方法，双指针分别指针可选数范围的一头一尾，然后要使得双指针所指的数之和等于一个定值。这样我们就把问题转换成了上面的题目<strong>.</strong> 之后我们只需要保证不会有重复即可。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; tmp(3, 100001);
        for(int i = 0; i &lt; nums.size(); i++)&#123;
            if(i &amp;&amp; nums[i] == nums[i - 1]) continue;
            tmp[0] = nums[i];
            int left = i + 1, right = nums.size() - 1;
            while(left &lt; right)&#123;
                if(nums[left] + nums[right] == 0 - nums[i])&#123;
                    if(tmp[1] == nums[left] &amp;&amp; tmp[2] == nums[right]) &#123;
                        left++;
                        right--;
                    &#125;else&#123;
                        tmp[1] = nums[left];
                        tmp[2] = nums[right];
                        res.emplace_back(tmp);
                        left++;
                        right--;
                    &#125;
                &#125;else if(nums[left] + nums[right] &gt; 0 - nums[i]) right--;
                else left++;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/e8eb0481.html</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>变种的二分查找主要分为区间变种和范围变种</p>
<p>区间变种主要是[],(),[)</p>
<p>范围变种主要是≥,&gt;,≤,&lt;</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/bs.png" alt=""></p>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><strong><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置</a></strong></h1><p>这道题我原来的做法是先在数组中找到这个元素的位置，然后往前往后寻找两个端点，这样的时间复杂度是$O(n)$,比较耗时。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;int&gt; res(2, -1);
        if(nums.empty())    return res;
        int left = 0, right = nums.size() - 1;
        while(left &lt;= right)&#123;
            int mid = (left + right) &gt;&gt; 1;
            if(nums[mid] == target) break;
            else if(nums[mid] &gt; target) right = mid - 1;
            else left = mid + 1;
        &#125;
        if(right &lt; left)    return res;
        right = (right + left) &gt;&gt; 1;
        left = right;
        while(left &gt;= 0)&#123;
            if(nums[left] == target)left--;
            else break;
        &#125;
        res[0] = left + 1;
        while(right &lt; nums.size())&#123;
            if(nums[right] == target)right++;
            else break;
        &#125;
        res[1] = right - 1;
        return res;
    &#125;
&#125;;
</code></pre>
<p>后面看了灵神的视频，发现可以使用两次二分查找即可。</p>
<p>在找起始位置时我们只要保证l前面的数都是小于target的，找末置位时我们只要保证r后面的都大于target即可。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;int&gt; res(2, -1);
        int left = 0, right = nums.size() - 1;
        while(left &lt;= right)&#123;
            int mid = left + (right - left) / 2;
            if(nums[mid] &lt; target)&#123;
                left = mid + 1;
            &#125;else&#123;
                right = mid - 1;
            &#125;
        &#125;
        if(left == nums.size() || nums[left] != target) return res;
        res[0] = left;
        left = 0, right = nums.size() - 1;
        while(left &lt;= right)&#123;
            int mid = left + (right - left) / 2;
            if(nums[mid] &lt;= target)&#123;
                left = mid + 1;
            &#125;else&#123;
                right = mid - 1;
            &#125;
        &#125;
        res[1] = right;
        return res;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分区模型</title>
    <url>/posts/30c3500f.html</url>
    <content><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++chengxu在执行时，将内存当方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不是放，程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义</strong>：</p>
<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。</p>
<h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<ol>
<li><p>代码区：</p>
<p> 存放CPU执行的机器指令</p>
<p> 代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可（多次打开同一个程序它的代码时同一个）</p>
<p> 代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
</li>
<li><p>全局区</p>
<p> 全局变量和静态变量存放在此</p>
<p> 全局区还包含了常量区、字符串常量和其他常量（const修饰）也存放在此</p>
<p> 该区域的数据在程序结束后由操作系统释放</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//全局变量
int g_a = 10;
int g_b = 10;

//全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main() &#123;

    //局部变量
    int a = 10;
    int b = 10;

    //打印地址
    cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;
    cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;

    cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;
    cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;

    //静态变量
    static int s_a = 10;
    static int s_b = 10;

    cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;
    cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;

    cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;
    cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;

    const int c_l_a = 10;
    const int c_l_b = 10;
    cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;
    cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/C++memeroy.png" alt=""></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放const修饰的全局常量 和 字符串常量（不是字符串变量）</li>
</ul>
<h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><p><strong>栈区</strong>：</p>
<p>由编译器自动分配释放，存放函数的参数值，局部变量等</p>
<p>注意事项：不要返回局部变量的地址，栈区开辟的数组由编译器自动释放</p>
<p>示例：</p>
<pre><code class="lang-cpp">int * func()&#123;
    int a = 10; //局部变量 存放在栈区，栈区的数据在函数执行完后自动释放
    return &amp;a; //返回局部变量的地址
&#125;

int main() &#123;

    int *p = func();

    cout &lt;&lt; *p &lt;&lt; endl; //第一行输出没有问题， 编译器做了保留，所以第一次可以打印正确的数字
    cout &lt;&lt; *p &lt;&lt; endl; //第二行输出与第一行不同， 第二次这个数据就不再保留了

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>堆区</strong>：</p>
<p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。</p>
<p>在C++中主要利用new在堆区开辟内存</p>
<pre><code class="lang-cpp">int* func()&#123;
  //利用new关键字，可以将数据开辟到堆区
    int* a = new int(10);
    return a;
&#125;

int main() &#123;

    int *p = func();

    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *p &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结</strong>：</p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内容</p>
<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p>C++中利用<em>new</em>操作符在堆区开辟数据</p>
<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符<em>delete</em></p>
<p>语法：<code>new 数据类型</code></p>
<p>利用new创建的数据，会返回该数据对应类型的指针</p>
<p><strong>示例1：基本语法</strong></p>
<pre><code class="lang-cpp">int* func()&#123;
    int* a = new int(10);
    return a;
&#125;

int main() &#123;

    int *p = func();

    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *p &lt;&lt; endl;

    //利用delete释放堆区数据
    delete p;

    //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327165830.png" alt=""></p>
<p><strong>示例2：开辟数组</strong></p>
<pre><code class="lang-cpp">//堆区开辟数组
int main() &#123;

    int* arr = new int[10];

    for (int i = 0; i &lt; 10; i++)    &#123;
        arr[i] = i + 100;
    &#125;

    for (int i = 0; i &lt; 10; i++)    &#123;
        cout &lt;&lt; arr[i] &lt;&lt; endl;
    &#125;
    //释放数组 delete 后加 []
    delete[] arr;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/posts/41e39f2b.html</url>
    <content><![CDATA[<ul>
<li><strong>单道程序设计中</strong>：内存被划分为两部分，一部分供操作系统使用(驻留监控程序、内核)，一部分供当前正在执行的程序使用</li>
<li><strong>多道程序设计中</strong>：必须在内存中进一步细分“用户”部分，以满足多个进程的要求，细分的任务由操作系统动态完成，称为内存管理</li>
</ul>
<p><strong>内存管理的需求</strong></p>
<ul>
<li><strong>重定位</strong>：程序在从磁盘换入内存时，可以被装载到内存中的不同区域</li>
<li><strong>保护</strong>：处理器必须保证进程以外的其它进程不能未经授权地访问该进程的内存单元</li>
<li><strong>共享</strong>：任何保护机制都必须具有一定灵活性，以允许多个进程访问内存的同一部分</li>
<li><strong>逻辑组织</strong></li>
<li><strong>物理组织</strong></li>
</ul>
<p><strong>内存管理中的地址</strong></p>
<ul>
<li><strong>逻辑地址</strong>：指与当前数据在内存中的物理分配地址无关的访问地址，执行对内存访问前必须转换成物理地址</li>
<li><strong>相对地址</strong>：逻辑地址的一个特例，是相对于某些已知点（通常是程序开始处）的存储单元</li>
<li><strong>物理地址(绝对地址)</strong>：数据在内存中的实际位置</li>
<li><strong>虚拟地址</strong>：虚拟内存中的逻辑地址</li>
</ul>
<p><strong>内存管理单元(MMU)</strong>：CPU中的一个模块，将虚拟地址转换成实际物理地址</p>
<h2 id="内存管理中的数据块"><a href="#内存管理中的数据块" class="headerlink" title="内存管理中的数据块"></a>内存管理中的数据块</h2><ul>
<li><strong>页框</strong>：内存中一个固定长度的块</li>
<li><strong>页</strong>：二级存储(如磁盘)中一个固定长度的数据块</li>
<li><strong>段</strong>：二级存储中一个变长的数据块</li>
</ul>
<h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><p>系统生成阶段，<strong>内存被划分成许多静态(大小，容量固定不变)分区</strong>，两种固定分区：</p>
<ul>
<li><strong>分区大小相等</strong></li>
<li><strong>分区大小不等</strong></li>
</ul>
<p><strong>放置策略：</strong></p>
<ul>
<li><strong>对于分区大小相等的固定分区</strong><ul>
<li>只要存在可用分区，就可以分配给进程</li>
</ul>
</li>
<li><strong>对于分区大小不等的固定分区</strong><ul>
<li><strong>每个进程分配到能容纳它的最小分区</strong>：每个分区维护一个队列（较多小进程时，大分区会空闲）</li>
<li><strong>每个进程分配到能容纳它的最小可用分区</strong>：只需一个队列</li>
</ul>
</li>
</ul>
<blockquote>
<p>存在内部碎片；活动进程数固定</p>
</blockquote>
<h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><p>并不进行预先分区，<strong>在每次需要为进程分配时动态划分</strong></p>
<p>外部碎片（随着时间推移，内存中产生了越来越多”空洞“）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519100824.png" alt="Img"></p>
<p>可以使用压缩解决外部碎片，但是非常耗时</p>
<p><strong>放置算法</strong>：由于压缩十分耗时，因而需要巧妙地把进程分配到内存中，塞住内存中的”洞“</p>
<ul>
<li><strong>最佳适配</strong>：选择与要求大小最接近的块（通常性能最差，尽管每次浪费的空间最小，但结果却使得内存中很快产生许多碎片）</li>
<li><strong>首次适配</strong>：选择大小足够的第一个块（不仅最简单，通常也是最好、最快的；容易在首部产生碎片）</li>
<li><strong>下次适配</strong>：从上次放置的位置起，第一个大小足够的块（比首次适配差，常常会在尾部产生碎片）</li>
</ul>
<blockquote>
<p>维护复杂，且会产生外部碎片</p>
</blockquote>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>内存最小块和最大块的尺寸是M和L。在为一个进程分配空间时，如果需要的内存大于L/2，则分配L的内存，否则，将大小为L的块分成两个L/2的块，继续上述步骤；如果两个相邻的块（伙伴）都未分配出去（如前面的进程释放后），则将其合并</p>
<p>下图为一个伙伴系统的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519100953.png" alt="Img"></p>
<blockquote>
<p>伙伴系统是一种折中方案，克服了固定分区和动态分区方案的缺陷。但在当前操作系统中，基于分页和分段机制的虚拟内存更好。伙伴系统在并行系统中有很多应用</p>
</blockquote>
<h3 id="分区中的地址转换"><a href="#分区中的地址转换" class="headerlink" title="分区中的地址转换"></a>分区中的地址转换</h3><p>逻辑地址-&gt;物理地址的转换如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519101057.png" alt="Img"></p>
<ul>
<li><strong>基址寄存器</strong>：被载入程序在内存中的起始地址</li>
<li><strong>界限寄存器</strong>：程序的终止位置</li>
</ul>
<p>这种转换方式适用于程序运行时，被加载到内存中连续区域的情况。对于分页和分段，由于一个程序可以加载到内存的不同区域，所以需要使用另外的机制进行转换</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>内存被划分为大小固定的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以指定到内存中称为页框的可用块。<strong>和固定分区的不同在于：一个程序可以占据多个分区，这些分区不要求连续</strong></p>
<p>使用分页技术在内存中每个进程浪费的空间，仅仅是最后一页的一小部分（内部碎片）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519101215.png" alt="Img"></p>
<h3 id="分页中的地址转换"><a href="#分页中的地址转换" class="headerlink" title="分页中的地址转换"></a>分页中的地址转换</h3><p>由于进程的页可能不连续，因此仅使用一个简单的基址寄存器是不够的，操作系统需要为每个进程维护一个页表。页表项是进程每一页与内存页框的映射</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519101307.png" alt="Img"></p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>段有一个最大长度限制，但不要求所有程序的所有段长度都相等。分段类似于<strong>动态分区，区别在于：一个程序可以占据多个不连续的分区</strong></p>
<p>分段同样会产生外部碎片，但是进程被划分成多个小块，因此外部碎片也会很小</p>
<h3 id="分段中的地址转换"><a href="#分段中的地址转换" class="headerlink" title="分段中的地址转换"></a>分段中的地址转换</h3><p>由于进程的段可能不连续，因此也不能仅靠一个简单的基址寄存器，地址转换通过<strong>段表</strong>实现。由于段的大小不同，因此段表项中还包括段的大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519101438.png" alt="Img"></p>
<p>如果偏移大于段的长度，则这个地址无效</p>
<h2 id="内存安全"><a href="#内存安全" class="headerlink" title="内存安全"></a>内存安全</h2><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p><strong>缓冲区溢出是指输入到一个缓冲区或者数据保存区域的数据量超过了其容量，从而导致覆盖了其它区域数据的状况</strong>。攻击者造成并利用这种状况使系统崩溃或者通过插入特制的代码来控制系统</p>
<p>被覆盖的区域可能存有其它程序的变量、参数、类似于返回地址或指向前一个栈帧的指针等程序控制流数据。缓冲区可以位于堆、栈或进程的数据段。这种错误可能产生如下后果：</p>
<ol>
<li>破坏程序的数据</li>
<li>改变程序的控制流，因此可能访问特权代码</li>
</ol>
<p><strong>最终很有可能造成程序终止</strong>。当攻击者成功地攻击了一个系统之后，作为攻击的一部分，程序的控制流可能会跳转到攻击者选择的代码处，造成的结果是被攻击的进程可以执行任意的特权代码（比如通过判断输入是否和密码匹配来访问特权代码，如果存在缓冲区漏洞，非法输入导致存放“密码”的内存区被覆盖，从而使得“密码”被改写，因此判断为匹配进而获得了特权代码的访问权）</p>
<blockquote>
<p>缓冲区溢出攻击是最普遍和最具危害性的计算机安全攻击类型之一</p>
</blockquote>
<h3 id="预防缓冲区溢出"><a href="#预防缓冲区溢出" class="headerlink" title="预防缓冲区溢出"></a>预防缓冲区溢出</h3><p>广义上分为两类：</p>
<ul>
<li>编译时防御系统，目的是强化系统以抵御潜伏于新程序中的恶意攻击</li>
<li>运行时预防系统，目的是检测并终止现有程序中的恶意攻击</li>
</ul>
<p>尽管合适的防御系统已经出现几十年了，但是大量现有的脆弱的软件和系统阻碍了它们的部署。因此运行时防御有趣的地方是它能够部署在操作系统中，可以更新，并能为现有的易受攻击的程序提供保护</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树公共祖先</title>
    <url>/posts/ee93e3cf.html</url>
    <content><![CDATA[<h1 id="二叉树公共祖先"><a href="#二叉树公共祖先" class="headerlink" title="二叉树公共祖先"></a>二叉树公共祖先</h1><p>对于这种题，我们首先得明确一点。</p>
<blockquote>
<p>什么是公共祖先？</p>
</blockquote>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：”对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong><br>）。“</p>
<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a><strong><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236.二叉树的最近公共祖先</a></strong></h1><p>对于这一题，题目提供了一个二叉树以及两个节点。这里有几个特殊样例，如果<code>root</code>刚好等于<code>q</code>或者<code>root</code>刚好等于<code>q</code>，那么直接返回<code>root</code>即可，因为这个时候<code>root</code>就刚好是最近公共祖先，如果<code>root</code>为空，那么就返回空。</p>
<p>如果不是，那么我们就要递归遍历左右子树。</p>
<p>在每一轮的遍历中，我们根据左右子树返回的节点是否为空做了以下几个判断：</p>
<ol>
<li>如果<code>root</code>的左子树和右子树都不为空，说明左右子树各有一个目标节点，那么<code>p</code>和<code>q</code>的最近公共祖先就是<code>root</code></li>
<li>如果<code>root</code>的左子树为空，那么说明两个目标节点都在右子树上，那么我们就直接返回右子树给我们的最近公共祖先的节点即可</li>
<li>如果<code>root</code>的右子树为空，那么说明两个目标节点都在左子树上，那么我们就直接返回左子树给我们的最近公共祖先的节点即可</li>
<li>如果<code>root</code>的左右子树都为空，直接返回空即可</li>
</ol>
<pre><code class="lang-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root == NULL || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);
        if(left &amp;&amp; right) return root;
        else if(left) return left;
        else if(right) return right;
        else return NULL;
    &#125;
&#125;;
</code></pre>
<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a><strong><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235.二叉搜索树的最近公共祖先</a></strong></h1><p>这道题相比于上一题有一个好处，那就是可以进行剪枝，我们可以根据二叉搜索树的特性来减少不必要的搜索。</p>
<p>二叉搜索树的特性能够帮我们判断<code>p</code>、<code>q</code>节点在<code>root</code>节点的哪个子树上。</p>
<p>如果<code>root</code>节点的值大于<code>p</code>、<code>q</code>节点的值，那么就只要递归右子树即可，因为<code>p</code>和<code>q</code>都只能在<code>root</code>的右子树，这样我们就节省了递归左子树的开销。</p>
<p>如果<code>root</code>节点的值小于<code>p</code>、<code>q</code>节点的值，那么就只要递归左子树即可，因为<code>p</code>和<code>q</code>都只能在<code>root</code>的左子树，这样我们就节省了递归右子树的开销。</p>
<p>如果<code>root</code>节点的值小于<code>p</code>、<code>q</code>中的一个，大于另外一个，这就说明<code>p</code>、<code>q</code>两个节点在<code>root</code>节点的左右两边，这种情况我们直接返回<code>root</code>节点即可。</p>
<pre><code class="lang-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 */

class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root == NULL || root == p || root == q) return root;
        if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)&#123;
            return lowestCommonAncestor(root-&gt;left, p, q);
        &#125;else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;
            return lowestCommonAncestor(root-&gt;right, p, q);
        &#125;else &#123;
            return root;
        &#125;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>函数提高</title>
    <url>/posts/dbf73455.html</url>
    <content><![CDATA[<p>在C++中，函数的形参列表中的形参是可以有默认值的</p>
<p>语法：<code>返回值类型 函数名 (参数 = 默认值)&#123;&#125;</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int func(int a, int b = 10, int c = 10) &#123;
    return a + b + c;
&#125;

//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) &#123;
    return a + b;
&#125;

int main() &#123;

    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;
    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170604.png" alt=""></p>
<h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法</strong>：</p>
<p><code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//函数占位参数 ，占位参数也可以有默认参数
void func(int a, int) &#123;
    cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;
&#125;

int main() &#123;

    func(10,10); //占位参数必须填补

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170633.png" alt=""></p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h3><p><strong>作用</strong>：函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件</strong>：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意</strong>：函数的返回值不可以作为函数重载的条件，因为函数类型可以强转</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//函数重载需要函数都在同一个作用域下
void func()
&#123;
    cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;
&#125;
void func(int a)
&#123;
    cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;
&#125;
void func(double a)
&#123;
    cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;
&#125;
void func(int a ,double b)
&#123;
    cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;
&#125;
void func(double a ,int b)
&#123;
    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;
&#125;

//函数返回值不可以作为函数重载条件
//int func(double a, int b)
//&#123;
//    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;
//&#125;

int main() &#123;

    func();
    func(10);
    func(3.14);
    func(10,3.14);
    func(3.14 , 10);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170708.png" alt=""></p>
<h3 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h3><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//函数重载注意事项
//1、引用作为重载条件

void func(int &amp;a)
&#123;
    cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;
&#125;

void func(const int &amp;a)
&#123;
    cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;
&#125;

//2、函数重载碰到函数默认参数

void func2(int a, int b = 10)
&#123;
    cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;
&#125;

void func2(int a)
&#123;
    cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;
&#125;

int main() &#123;

    int a = 10;
    func(a); //调用无const
    func(10);//调用有const

    //func2(10); //碰到默认参数产生歧义，需要避免

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170800.png" alt=""></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>函数</title>
    <url>/posts/71adb096.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>作用</strong>：讲一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数的定义一般主要有5个步骤：</p>
<ol>
<li>返回值类型</li>
<li>函数名</li>
<li>参数列表</li>
<li>函数体语句</li>
<li>return 表达式</li>
</ol>
<p>语法：</p>
<pre><code class="lang-cpp">返回值类型 函数名 （参数列表）&#123;
       函数体语句

       return表达式
&#125;
</code></pre>
<ul>
<li>返回值类型：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名字</li>
<li>参数列表：使用该函数时，函数内需要执行的语句</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式：和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p>示例：定义一个加法函数，实现两个数相加</p>
<pre><code class="lang-cpp">//函数定义
int add(int num1, int num2)&#123;
    int sum = num1 + num2;
    return sum;
&#125;
</code></pre>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p><strong>功能</strong>：使用定义好的函数</p>
<p><strong>语法</strong>：<code>函数名(参数)</code></p>
<p><strong>示例</strong></p>
<pre><code class="lang-cpp">//函数定义
int add(int num1, int num2) &#123;//定义中的num1,num2称为形式参数，简称形参
    int sum = num1 + num2;
    return sum;
&#125;

int main() &#123;
    int a = 10;
    int b = 10;
    //调用add函数
    int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

    a = 100;
    b = 100;

    sum = add(a, b);
    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：函数定义里小括号成为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，<em>如果形参发生，并不会影响实参</em></li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">void swap(int num1, int num2)&#123;
    cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
    cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

    int temp = num1;
    num1 = num2;
    num2 = temp;

    cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
    cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;

    //return ; 当函数声明时候，不需要返回值，可以不写return
&#125;

int main() &#123;
    int a = 10;
    int b = 20;

    swap(a, b);

    cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：值传递时，形参时修饰不了实参的</p>
</blockquote>
<h2 id="函数的常见样式"><a href="#函数的常见样式" class="headerlink" title="函数的常见样式"></a>函数的常见样式</h2><p>常见的函数样式有四种</p>
<ol>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
<li>无参无返</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//函数常见样式
//1、 无参无返
void test01()&#123;
    //void a = 10; //无类型不可以创建变量,原因无法分配内存
    cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;
    //test01(); 函数调用
&#125;

//2、 有参无返
void test02(int a)&#123;
    cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
&#125;

//3、无参有返
int test03()&#123;
    cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl;
    return 10;
&#125;

//4、有参有返
int test04(int a, int b)&#123;
    cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl;
    int sum = a + b;
    return sum;
&#125;
</code></pre>
<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p><strong>作用</strong>：告诉编译器函数名称及如何调用函数。函数的实际主题可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b)&#123;
    return a &gt; b ? a : b;
&#125;

int main() &#123;
    int a = 100;
    int b = 200;

    cout &lt;&lt; max(a, b) &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h2><p><strong>作用</strong>：让代码结构更加清晰</p>
<p>函数分文件编写一般有四个步骤</p>
<ol>
<li>创建后缀名为.h的头文件</li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//swap.h文件
#include&lt;iostream&gt;
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);
</code></pre>
<pre><code class="lang-cpp">//swap.cpp文件
#include &quot;swap.h&quot;

void swap(int a, int b)&#123;
    int temp = a;
    a = b;
    b = temp;

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
&#125;
</code></pre>
<pre><code class="lang-cpp">//main函数文件
#include &quot;swap.h&quot;
int main() &#123;

    int a = 100;
    int b = 200;
    swap(a, b);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>单处理器调度</title>
    <url>/posts/b07f406.html</url>
    <content><![CDATA[<p>所谓单处理器调度，指的是单个处理器上的调度。主要是单处理器上多道程序设计系统的进程调度，多道程序设计系统中，内存可以同时驻留多个进程</p>
<h2 id="进程调度类型"><a href="#进程调度类型" class="headerlink" title="进程调度类型"></a>进程调度类型</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519104045.png" alt="Img"></p>
<p>调度类型和进程状态转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519105543.png" alt="Img"></p>
<p>长程调度决定哪一个程序可以进入系统中处理，因此控制着系统的并发度</p>
<p>在批处理系统或者操作系统的批处理部分，新提交的作业被发生到磁盘，并保存在一个批处理队列中。在长程调度程序运行的时候，从队列中创建相应的进程。这里涉及两个决策：</p>
<ul>
<li>调度程序决定何时操作系统接纳一个进程或者多个进程</li>
<li>调度程序决定接收哪个作业或哪些作业，并将其转变成进程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519105628.png" alt="Img"></p>
<p>长程调度执行频率较低，并且仅仅是粗略地决定是否接受新进程及接受哪一个</p>
<p>该章剩余内容主要关注短程调度，即处理器选择一个进程执行时的调度决策。短程调度执行得最频繁，并且精确地决定下一次执行哪个进程</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="短程调度准则"><a href="#短程调度准则" class="headerlink" title="短程调度准则"></a>短程调度准则</h3><p>调度算法的设计需要考虑如下方面（以下为从一种维度的划分）：</p>
<ul>
<li>面向用户的准则：延迟（侧重于用户）</li>
<li>面向系统的准则：效果、利用率、吞吐量（侧重于系统）</li>
</ul>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><ul>
<li>每个进程被指定一个优先级，调度程序总是优先选择具有较高优先级的进程</li>
<li>低优先级进程可能饥饿</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519105758.png" alt="Img"></p>
<h3 id="选择调度策略"><a href="#选择调度策略" class="headerlink" title="选择调度策略"></a>选择调度策略</h3><ul>
<li><strong>周转时间</strong>：等待时间 + 服务时间</li>
<li><strong>归一化周转时间</strong>：周转时间/服务时间</li>
</ul>
<h4 id="先来先服务-FCFS-："><a href="#先来先服务-FCFS-：" class="headerlink" title="先来先服务(FCFS)："></a>先来先服务(FCFS)：</h4><ul>
<li>非抢占</li>
<li>对短进程不利（相对于I/O密集型的进程，更利于处CPU密集型的进程）；一种改进是与优先级结合，每个优先级一个队列，同一队列内部使用FCFS</li>
</ul>
<h4 id="轮转（时间片）："><a href="#轮转（时间片）：" class="headerlink" title="轮转（时间片）："></a>轮转（时间片）：</h4><ul>
<li>抢占</li>
<li>以时间片为周期产生时钟中断，切换运行</li>
<li>主要设计问题是时间片的长度，太短时间片会带来频繁的进程上下文切换开销。时间片过长（比最长进程还长），算法就退化成了FCFS</li>
</ul>
<h4 id="最短进程优先（SPN）："><a href="#最短进程优先（SPN）：" class="headerlink" title="最短进程优先（SPN）："></a>最短进程优先（SPN）：</h4><ul>
<li>非抢占</li>
<li>每次调度选择（所需总）处理事件最短的进程。可能饥饿长进程</li>
<li>难点在于需要估计每个进程所需要的时间处理</li>
</ul>
<h4 id="最短剩余时间（SRT）："><a href="#最短剩余时间（SRT）：" class="headerlink" title="最短剩余时间（SRT）："></a>最短剩余时间（SRT）：</h4><ul>
<li>抢占</li>
<li>每次选择剩余处理时间最少的进程，可能饥饿长进程</li>
<li>也需要估计每个进程所需的处理时间。同时，维护过去的服务时间也会增加开销</li>
</ul>
<h4 id="最高响应比（HRRN）："><a href="#最高响应比（HRRN）：" class="headerlink" title="最高响应比（HRRN）："></a>最高响应比（HRRN）：</h4><ul>
<li>非抢占</li>
<li>调度选择归一化周转时间最大的进程，归一化时间越大说明进程“年龄”越大。当偏向短作业时（小分母产生大比值），长进程由于得不到服务，等待的时间不断增加，从而增大了比值，最终在竞争中可以胜出</li>
<li>同样需要预估每个进程所需的处理时间</li>
</ul>
<h4 id="反馈法："><a href="#反馈法：" class="headerlink" title="反馈法："></a>反馈法：</h4><ul>
<li>抢占</li>
<li>反馈法为了解决SPN、SPT和HRRN必须预估进程所需处理时间的问题（不能获得剩余执行时间就关注已经执行了的时间）。通过处罚运行时间较长的进程的方法来偏向短进程。进程每被抢占一次（说明进程还未运行完，可能是个长进程），就移入更低优先级的队列。在这种机制下，短进程在降级过多前就能运行完，长进程会一直降级，如果已经处于最低级队列，则再次被抢占后返回该队列</li>
<li>这种方法的问题是长进程的周转时间可能惊人的增加，导致饥饿，一种方法是可以增加低优先级队列进程运行的时间片，但仍可能饥饿，还有一种方法是如果在低级队列中时间过长，提升到高优先级队列中</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519132642.png" alt="Img"></p>
<p><strong>调度策略对比总结</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519132658.png" alt="Img"></p>
<p><strong>性能比较</strong></p>
<p>调度策略的性能是选择调度策略的一个关键因素。但是由于相关的性能取决于各种各样的因素，包括各种进程的服务时间分布、调度的效率、上下文切换机制、I/O请求的本质和I/O子系统的性能，因而不可能得到明确的比较结果</p>
<h3 id="调度实例分析"><a href="#调度实例分析" class="headerlink" title="调度实例分析"></a>调度实例分析</h3><p>给出如下进程以及到达时间和服务时间：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519132823.png" alt="Img"></p>
<p>使用各种调度策略：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519132833.png" alt="Img"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>友元</title>
    <url>/posts/63c99134.html</url>
    <content><![CDATA[<p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为 <em>friend</em></p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h2 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h2><pre><code class="lang-cpp">class Building&#123;
    //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
    friend void goodGay(Building * building);

public:

    Building()    &#123;
        this-&gt;m_SittingRoom = &quot;客厅&quot;;
        this-&gt;m_BedRoom = &quot;卧室&quot;;
    &#125;

public:
    string m_SittingRoom; //客厅

private:
    string m_BedRoom; //卧室
&#125;;

void goodGay(Building * building)&#123;
    cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
    cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
&#125;

void test01()&#123;
    Building b;
    goodGay(&amp;b);
&#125;

int main()&#123;

    test01();

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<h2 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h2><pre><code class="lang-cpp">class Building;
class goodGay&#123;
public:

    goodGay();
    void visit();

private:
    Building *building;
&#125;;

class Building&#123;
    //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
    friend class goodGay;

public:
    Building();

public:
    string m_SittingRoom; //客厅
private:
    string m_BedRoom;//卧室
&#125;;

Building::Building()&#123;
    this-&gt;m_SittingRoom = &quot;客厅&quot;;
    this-&gt;m_BedRoom = &quot;卧室&quot;;
&#125;

goodGay::goodGay()&#123;
    building = new Building;
&#125;

void goodGay::visit()&#123;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
&#125;

void test01()&#123;
    goodGay gg;
    gg.visit();
&#125;

int main()&#123;
    test01();

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<h2 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h2><pre><code class="lang-cpp">class Building;

class goodGay&#123;
public:
    goodGay();
    void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
    void visit2(); 

private:
    Building *building;
&#125;;

class Building&#123;
    //告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
    friend void goodGay::visit();

public:
    Building();

public:
    string m_SittingRoom; //客厅
private:
    string m_BedRoom;//卧室
&#125;;

Building::Building()&#123;
    this-&gt;m_SittingRoom = &quot;客厅&quot;;
    this-&gt;m_BedRoom = &quot;卧室&quot;;
&#125;

goodGay::goodGay()&#123;
    building = new Building;
&#125;

void goodGay::visit()&#123;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
&#125;

void goodGay::visit2()&#123;
    cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
    //cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
&#125;

void test01()&#123;
    goodGay  gg;
    gg.visit();

&#125;

int main()&#123;

    test01();

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>删除链表重复节点</title>
    <url>/posts/3ab82e9f.html</url>
    <content><![CDATA[<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a><strong><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/description/">237.删除链表中的节点</a></strong></h2><p>题目让我们删除提供的节点，但是我们不知道这个节点的前面位置，那应该怎么删除呢？我们看到这个链表的标识是<code>val</code>值，那么我们可以把要删除的后面的节点的值移到要删除的节点，再删除后面这个节点，返回的链表的<code>val</code>值顺序是不变的，只是地址会有不同。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    void deleteNode(ListNode* node) &#123;
        if(node-&gt;next == NULL) &#123;
            delete node;
            return;
        &#125;
        ListNode *root = node-&gt;next;
        node-&gt;val = root-&gt;val;
        node-&gt;next = root-&gt;next;
        delete root;
    &#125;
&#125;;
</code></pre>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a><strong><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第 N 个结点</a></strong></h2><p>这道题我原本想的是先跑一遍看这个链表的长度是多少，但是有一个更巧妙的方法</p>
<p>我不是要找到倒数第<code>N</code>个节点嘛，那我先让节点往前位移<code>N</code>个节点，再让一个新的指针从头出发，这样先出发的节点到达终点的时候，后一个出发的指针刚好指向倒数第<code>N</code>个节点，再删除那个节点即可。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
        ListNode* root = new ListNode(0, head), *p = root;
        int e = -1;
        while(head)&#123;
            head = head-&gt;next;
            e++;
            if(e &gt;= n) p = p-&gt;next;
        &#125;
        ListNode* q = p-&gt;next;
        p-&gt;next = p-&gt;next-&gt;next;
        delete q;
        return root-&gt;next;
    &#125;
&#125;;
</code></pre>
<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83.删除排序链表中的重复元素"></a><strong><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83.删除排序链表中的重复元素</a></strong></h2><p>我们从头开始遍历，用一个变量来记录上一个节点的数，如果相同，则删除当前节点，如果不同，更新变量并移动指针到下一个节点。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        if(head == NULL) return head;
        ListNode* root = new ListNode(0, head), *p = head;
        int val = head-&gt;val;
        while(head-&gt;next)&#123;
            head = head-&gt;next;
            if(head-&gt;val == val)&#123;
                p-&gt;next = head-&gt;next;
                delete head;
                head = p;
            &#125;else&#123;
                val = head-&gt;val;
                p = head;
            &#125;
        &#125;
        return root-&gt;next;
    &#125;
&#125;;
</code></pre>
<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82.删除排序链表中的重复元素 II"></a><strong><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">82.删除排序链表中的重复元素 II</a></strong></h2><p>这道题我们只要记录要删除链表的起点的上一个节点<code>prev</code>和终点的下一个节点<code>next</code>就可以了，因此我们要实时维护<code>prev</code>指针的位置</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        if(!head) return head;
        ListNode *root = new ListNode(0, head), *p = root, *q = root, *t = root;
        int val = head-&gt;val;
        while(head-&gt;next)&#123;
            t = head;
            head = head-&gt;next;
            if(head-&gt;val != val)&#123;
                val = head-&gt;val;
                p = t;
            &#125;else&#123;
                while(head &amp;&amp; head-&gt;val == val) head = head-&gt;next;
                p-&gt;next = head;
                while(t != head)&#123;
                    q = t;
                    t = t-&gt;next;
                    delete q;
                &#125;
                if(head == NULL) break;
                val = head-&gt;val;
            &#125;
        &#125;
        return root-&gt;next;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/posts/82b7a1a9.html</url>
    <content><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><strong><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></strong></h2><p>最暴力的方法就是先将链表中的所有节点都拆分下来，再一一安装上去，但是这样我们需要扫两遍。</p>
<p>有更简单的方法。</p>
<p>传入的是这样的一个链表</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325141342.png" alt=""></p>
<p>我们要想反转链表，我们得需要额外的指针来指着当前节点的前面一个，以及该节点的<code>next</code>应该指着的位置。我们用<code>t</code>来表示当前节点的后面的位置，末尾的<code>next</code>指针指着<code>null</code>的位置，所以我们把<code>t</code>设置为<code>null</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325141803.png" alt=""></p>
<p>在每次循环中，我们要先移动<code>head</code>的位置，以防止改变<code>head</code>的<code>next</code>指针后<code>head</code>后面的位置访问不到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325142503.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325151238.png" alt=""></p>
<p>这样我们就能保证能够找到前后节点了，下次反转的时候我们先将<code>t</code>指向<code>root</code>再将<code>root</code>指向的内容变为<code>head</code>指向的内容，再将<code>head</code>往后移动一位，再将<code>root</code>的<code>next</code>指针指向<code>t</code>。</p>
<p>这样反复直到<code>head</code>指向<code>null</code>。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        if(head == NULL || head-&gt;next == NULL) return head;
        ListNode *t = NULL, *ans = head;
        while(head)&#123;
            head = head-&gt;next;
            ans-&gt;next = t;
            t = ans;
            ans = head;
        &#125;
        return t;
    &#125;
&#125;;
</code></pre>
<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><strong><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">92. 反转链表 II</a></strong></h2><p>这道题我的做法就是利用上面的方法，我们将要反转的链表范围截取下来放到上面问题的反转链表中进行操作，最后将三段链表合并即可。</p>
<p>一整个链表被我拆分成了三段：</p>
<p>[head,prev],[left,right],[tail,NULL]</p>
<p>其中关系是<code>prev-&gt;next = left, right-&gt;next = tail.</code></p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head)&#123;
        ListNode* root = head, *t = NULL;
        while(head)&#123;
            head = head-&gt;next;
            root-&gt;next = t;
            t = root;
            root = head;
        &#125;
        return t;
    &#125;

    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;
        if(left == right) return head;
        ListNode* root = new ListNode(0, head);
        int i = 1;
        ListNode* prev = root;
        while(i &lt; left)&#123;
            i++;
            prev = prev-&gt;next;
        &#125;
        ListNode* tail = prev, *p = prev;
        while(i &lt;= right + 1)&#123;
            p = tail;
            tail = tail-&gt;next;
            i++;
        &#125;
        p-&gt;next = NULL;
        prev-&gt;next = reverseList(prev-&gt;next);
        while(prev-&gt;next) prev = prev-&gt;next;
        prev-&gt;next = tail;
        return root-&gt;next;
    &#125;
&#125;;
</code></pre>
<h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a><strong><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">25.K个一组翻转链表</a></strong></h2><p>发现只要掌握第一个问题之后，后面的问题都能够依靠第一个问题的方法来解决。</p>
<p>这一题我每找到k个节点我就分割链表，将要反转的链表放入第一个问题中的解决函数，然后将返回的链表重新连接起来。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head)&#123;
        ListNode* ans = head, *t = NULL;
        while(head != NULL)&#123;
            head = head-&gt;next;
            ans-&gt;next = t;
            t = ans;
            ans = head;
        &#125;
        return t;
    &#125;

    ListNode* reverseKGroup(ListNode* head, int k) &#123;
        if(k == 1) return head;
        ListNode* root = new ListNode(0, head);
        ListNode* prev = root, *tail = NULL;
        int i = 1;
        while(head != NULL)&#123;
            head = head-&gt;next;
            i++;
            if(i % k == 0)&#123;
                if(head == NULL) continue;
                tail = head-&gt;next;
                head-&gt;next = NULL;
                prev-&gt;next = reverseList(prev-&gt;next);
                while(prev-&gt;next) prev = prev-&gt;next;
                prev-&gt;next = tail;
                head = prev;
            &#125;
        &#125;

        return root-&gt;next;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>同向双指针 滑动窗口</title>
    <url>/posts/137e18a2.html</url>
    <content><![CDATA[<h1 id="同向双指针-滑动窗口"><a href="#同向双指针-滑动窗口" class="headerlink" title="同向双指针 滑动窗口"></a>同向双指针 滑动窗口</h1><h1 id="209-长度最小的子数组-Medium"><a href="#209-长度最小的子数组-Medium" class="headerlink" title="209. 长度最小的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>(Medium)</strong></h1><p>这道题的目标是在给定数组上求最短连续数组的和大于给定的k值</p>
<p>一般思路：用两个for循环来遍历所有可能的子串和，这种方法的时间复杂度是 $O(n^2)$</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;
                int len = nums.size();
                int res = len;
                for(int i = 0; i &lt; len; i++)&#123;
                    int tmp = nums[i];
                    if(tmp &gt;= target) len = 1;
                    for(int j = i + 1; j &lt; len; j++)&#123;
                        tmp += nums[j];
                        if(tmp &gt;= target) &#123;
                            len = min(len, j - i + 1);
                        &#125;
                    &#125;
                &#125;
        &#125;
        return res;
&#125;
</code></pre>
<p>另一种方法就是使用双指针，之前我们用到的双指针一般都是指向一头一尾，然后通过不断向中间位移来压缩长度。</p>
<p>这道题的双指针是同向双指针，类似于队列的头指针和尾指针。我们先移动头指针，直到头指针和尾指针之间的数之和大于等于给定值。当和大于等于给定值时，我们就开始移动尾指针，知道头指针和尾指针之间的数之和小于给定值，在移动尾指针的时候我们要实时更新最短长度，这个最短长度就是头指针和尾指针的距离。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;
        int res = nums.size() + 1;
        int idx = -1, sum = 0;
        for(int i = 0; i &lt; nums.size(); i++)&#123;
            sum += nums[i];
            while(sum &gt;= target)&#123;
                res = min(i - idx, res);
                idx++;
                sum -= nums[idx];
            &#125;
        &#125;
        if(res == nums.size() + 1) return 0;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="713-乘积小于-K-的子数组-Medium"><a href="#713-乘积小于-K-的子数组-Medium" class="headerlink" title="713. 乘积小于 K 的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a>(Medium)</strong></h1><p>这道题和上面类似，只不过上面是求最大的长度，这里是要枚举数量。</p>
<p>但是No.713和No.209类似，都是需要用到双指针，而且是同向双指针，双指针维护的是双指针之间的乘积。</p>
<p>那么重点来了，双指针维护的是乘积，我们怎么获取个数呢？因为双指针之间的数的乘积是小于K的，当他大于K时，我们也只要更新左指针来保证双指针之间的数的乘积小于K。从这我们可以看出双指针的右指针在一次操作中是不动的，那么我们就可以在每次确立右指针之后，查看是否要更新左指针，之后我们在这个双指针的基础上，以右指针为数组的右端点，枚举左端点，查看最后有多少个以右指针为数组端点的子数组。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;
        int res = 0;
        int idx = -1, sum = 1;
        for(int i = 0; i &lt; nums.size(); i++)&#123;
            sum *= nums[i];
            while(sum &gt;= k &amp;&amp; idx &lt; i) sum /= nums[++idx];
            res += (i - idx);
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="3-无重复字符的最长子串-Meduim"><a href="#3-无重复字符的最长子串-Meduim" class="headerlink" title="3. 无重复字符的最长子串[Meduim]"></a><strong><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>[Meduim]</strong></h1><p>这道题利用双指针怎么做呢？</p>
<p>我们利用同向双指针，右指针每往右移一个时，我们判断这个新加入的元素在左右指针中是否已经出现过。如果没出现过，那么我们就继续右移右指针，如果出现过，那么我们就要开始移动左指针，直到左右指针之间的所有元素都只出现一次。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;
        unordered_map&lt;char, int&gt; hash;
        int res = 0, idx = -1;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            if(!hash[s[i]])&#123;
                res = max(res, i - idx);
                hash[s[i]] = 1;
            &#125;else&#123;
                while(s[++idx] != s[i])&#123;
                    hash[s[idx]] = 0;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，同向双指针重要的是维护双指针之间的数，如果满足条件，一般移动右指针，当不满足时，右移左指针。</p>
<p>一般操作：</p>
<ol>
<li>右移右指针直到末尾</li>
<li>判断左右指针之间的数是否满足条件<ol>
<li>如果满足，回到步骤1</li>
<li>如果不满足，移动左指针，回到步骤2</li>
</ol>
</li>
<li>结束</li>
</ol>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的初始化和清理</title>
    <url>/posts/5bd18230.html</url>
    <content><![CDATA[<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置</li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</li>
<li>析构函数：主要作用在于对象<strong>销毁</strong>前系统自动调用，执行一些清理工作</li>
</ul>
<p><strong>构造函数语法</strong>：</p>
<p><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次</li>
</ol>
<p><strong>析构函数语法</strong>：</p>
<p><code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称和类名相同，在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前自动调用析构，无须手动调用，而且只会调用一次</li>
</ol>
<pre><code class="lang-cpp">class Person&#123;
public:
    //构造函数
    Person()    &#123;
        cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;
    &#125;
    //析构函数
    ~Person()    &#123;
        cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;
    &#125;

&#125;;

void test01()&#123;
    Person p;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327171428.png" alt=""></p>
<h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p>两种分类方式：</p>
<p>按参数分：有参构造和无参构造</p>
<p>按类型分：普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>括号法</p>
<p>显示法</p>
<p>隐式转换法</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person &#123;
public:
    //无参（默认）构造函数
    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
    &#125;
    //有参构造函数
    Person(int a) &#123;
        age = a;
        cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
    &#125;
    //拷贝构造函数
    Person(const Person&amp; p) &#123;
        age = p.age;
        cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
    &#125;
    //析构函数
    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
    &#125;
public:
    int age;
&#125;;

//2、构造函数的调用
//调用无参构造函数
void test01() &#123;
    Person p; //调用无参构造函数
&#125;

//调用有参的构造函数
void test02() &#123;

    //2.1  括号法，常用
    Person p1(10);
    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
    //Person p2();

    //2.2 显式法
    Person p2 = Person(10); 
    Person p3 = Person(p2);
    //Person(10)单独写就是匿名对象  当前行结束之后，马上析构

    //2.3 隐式转换法
    Person p4 = 10; // Person p4 = Person(10); 
    Person p5 = p4; // Person p5 = Person(p4); 

    //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
    //Person p5(p4);
&#125;

int main() &#123;

    test01();
    //test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person &#123;
public:
    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
        mAge = 0;
    &#125;
    Person(int age) &#123;
        cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
        mAge = age;
    &#125;
    Person(const Person&amp; p) &#123;
        cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
        mAge = p.mAge;
    &#125;
    //析构函数在释放内存之前调用
    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
    &#125;
public:
    int mAge;
&#125;;

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() &#123;

    Person man(100); //p对象已经创建完毕
    Person newman(man); //调用拷贝构造函数
    Person newman2 = man; //拷贝构造

    //Person newman3;
    //newman3 = man; //不是调用拷贝构造函数，赋值操作
&#125;

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) &#123;&#125;
void test02() &#123;
    Person p; //无参构造函数
    doWork(p);
&#125;

//3. 以值方式返回局部对象
Person doWork2()
&#123;
    Person p1;
    cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;
    return p1;
&#125;

void test03()
&#123;
    Person p = doWork2();
    cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;
&#125;

int main() &#123;

    test01();
    cout &lt;&lt; endl;
    test02();
    cout &lt;&lt; endl;
    test03();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327171536.png" alt=""></p>
<h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>默认情况下，C++编译器至少给一个类添加3个函数</p>
<ol>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
</ol>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person &#123;
public:
    //无参（默认）构造函数
    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
    &#125;
    //有参构造函数
    Person(int a) &#123;
        age = a;
        cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;
    &#125;
    //拷贝构造函数
    Person(const Person&amp; p) &#123;
        age = p.age;
        cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
    &#125;
    //析构函数
    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
    &#125;
public:
    int age;
&#125;;

void test01()&#123;
    Person p1(18);
    //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
    Person p2(p1);

    cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;
&#125;

void test02()&#123;
    //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
    Person p1; //此时如果用户自己没有提供默认构造，会出错
    Person p2(10); //用户提供的有参
    Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

    //如果用户提供拷贝构造，编译器不会提供其他构造函数
    Person p4; //此时如果用户自己没有提供默认构造，会出错
    Person p5(10); //此时如果用户自己没有提供有参，会出错
    Person p6(p5); //用户自己提供拷贝构造
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327171716.png" alt=""></p>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person &#123;
public:
    //无参（默认）构造函数
    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;
    &#125;
    //有参构造函数
    Person(int age ,int height) &#123;

        cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;

        m_age = age;
        m_height = new int(height);

    &#125;
    //拷贝构造函数  
    Person(const Person&amp; p) &#123;
        cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;
        //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
        m_age = p.m_age;
        m_height = new int(*p.m_height);

    &#125;

    //析构函数
    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;
        if (m_height != NULL)        &#123;
            delete m_height;
        &#125;
    &#125;
public:
    int m_age;
    int* m_height;
&#125;;

void test01()&#123;
    Person p1(18, 180);

    Person p2(p1);

    cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;

    cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要提供拷贝构造函数，防止浅拷贝带来的问题</p>
<p>具体的问题：如果在堆区开辟的数据利用拷贝，拷贝的时候给的也是相同地址，因此当有一个对象释放其空间，另外一个也想释放时就会出错，会返回一个空指针。</p>
</blockquote>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p><strong>作用</strong>：</p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法</strong>：</p>
<p><code>构造函数(): 属性1(值1), 属性2(值2)...&#123;&#125;</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person &#123;
public:

    ////传统方式初始化
    //Person(int a, int b, int c) &#123;
    //    m_A = a;
    //    m_B = b;
    //    m_C = c;
    //&#125;

    //初始化列表方式初始化
    Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;
    void PrintPerson() &#123;
        cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;
        cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;
        cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;
    &#125;
private:
    int m_A;
    int m_B;
    int m_C;
&#125;;

int main() &#123;

    Person p(1, 2, 3);
    p.PrintPerson();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<pre><code class="lang-cpp">class A &#123;&#125;
class B&#123;
    A a；
&#125;
</code></pre>
<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p>根据先进后出的原则，我们是先调用B，再调用A，因为没有B对象，我们就不用申请A作为对象成员了</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Phone&#123;
public:
    Phone(string name)    &#123;
        m_PhoneName = name;
        cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;
    &#125;

    ~Phone()    &#123;
        cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;
    &#125;

    string m_PhoneName;

&#125;;

class Person&#123;
public:
    //初始化列表可以告诉编译器调用哪一个构造函数
    Person(string name, string pName) :m_Name(name), m_Phone(pName)    &#123;
        cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;
    &#125;

    ~Person()    &#123;
        cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;
    &#125;

    void playGame()    &#123;
        cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;
    &#125;

    string m_Name;
    Phone m_Phone;
&#125;;
void test01()&#123;
    //当类中成员是其他类对象时，我们称该成员为 对象成员
    //构造的顺序是 ：先调用对象成员的构造，再调用本类构造
    //析构顺序与构造相反
    Person p(&quot;张三&quot; , &quot;苹果X&quot;);
    p.playGame();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327171842.png" alt=""></p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1</strong>：静态成员变量</p>
<pre><code class="lang-cpp">class Person&#123;

public:

    static int m_A; //静态成员变量

    //静态成员变量特点：
    //1 在编译阶段分配内存
    //2 类内声明，类外初始化
    //3 所有对象共享同一份数据

private:
    static int m_B; //静态成员变量也是有访问权限的
&#125;;
int Person::m_A = 10;
int Person::m_B = 10;

void test01()&#123;
    //静态成员变量两种访问方式

    //1、通过对象
    Person p1;
    p1.m_A = 100;
    cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;

    Person p2;
    p2.m_A = 200;
    cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据
    cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;

    //2、通过类名
    cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;

    //cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>示例2</strong>：静态成员函数</p>
<pre><code class="lang-cpp">class Person&#123;

public:

    //静态成员函数特点：
    //1 程序共享一个函数
    //2 静态成员函数只能访问静态成员变量

    static void func()    &#123;
        cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;
        m_A = 100;
        //m_B = 100; //错误，不可以访问非静态成员变量
    &#125;

    static int m_A; //静态成员变量
    int m_B; // 
private:

    //静态成员函数也是有访问权限的
    static void func2()    &#123;
        cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;
    &#125;
&#125;;
int Person::m_A = 10;

void test01()&#123;
    //静态成员变量两种访问方式

    //1、通过对象
    Person p1;
    p1.func();

    //2、通过类名
    Person::func();

    //Person::func2(); //私有权限访问不到
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>并发</title>
    <url>/posts/46bf65ac.html</url>
    <content><![CDATA[<p>并发相关的术语：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518104039.png" alt="Img"></p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>可以根据进程相互之间知道对方是否存在的程度，对进程间的交互进行分类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518104124.png" alt="Img"></p>
<ul>
<li><strong>进程间的资源竞争</strong>：每个进程不影响它所使用的资源，这类资源包括I/O设备、存储器、处理器时间和时钟。首先需要提供互斥要求（比方说，如果不提供对打印机的互斥访问，打印结果会穿插）。实施互斥又产生了两个额外的控制问题：死锁和饥饿</li>
<li><strong>进程间通过共享的合作</strong>：进程可能使用并修改共享变量而不涉及其他进程，但却知道其他进程也可能访问同一数据。因此，进程必须合作，以确保共享的数据得到正确管理。由于数据保存在资源中（设备或存储器），因此再次涉及有关互斥、死锁、饥饿等控制问题，除此之外，还有一个新要求：数据的一致性</li>
<li><strong>进程间通过通信的合作</strong>：由于在传递消息的过程中，进程间未共享任何对象，因而这类合作不需要互斥，但是仍然存在死锁和饥饿问题（死锁举例：两个进程可能都被阻塞，每个都在等待来自对方的通信；饥饿举例：P1,P2,P3，P1不断试图与P2，P3通信，P2和P3都试图与P1通信，如果P1和P2不断交换信息，而P3一直被阻塞，等待与P1通信，由于P1一直是活跃的，P3处于饥饿状态）</li>
</ul>
<h3 id="互斥的硬件支持"><a href="#互斥的硬件支持" class="headerlink" title="互斥的硬件支持"></a>互斥的硬件支持</h3><h4 id="中断禁用（只对单处理器有效）"><a href="#中断禁用（只对单处理器有效）" class="headerlink" title="中断禁用（只对单处理器有效）"></a>中断禁用（只对单处理器有效）</h4><p>为保证互斥，只需保证一个进程不被中断即可</p>
<pre><code class="lang-c">while(true)&#123;
    /* 禁用中断 */
    /*  临界区  */
    /* 启用中断 */
    /* 其余部分 */
&#125;
</code></pre>
<p><strong>问题</strong></p>
<ul>
<li>处理器被限制于只能交替执行程序，因此执行的效率将会有明显的降低</li>
<li>该方法不能用于多处理器结构中</li>
</ul>
<h4 id="专用机器指令"><a href="#专用机器指令" class="headerlink" title="专用机器指令"></a>专用机器指令</h4><ul>
<li><strong>比较和交换指令</strong></li>
<li><strong>交换指令</strong></li>
</ul>
<p>在硬件级别上，对存储单元的访问排斥对相同单元的其它访问。基于这一点，处理器的设计者提出了一些机器指令，用于保证两个动作的原子性。在指令执行的过程中，任何其它指令访问内存将被阻止</p>
<pre><code class="lang-c">/*比较和交换指令*/
int bolt;
void P(int i)
&#123;
    while(true)&#123;
        while(compare_and_swap(&amp;bolt,0,1) == 1)
            /*不做任何事*/;
        /*临界区*/
        bolt = 0;
        /*其余部分*/
    &#125;
&#125;

int compare_and_swap(int *word,int testval,int newval)
&#123;
    int oldval;
    oldval = *word;
    if(oldval == testval) *word = newval;
    return oldval;
&#125;
</code></pre>
<pre><code class="lang-c">/*交换指令*/
int bolt;
void P(int i)
&#123;
    int keyi = 1;
    while(true)&#123;
        do exchange (&amp;keyi,&amp;bolt);
        while(keyi != 0);
        /*临界区*/
        bolt = 0;
        /*其余部分*/
    &#125;
&#125;

void exchange (int *register,int *memory)
&#123;
    int temp;
    temp = *memory;
    *memory = *register;
    *register = temp;
&#125;
</code></pre>
<p><strong>优点</strong></p>
<ul>
<li>适用于单处理器或共享内存的多处理上的任何数目的进程</li>
<li>简单且易于证明</li>
<li>可用于支持多个临界区（每个临界区可以用它自己的变量定义）</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>使用了忙等待（进入临界区前会一直循环检测，会销毁处理器时间）</li>
<li>可能饥饿（忙等的进程中可能存在一些进程一直无法进入临界区）</li>
<li>可能死锁（P1在临街区中时被更高优先级的P2抢占，P2请求相同的资源）</li>
</ul>
<h3 id="互斥的软件支持"><a href="#互斥的软件支持" class="headerlink" title="互斥的软件支持"></a>互斥的软件支持</h3><p>软件支持包括操作系统和用于提供并发性的程序设计语言机制，常见如下表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518105058.png" alt="Img"></p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>通常称为计数信号量或一般信号量</p>
<p>可把信号量视为一个具有整数值的变量，在它之上定义三个操作：</p>
<ol>
<li>一个信号量可以初始化为非负数（表示发出semWait操作后可立即执行的进程数量）</li>
<li>semWait操作使信号量减1。若值为负数，执行该操作进程被阻塞。否则进程继续执行</li>
<li>semSignal操作使信号量加1。若值小于或等于0，则被semWait阻塞的进程被解除阻塞</li>
</ol>
<p>信号量原语的定义：</p>
<pre><code class="lang-c">struct semaphore&#123;
    int count;
    queueType queue;
&#125;;

void semWait(semaphore s)
&#123;
    s.count--;
    if(s.count &lt; 0)&#123;
        /*把当前进程插入到队列当中*/;
        /*阻塞当前进程*/;
    &#125;
&#125;

void semSignal(semaphore s)
&#123;
    s.count++;
    if(s.count &lt;= 0)&#123;
        /*把进程P从队列中移除*/;
        /*把进程P插入到就绪队列*/;
    &#125;
&#125;
</code></pre>
<h4 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h4><p>二元信号量是一种更特殊的信号量，它的值只能是0或1</p>
<p>可以使用下面3种操作：</p>
<ol>
<li>可以初始化为0或1</li>
<li>semWaitB操作检查信号的值，如果为0，该操作会阻塞进程。如果值为1，将其改为0后进程继续执行</li>
<li>semSignalB操作检查是否有任何进程在信号上阻塞。有则通过semSignalB操作，受阻进程会被唤醒，如果没有，那么设置值为1</li>
</ol>
<p>二元信号量的原语定义：</p>
<pre><code class="lang-c">struct binary_semaphore&#123;
    enum &#123;zero,one&#125; value;
    queueType queue;
&#125;;

void semWaitB(binary_semaphore s)
&#123;
    if(s.value == one)
        s.value = zero;
    else&#123;
        /*把当前进程插入到队列当中*/;
        /*阻塞当前进程*/;
    &#125;
&#125;

void semSignalB(binary_semaphore s)
&#123;
    if(s.queue is empty())
        s.value = one;
    else&#123;
        /*把进程P从等待队列中移除*/;
        /*把进程P插入到就绪队列*/;
    &#125;
&#125;
</code></pre>
<blockquote>
<ul>
<li>强信号量：队列设计为FIFO，被阻塞最久的进程最先从队列中释放（保证不会饥饿）</li>
<li>弱信号量：没有规定进程从队列中移出顺序</li>
</ul>
</blockquote>
<p><strong>使用信号量的互斥</strong>（这里是一般信号量，不是二元信号量）</p>
<pre><code class="lang-c">const int n = /*进程数*/
semaphore s = 1;

void P(int i)
&#123;
    while(true)&#123;
        semWait(s);
        /*临界区*/;
        semSignal(s);
        /*其它部分*/;
    &#125;
&#125;

void main()
&#123;
    parbegin(P(1),P(2),...,P(n));
&#125;
</code></pre>
<p>下图为三个进程使用上述互斥协议后，一种可能的执行顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518132024.png" alt="Img"></p>
<blockquote>
<p>信号量为实施互斥及进程间合作提供了一种原始但功能强大且灵活的工具，但是，使用信号量设计一个正确的程序是很困难的，其难点在于semWait和semSignal操作可能分布在整个程序中，却很难看出这些在信号量上的操作所产生的整体效果</p>
</blockquote>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>互斥量和二元信号量关键的区别在于：互斥量加锁的进程和解锁的进程必须是同一进程</p>
<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>管程是一个程序设计语言结构，它提供了与信号量同样的功能，但更易于控制。它是由<strong>一个或多个过程，一个初始化序列</strong>和<strong>局部数据</strong>组成的软件模块，主要特点如下：</p>
<ol>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>在任何时候，只能有一个进程在管理种执行，调用管程的其它进程都被阻塞，等待管程可用</li>
</ol>
<p>为进行并发处理，管程必须包含同步工具（例如：一个进程调用了管程，并且当它在管程中时必须被阻塞，直到满足某些条件。这就需要一种机制，使得该进程在管程内被阻塞时，能释放管程，以便其它进程可以进入。以后，当条件满足且管程在此可用时，需要恢复进程并允许它在阻塞点重新进入管程）</p>
<p>管程通过使用<strong>条件变量</strong>提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个操作：</p>
<ul>
<li>cwait(c):调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用</li>
<li>csignal(c):恢复执行在cwait后因某些条件被阻塞的进程。如果有多个则选择其一；如果没有则什么也不做</li>
</ul>
<p>管程的结构如下：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518133313.png" alt="Img"></p>
<blockquote>
<p>管程优于信号量之处在于，所有的同步机制都被限制在管程内部，因此，不但易于验证同步的正确性，而且易于检查出错误。此外，如果一个管程被正确编写，则所有进程对保护资源的访问都是正确的；而对于信号量，只有当所有访问资源的进程都被正确地编写时，资源访问才是正确的</p>
</blockquote>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>最小操作集：</p>
<ul>
<li>send(destination, message)</li>
<li>receive(source, message)</li>
</ul>
<p>阻塞：</p>
<ul>
<li>当一个进程执行send原语时，有2中可能：<ul>
<li>发送进程被阻塞直到这个消息被目标进程接收</li>
<li>不阻塞</li>
</ul>
</li>
<li>当一个进程执行receive原语后，也有2种可能：<ul>
<li>如果一个消息在此之前被发送，该消息被正确接收并继续执行</li>
<li>没有正在等待的消息，则a）进程阻塞直到等待的消息到达，b）继续执行，放弃接收的努力</li>
</ul>
</li>
</ul>
<p>消息传递过程中需要识别消息的源或目的地，这个过程称为<strong>寻址</strong>，可分为两类：</p>
<ol>
<li><p>直接寻址：</p>
<ul>
<li>对于send：包含目标进程的标识号</li>
<li>对于receive：1）进程显示指定袁锦程；2）不可能指定所希望的源进程时，通过source参数保存相应信息</li>
</ul>
</li>
<li><p>间接寻址（解除了发送者/接收者的耦合性，更灵活）</p>
<ul>
<li>消息发送到一个共享数据结构，称为“信箱”。发送者和接收者直接有“一对一”、“多对一”、“一对多”和“多对多”的对应关系（典型的“多对一”如客户端/服务器，此时“信箱”就是端口）</li>
</ul>
</li>
</ol>
<p>消息传递实现互斥（消息函数可视为在进程直接传递的一个令牌）：</p>
<pre><code class="lang-c">const int n = /*进程数*/;
void P(int i)
&#123;
    message msg;
    while(true)&#123;
        receive(box,msg);
        /*临界区*/;
        send(box,msg);
        /*其它部分*/;
    &#125;
&#125;

void main()
&#123;
    create mailbox (box);
    send(box,null);
    parbegin(P(1),P(2),...,P(n));
&#125;
</code></pre>
<blockquote>
<p>可以使用消息传递处理“生产者/消费者问题”，可以有多个消费者和生产者，系统甚至可以是分布式系统</p>
</blockquote>
<h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>在设计同步和并发机制时，可以与一些经典问题联系起来，以检测该问题的解决方案对原问题是否有效</p>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h4><p>有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；有一个消费者从缓冲区中取数据，每次取一项；</p>
<p>任何时候只有一个主体（生产者或消费者）可以访问缓冲区。要确保缓存满时，生产者不会继续添加，缓存为空时，消费者不会从中取数据</p>
<p>实现代码：</p>
<ul>
<li><strong>当缓冲无限大时</strong>（二元信号量，对应图5.10；信号量，对应图5.11）</li>
<li><strong>当缓冲有限时</strong>（信号量，对应图5.14；管程，对应图5.16；消息传递，对应图5.21）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518134902.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518134918.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518134927.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518134939.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518134958.png" alt="Img"></p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者/写者问题"></a>读者/写者问题</h4><p>有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据；此外还满足以下条件：</p>
<ul>
<li>任意多的读进程可以同时读</li>
<li>一次只有一个进程可以写</li>
<li>如果一个进程在写，禁止所有读</li>
</ul>
<p>实现代码：</p>
<ul>
<li><strong>读优先</strong>：只要至少有一个都进程正在读，就为进程保留对这个数据区的控制权（信号量，对应图5.22）</li>
<li><strong>写优先</strong>：保证当有一个写进程声明想写时，不允许新的读进程访问该数据区（信号量，对应图5.23）</li>
</ul>
<center>
<figure>
<img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518135515.png" width="280"/>
<img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518213258.png" width="340"/>
</figure>
</center>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁定义</strong>：一组进程中的每个进程都在等待某个事件，而只有在这种进程中的其它被阻塞的进程才可以出发该事件，这时就称这组进程发生死锁</p>
<p>假设两个进程的资源请求喝释放序列如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518213633.png" alt="Img"></p>
<p>下图是相应的<strong>联合进程图</strong>，显示了进程竞争资源的进展情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518214403.png" alt="Img"></p>
<p><strong>敏感区域</strong>：路径3，4进入的区域。敏感区域的存在依赖于两个进程的逻辑关系。然而，如果另个进程的交互过程创建了能够进入敏感区的执行路径，那么死锁就必然发生</p>
<p><strong>死锁问题中的资源分类</strong></p>
<ul>
<li><strong>可重用资源</strong>：一次只能供一个进程安全地使用，并且不会由于使用而耗尽的资源（包括处理器、I/O通道、内外存、设备等）</li>
<li><strong>可消耗资源</strong>：可以被进程创建和消耗的资源。通常对某种类型可消耗资源的数目没有限制，一个无阻塞的生产进程可以创建任意数目的这类资源（包括中断、信号、消息和I/O缓冲中的信息）</li>
</ul>
<p><strong>资源分配图</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518214631.png" alt="Img"></p>
<ul>
<li>进程到资源：进程请求资源但还没得到授权</li>
<li>资源到进程：请求资源已被授权</li>
<li>资源中的“点”：表示该类资源的一个实例</li>
</ul>
<h3 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a>死锁的条件</h3><p>死锁条件：</p>
<pre><code>1. **互斥**：一次只有一个进程可以使用一个资源
2. **占有且等待**：当一个进程等待其他进程时，继续占有已经分配的资源
3. **不可抢占**：不能强行抢占进程已占有的资源
4. **循环等待**：存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需的一个资源
</code></pre><p>条件1~3是死锁的必要条件，条件4是前3个条件的潜在结果，即假设前3个条件存在，可能发生的一系列事件会导致不可解的循环等待。这个不可解的循环等待实际上就是死锁的定义。之所以不可解是因为有前3个条件的存在。因此，4个条件连在一起构成了死锁的充分必要条件</p>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><p>死锁预防是通过约束资源请求，使得4个死锁条件中的至少1个被破坏，从而防止死锁发生</p>
<ul>
<li><p><strong>间接的死锁预防（防止死锁条件1~3）</strong></p>
<ul>
<li><strong>预防互斥</strong>：一般来说，不可能禁止</li>
<li><strong>预防占有且等待</strong>：可以要求进程一次性地请求所有需要的资源，并且阻塞进程直到所有请求都同时满足。这种方法在两个方面是低效的：1）为了等待满足其所有请求的资源，进程可能被阻塞很长时间。但实际上只要有一部分资源，就可以继续执行；2）分配的资源有可能有相当长的一段时间不会被使用，且在此期间，这些资源不能被其它进程使用；除此之外，一个进程可能事先并不会知道它所需要的所有资源</li>
<li><strong>预防不可抢占</strong>：有几种方法：1）如果占用某些资源的进程进一步申请资源时被拒，则释放其占用的资源；2）如果一个进程请求当前被另一个进程占有的一个资源，操作系统可以抢占另一个进程，要求它释放资源(方法2只有在任意两个进程优先级不同时，才能预防死锁)；此外，通过预防不可抢占来预防死锁的方法，只有在资源状态可以很容易保存和恢复的情况下才实用</li>
</ul>
</li>
<li><p><strong>直接的死锁预防（防止死锁条件4）</strong></p>
<ul>
<li><strong>预防循环等待</strong>：可以通过定义资源类型的线性顺序来预防，如果一个进程已经分配到了R类型的资源，那么它接下来请求的资源只能是那些排在R类型之后的资源；这种方法可能是低效的，会使进程执行速度变慢，并且可能在没有必要的情况下拒绝资源访问</li>
</ul>
</li>
</ul>
<blockquote>
<p>都会导致低效的资源使用和低效的进程运行</p>
</blockquote>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免允许3个必要条件，但通过明智选择，确保永远不会到达死锁点</p>
<p>由于需要对是否会引起死锁进行判断，因此死锁避免需要知道将来的进程资源请求的情况</p>
<p>2种死锁避免的方法：</p>
<pre><code>1. **进程启动拒绝**：如果一个进程的请求会导致死锁，则不启动此进程
2. **资源分配拒绝**：如果一个进程增加的资源请求会导致死锁，则不允许此分配
</code></pre><h4 id="进程启动拒绝"><a href="#进程启动拒绝" class="headerlink" title="进程启动拒绝"></a>进程启动拒绝</h4><p>一个有n个进程，m种不同类型资源的系统。定义如下向量和矩阵</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518215548.png" alt="Img"></p>
<p>从中可以看出以下关系成立：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518215642.png" alt="Img"></p>
<p>对于进程n+1，仅当对所有j，以下关系成立时，才启动进程n+1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518215712.png" alt="Img"></p>
<h4 id="资源分配拒绝（银行家算法）"><a href="#资源分配拒绝（银行家算法）" class="headerlink" title="资源分配拒绝（银行家算法）"></a>资源分配拒绝（银行家算法）</h4><p>当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程直到同意该请求后系统状态仍然是安全的</p>
<ul>
<li>安全状态：至少有一个资源分配序列不会导致死锁(即所有进程都能运行直到结束)</li>
<li>不安全状态：非安全的一个状态(所有分配序列都不可行)</li>
</ul>
<p>下图为一个安全序列</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518215814.png" alt="Img"></p>
<p>下图为一个不安全序列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518215846.png" alt="Img"></p>
<p>这个不安全序列并不是一个死锁状态，仅仅是有可能死锁。例如，如果P1从这个状态开始运行，先释放一个R1和R3，后来又再次需要这些资源，一旦这样做，则系统将到达一个安全状态</p>
<p><strong>优点</strong></p>
<pre><code>- 不需要死锁预防中的抢占和回滚进程，并且比死锁预防的限制少。比死锁预防允许更多的并发
</code></pre><p><strong>缺点</strong></p>
<pre><code>- 必须事先声明每个进程请求的最大资源
- 所讨论的进程必须是无关的，也就是说，他们执行的顺序必须没有任何同步要求的限制
- 分配的资源数目必须是固定的
- 在占有资源时，进程不能退出
</code></pre><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>死锁检测不限制资源访问或约束进程行为。只要有可能，被请求的资源就被分配给进程。操作系统周期性地执行一个算法检测死锁条件4(循环等待)</p>
<p><strong>常见死锁检测算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518220209.png" alt="Img"></p>
<p>这种算法的策略是查找一个进程，使得可用资源可以满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，再释放它的所有资源。然后算法再寻找另一个可以满足资源请求的进程</p>
<p>这个算法并不能保证防止死锁，是否死锁要取决于将来同意请求的次序，它所做的一切是确定当前是否存在死锁</p>
<p><strong>恢复</strong></p>
<p>一旦检测到死锁，就需要某种策略以恢复死锁，有下列方法(复杂度递增)：</p>
<ul>
<li>取消所有死锁进程（操作系统最常用）</li>
<li>回滚每个死锁进程到前面定义的某些检测点</li>
<li>连续取消死锁进程直到不再存在死锁（基于某种最小代价原则）</li>
<li>连续抢占资源直到不再存在死锁（基于代价选择，每次抢占后需重新调用算法检测，被抢占的进程需回滚）</li>
</ul>
<h3 id="死锁“预防-避免-检测”总结"><a href="#死锁“预防-避免-检测”总结" class="headerlink" title="死锁“预防/避免/检测”总结"></a>死锁“预防/避免/检测”总结</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518220405.png" alt="Img"></p>
<h3 id="经典问题-哲学家就餐问题"><a href="#经典问题-哲学家就餐问题" class="headerlink" title="经典问题(哲学家就餐问题)"></a>经典问题(哲学家就餐问题)</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518220432.png" alt="Img"></p>
<p>就餐需要使用盘子和两侧的叉子，设计一套算法以允许哲学家吃饭。算法必须保证互斥（没有两位哲学家同时使用同一把叉子），同时还要避免死锁和饥饿</p>
<p><strong>方法一(基于信号量，可能死锁)</strong>：每位哲学家首先拿起左边的叉子，然后拿起右边的叉子。吃完面后，把两把叉子放回。如果哲学家同时拿起左边的叉子，会死锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518220501.png" alt="Img"></p>
<p><strong>方法二(基于信号量，不会死锁)</strong>：增加一位服务员，只允许4位哲学家同时就座，因而至少有一位哲学家可以拿到两把叉子</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518220541.png" alt="Img"></p>
<p><strong>方法三(基于管程，不会死锁)</strong>：和方法一类似，但和信号量不同的是，因为同一时刻只有一个进程进入管程，所以不会发生死锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518220604.png" alt="Img"></p>
<h2 id="UNIX并发机制"><a href="#UNIX并发机制" class="headerlink" title="UNIX并发机制"></a>UNIX并发机制</h2><p>UNIX为进程间的通信和同步，提供了下列几种重要的通信机制：</p>
<ul>
<li><strong>提供进程间传递数据的方法</strong><ul>
<li>管道</li>
<li>消息</li>
<li>共享内存</li>
</ul>
</li>
<li><strong>触发其它进程的行为</strong><ul>
<li>信号量</li>
<li>信号</li>
</ul>
</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一个环形缓冲区，允许两个进程以生产者/消费者的模型进程通信</p>
<ul>
<li>写管道：当一个进程试图写管道时，如果有足够的空间，则写请求被立即执行，否则进程被阻塞</li>
<li>读管道：当一个进程试图读管道时，如果读取字节数多于当前管道中的字节数，进程被阻塞</li>
</ul>
<p>操作系统强制实施互斥，即一次只能有一个进程可以访问管道</p>
<p><strong>两类管道</strong></p>
<ul>
<li>命名管道：共享的进程可以不相关</li>
<li>匿名管道：只有父子关系的进程才能共享</li>
</ul>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>每个进程都有一个关联的消息队列，功能类似于信箱</p>
<ul>
<li>发送消息：发送者指定发送消息的类型。试图给一个满队列发送时进程会被阻塞</li>
<li>接收消息：接收者可以按先进先出的顺序接收信息；也可以按类型接收；试图从空队列读消息时，进程会被阻塞，试图读取某一类型消息，但是该类型消息不存在时，不会阻塞进程</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是UNIX提供的进程间通信手段中速度最快的一种。共享内存是虚存中由多个进程共享的一个公共内存块。互斥约束不属于共享内存机制的一部分，但必须由使用共享内存的进程提供</p>
<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>UNIX System V中的信号量系统调用是对semWait和semSignal原语的推广</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是用于向一个进程通知发生异步事件的机制。类似于硬件中断，但没有优先级，即内核平等地对待所有的信号。对于同时发送的信号，一次只给进程一个信号，而没有特定的次序</p>
<h2 id="Linux内核并发机制"><a href="#Linux内核并发机制" class="headerlink" title="Linux内核并发机制"></a>Linux内核并发机制</h2><p>Linux包含了在其他UNIX系统中出现的所有并发机制，其中包括管道，消息，共享内存和信号。除此之外，还包括：</p>
<ul>
<li>原子操作</li>
<li>自旋锁</li>
<li>信号量</li>
<li>屏障</li>
</ul>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>Linux提供了一组操作以保证对变量的原子操作。这些操作能够用来避免简单的竞争条件。原子操作执行时不会被打断或被干涉</p>
<ul>
<li>在单处理器上：线程一旦启动原子操作，则从操作开始到结束的这段时间内，线程不能被中断</li>
<li>在多处理器上：原子操作所针对的变量是被锁住的，以免被其他的进程访问，直到原子操作执行完毕</li>
</ul>
<p>Linux中定义了2种原子操作：</p>
<ul>
<li>针对整数变量的整数操作：定义了一个特殊的数据类型atomic_t，原子整数操作仅能用在这个数据类型上，其它操作不允许用在这个数据类型上</li>
<li>针对位图中某一位的位图操作：操作由指针变量指定任意一块内存区域的位序列中的某一位。因此没有和原子整数操作中atomic_t等同的数据类型</li>
</ul>
<p>Linux原子操作表：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518221036.png" alt="Img"></p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是Linux中包含临界区最常见的技术。同一时刻，只有一个线程能获得自旋锁。其它任何企图获得自旋锁的进程将一直进行尝试（忙等），直到获得了该锁</p>
<ul>
<li>普通自旋锁</li>
<li>读者-写者自旋锁：允许多个线程同时以只读方式访问同一数据结构，只有当一个线程想要更新时，才会互斥访问</li>
</ul>
<p>自旋锁操作表：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518221217.png" alt="Img"></p>
<h3 id="信号量-2"><a href="#信号量-2" class="headerlink" title="信号量"></a>信号量</h3><p>内核的信号量不能通过系统调用直接被用户程序访问。内核信号量是作为内核内部函数实现的，比用户可见的信号量更高效</p>
<ul>
<li>二元信号量：在Linux中也称为互斥信号量MUTEX</li>
<li>计数信号量</li>
<li>读者-写者信号量：允许多个并发的读者，仅允许一个写者。事实上，对于读者使用的是一个计数信号量，而对于写者使用的是一个二元信号量</li>
</ul>
<p>Linux提供3种版本的down操作：</p>
<ol>
<li>down：对应于传统的semWait操作</li>
<li>down_interruptible：允许因down操作而被阻塞的线程在此期间接收并相应内核信号</li>
<li>down_trylock：可在不被阻塞的同时获得信号量，如果信号量不可用，返回非0值，不会阻塞</li>
</ol>
<p>信号量操作表：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518221334.png" alt="Img"></p>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障用于保证指令执行的顺序。如，rmb()操作保证了之前和之后的代码都没有任何读操作会穿过屏障</p>
<p>对于屏障操作，需要注意2点：</p>
<ol>
<li>屏障和机器指令相关，也就是装载和存储指令（高级语言a=b会产生2个指令）</li>
<li>编译方面，屏障操作指示编译器在编译期间不要重新排序指令；处理器方面，屏障操作指示流水线上任何屏障前的指令必须在屏障后的指令开始执行之前提交</li>
</ol>
<p>barrier()操作是mb()操作的一个轻量版本，它仅仅控制编译器的行为</p>
<p>屏障操作表：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518221422.png" alt="Img"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>SQL-基础查询</title>
    <url>/posts/49b58c85.html</url>
    <content><![CDATA[<h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><p><strong>语法</strong></p>
<pre><code class="lang-SQL">SELECT 查询列表 FROM 表名;
</code></pre>
<p><strong>特点</strong></p>
<ol>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>查询的结果是一个虚拟的表格</li>
</ol>
<p>以下的表是本篇博客中常用的表</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220437.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220453.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220506.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220522.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220534.png" alt="Img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230529220543.png" alt="Img"></p>
<p><strong>示例</strong></p>
<p>查询表中的单个字段</p>
<pre><code class="lang-SQL">SELECT last_name FROM employees;`
</code></pre>
<p>查询表中的多个字段</p>
<pre><code class="lang-SQL">SELECT last_name, salary, email
FROM employees;
</code></pre>
<p>查询表中的所有字段</p>
<pre><code class="lang-SQL">SELECT *
FROM employees;
</code></pre>
<p>查询常量值（一般是用来检验数据库是否连接成功）</p>
<pre><code class="lang-SQL">SELECT 1;
</code></pre>
<p>查询表达式</p>
<pre><code class="lang-SQL">SELECT 100 * 98;
</code></pre>
<p>查询函数</p>
<pre><code class="lang-SQL">SELECT VERSION();
</code></pre>
<h2 id="查询中用到的方法"><a href="#查询中用到的方法" class="headerlink" title="查询中用到的方法"></a>查询中用到的方法</h2><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h3><p>好处：</p>
<pre><code>1. 便于理解
2. 如果要查询的字段有重名的情况，使用别名可以区分开来
</code></pre><p>方法一：使用AS</p>
<pre><code class="lang-SQL">SELECT 100 % 98 AS result;
</code></pre>
<p>方法二：使用空格</p>
<pre><code class="lang-SQL">SELECT last_name 姓, first_name 名
FROM employees;
</code></pre>
<p>注意的是，起的别名不能是关键词，如果遇到了别名是关键词的话要加上着重符``</p>
<pre><code class="lang-SQL"># SELECT salary AS out put FROM employees;
SELECT salary AS `out put` FROM employees;
</code></pre>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>案例：查询员工表涉及到的所有的部门编号</p>
<pre><code class="lang-SQL">SELECT DISTINCT department_id FROM employees;
</code></pre>
<p>如果没有用<code>DISTINCT</code>，那么返回的结果中有重复的部门编号</p>
<h3 id="号的作用"><a href="#号的作用" class="headerlink" title="+号的作用"></a>+号的作用</h3><p>仅仅只有一个功能：运算符</p>
<ol>
<li><code>SELECT 100 + 90;</code> 两个操作符都为数值型，则做加法运算</li>
<li><code>SELECT &#39;123&#39; + 90;</code> 其中一方为字符型，试图将字符型数值转换成数值型，如果转换成功，则继续做加法运算</li>
<li><code>SELECT &#39;john&#39; + 90;</code> 如果转换失败，则将字符型数值转换为<code>0</code></li>
<li><code>SELECT NULL + 10;</code> 只要其中一方为<code>NULL</code>，则结果为<code>NULL</code></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基本概念</title>
    <url>/posts/c6854716.html</url>
    <content><![CDATA[<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p><strong>数据库系统的核心和基础是数据模型</strong>。一般来说，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特征、动态特征和完整性约束条件。因此数据模型一般由<strong>数据结构</strong>、<strong>数据操作</strong>和<strong>完整性约束</strong>三部分组成</p>
<ol>
<li><strong>数据结构</strong>：存储在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系</li>
<li><strong>数据操作</strong>：指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则</li>
<li><strong>完整性约束</strong>：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性</li>
</ol>
<p>根据模型引用目的的不同，数据模型分为两类：</p>
<ul>
<li>第一类<ul>
<li><strong>概念模型</strong>：也称为信息模型。它是按用户的观点来对数据和信息建模，主要用于数据库设计</li>
</ul>
</li>
<li>第二类<ul>
<li><strong>逻辑模型</strong>：主要包括层次模型、网状模型、<strong>关系模型</strong>、面向对象模型和对象关系模型等</li>
<li><strong>物理模型</strong>：是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的</li>
</ul>
</li>
</ul>
<p><strong>关系模型是目前最重要的一种数据类型</strong>。关系数据库系统采用关系模型作为数据的组织方式</p>
<ul>
<li>关系模型中数据的逻辑结构是一张二维表，或者说关系的数据结构就是一张表</li>
<li>关系数据模型的数据操作主要包含<strong>查询</strong>、<strong>插入</strong>、<strong>删除</strong>和<strong>更新</strong>数据</li>
<li>关系模型的完整性约束条件包含三大类：<strong>实体完整性</strong>、<strong>参照完整性</strong>和<strong>用户自定义</strong>的完整性<ul>
<li>关系模型的实体完整性规则：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值（由此规则可得一直接结论：主键不能为空）</li>
<li>关系模型的参照完整性规则：若属性（或属性组）F是某基本关系R的外键，且它与基本关系R1的主键相对应，则对于R中，每个F上的值或为空值或者等于R1中的主键值</li>
</ul>
</li>
</ul>
<h2 id="主键与外键"><a href="#主键与外键" class="headerlink" title="主键与外键"></a>主键与外键</h2><ul>
<li><strong>候选码</strong>：关系（二维表）中能唯一标识一个元组的属性组</li>
<li><strong>主键</strong>：如果一张表有多个候选码，则选定其中一个为主键</li>
<li><strong>外键</strong>：如果关系模式R中的某属性集不是R的主键，而是另一个关系R1的主键，则该属性集是关系模式R的外键。外键表示了两个关系（表）之间的联系。以另一个关系的外键作主键的表被称为主表，具有此外键的表被称为主表的从表</li>
<li><strong>主属性与非主属性</strong>：候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务</strong>是指用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位<br>事务具有4个特性：<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>、<strong>持续性</strong>。简称为ACID特性</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>索引</strong>是对数据库中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</p>
<p>为表设置索引的好处与坏处：</p>
<ul>
<li>好处<ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>可以大大加快数据的检索速度（创建索引的主要原因）</li>
<li>在使用分组（group by）和排序（order by）子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参照完整性方面特别有意义</li>
</ul>
</li>
<li>坏处<ul>
<li>一是增加了数据库的存储空间</li>
<li>二是插入和删除数据时要花费较多时间（因为索引也要随之变动）</li>
</ul>
</li>
</ul>
<p>索引是建立在数据库表中的某些列的上面。在创建索引时，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引：</p>
<ul>
<li>一般来说，应该在这些列上创建索引<ul>
<li>在经常需要搜索的列上创建索引，可以加快搜索的速度</li>
<li>在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构</li>
<li>在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>在经常使用在<code>WHERE</code>子句中的列上创建索引，加快条件的判断速度</li>
</ul>
</li>
<li>一般来说，不应该创建索引的这些列具有下列特点<ul>
<li>那些在查询中很少使用的列不应该创建索引。很少使用故而即使创建索引也不会带来很大性能提升。索引又会带来空间和维护上的负担</li>
<li>只有很少数据值的列也不应该创建索引。如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引并不能明显加快检索速度</li>
<li>那些定义为text和bit等数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少，不利于使用索引</li>
<li>当修改操作远远大于检索操作时，不应该创建索引。因为修改性能和检索性能互相矛盾。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改的性能，降低检索的性能</li>
</ul>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图</strong>是从一个或几个基本表（或试图）导出的表。与基本表不同，它是一个虚表</p>
<p>数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化时，视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化</p>
<p>视图一经定义，就可以和基本表一样被查询、删除</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>建表</title>
    <url>/posts/2a739b03.html</url>
    <content><![CDATA[<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><blockquote>
<p>定义基本表</p>
</blockquote>
<pre><code class="lang-mysql">CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件]
                        [, &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件]]
                        ...
                        [, &lt;表级完整性约束条件&gt;]);
</code></pre>
<ul>
<li><code>primary key (A1, A2, A3, ...)</code>：指定主键属性集</li>
<li><code>foreign key (A1, A2, A3, ...) references T2</code>:声明并表示关系中任意元素在属性<code>(A1, A2, A3, ...)</code>上的取值必须对应于<code>T2</code>中某元组在主码属性上的取值</li>
</ul>
<p><strong>数据类型</strong>：</p>
<ul>
<li><code>int</code>:整型。等价于全程<code>integer</code></li>
<li><code>smallint</code>:小型整数</li>
<li><code>real</code>, <code>double precision</code>:浮点数与双精度浮点数（精度与机器相关）</li>
<li><code>float(n)</code>:精度至少为n位的浮点数</li>
<li><code>char(n)</code>:固定长度的字符串</li>
<li><code>varchar(n)</code>:可变长度的字符串</li>
</ul>
<p>例如：建立一个“学生信息”表Student：</p>
<pre><code class="lang-mysql">CREATE TABLE Student(
    Sno CHAR(9) PRIMARY KEY,
    Sname CHAR(20) UNIQUE
    Ssex CHAR(2),
    Sage SMALLINT,
    Sdept CHAR(20)
);
</code></pre>
<h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><blockquote>
<p>修正基本表</p>
</blockquote>
<pre><code class="lang-mysql">ALTER TABLE &lt;表名&gt;
[ADD &lt;新列名&gt; &lt;数据类型&gt;[完整性约束]]
[DROP &lt;完整性约束&gt;]
[MODIFY COLUMN &lt;列名&gt; &lt;数据类型&gt;];
</code></pre>
<ul>
<li><code>ADD</code>子句：增加新列和新的完整性约束</li>
<li><code>DROP</code>子句：删除指定的完整性约束</li>
<li><code>MODIFY COLUMN</code>子句：修改原有列的定义，包括列名和数据类型</li>
</ul>
<p>例子：</p>
<pre><code class="lang-mysql">ALTER TABLE Student ADD S_entrance DATE;    // 向Student表增加“入学时间”列，其数据类型为日期型
ALTER TABLE Student MODIFY COLUMN INT;      // 将年龄的数据类型由字符串型改为整数
ALTER TABLE ADD UNIQUE(Sname);              // 增加Student表Sname必须取唯一值的约束条件
</code></pre>
<h3 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h3><blockquote>
<p>删除基本表</p>
</blockquote>
<pre><code class="lang-mysql">DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE];
</code></pre>
<ul>
<li><code>RESTRICT</code>: 删除是有限制条件的。欲删除的基本表不能杯其他表的约束所引用（如：check、foreign key等约束），不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则该表不能被删除。</li>
<li><code>CASCADE</code>: 删除没有条件限制。在删除该表的同时，相关的依赖对象，例如试图，都将被一起删除</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>分类</p>
<p>tinyint, smallint, mediumint, int/integer, bigint(1,2,3,4,8)</p>
<p>特点</p>
<ol>
<li>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键词</li>
<li>如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值 </li>
<li>如果不设置长度，会有默认的长度</li>
</ol>
<p>设置有符号和无符号</p>
<pre><code class="lang-mysql">CREATE TABLE tab_int(
    t1 INT,
    t2 INT UNSIGNED
);
</code></pre>
<h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><p>分类：</p>
<ol>
<li>浮点型 <ul>
<li>FLOAT(M, D)</li>
<li>DOUBLE(M, D)</li>
</ul>
</li>
<li>定点型 <ul>
<li>DEC(M, D)</li>
<li>DECIMAL(M, D)</li>
<li>特点：</li>
<li>M:整数部位+小数部位 </li>
<li>D:小数部位<br>如果超过范围，则插入临界值 </li>
</ul>
</li>
</ol>
<p>M和D都可以省略<br>如果是DEMICAL， 则M默认为10，D默认为0<br>如果是FLOAT和DOUBLE，则会根据插入的数值的精度来决定精度<br>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
<p>原则：</p>
<pre><code>- 所选择的类型越简单越好 
- 能保存数值的类型越小越好
</code></pre><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>较短的文本： </p>
<ul>
<li>CHAR</li>
<li>VARCHAR</li>
</ul>
<p>较长的文本： </p>
<ul>
<li>TEXT</li>
<li>BLOB（较长的二进制） </li>
</ul>
<p>特点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>char(M)</td>
<td>最大的字符数，可以省略，默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar</td>
<td>varchar(M)</td>
<td>最大的字符数，不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p><strong>含义</strong>：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 </p>
<p><strong>分类：六大约束</strong></p>
<ol>
<li><strong>NOT NULL</strong>: 非空，用于保证该字段的值不能为空 比如主键 </li>
<li><strong>DEFAULT</strong>:默认，用于保证该字段有默认值 比如性别</li>
<li><strong>PRIMARY KEY</strong>:主键。用于保证该字段的值具有唯一性，并且非空 </li>
<li><strong>UNIQUE</strong>：唯一，用于保证该字段的值具有唯一性，可以为空，比如邮箱</li>
<li><strong>CHECK</strong>：检查约束 [mysql中不支持]</li>
<li><strong>FOREIGN KEY</strong>:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，在从表添加外键约束，用于引用主表中某列的值 比如学生表的专业编号，用工表的部门编号 </li>
</ol>
<p>添加约束的时机：</p>
<ol>
<li>创建表时 </li>
<li>修改表时 </li>
</ol>
<p>约束的添加分类： </p>
<ul>
<li>列级约束:六大约束语法上都支持，但外键约束没有效果 </li>
<li>表记约束：除了非空、默认，其他都支持 </li>
</ul>
<p>主键和唯一的区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>为空</th>
<th>一个表中可以有多少个</th>
<th>是否允许组合</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键</td>
<td>✔</td>
<td>×</td>
<td>至多有一个</td>
<td>是，但不推荐</td>
</tr>
<tr>
<td>唯一</td>
<td>✔</td>
<td>✔</td>
<td>可以有多个</td>
<td>是，但不推荐</td>
</tr>
</tbody>
</table>
</div>
<p>外键：</p>
<ol>
<li>要求再从表设置外键关系 </li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容</li>
<li>主表的关联列必须是一个key（一般是主键或唯一） </li>
<li>插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，在删除主表 </li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>引用</title>
    <url>/posts/c96f7df0.html</url>
    <content><![CDATA[<h2 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h2><p><strong>作用</strong>：给变量起别名</p>
<p><strong>语法</strong>：<code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    int a = 10;
    int &amp;b = a;

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

    b = 100;

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170014.png" alt=""></p>
<h2 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h2><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    int a = 10;
    int b = 20;
    //int &amp;c; //错误，引用必须初始化
    int &amp;c = a; //一旦初始化后，就不可以更改
    c = b; //这是赋值操作，不是更改引用

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><strong>作用</strong>：函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点</strong>：可以简化指针修改实参</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//1. 值传递
void mySwap01(int a, int b) &#123;
    int temp = a;
    a = b;
    b = temp;
&#125;

//2. 地址传递
void mySwap02(int* a, int* b) &#123;
    int temp = *a;
    *a = *b;
    *b = temp;
&#125;

//3. 引用传递
void mySwap03(int&amp; a, int&amp; b) &#123;
    int temp = a;
    a = b;
    b = temp;
&#125;

int main() &#123;

    int a = 10;
    int b = 20;

    mySwap01(a, b);
    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;

    mySwap02(&amp;a, &amp;b);
    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;

    mySwap03(a, b);
    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170101.png" alt=""></p>
<h2 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h2><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//返回局部变量引用
int&amp; test01() &#123;
    int a = 10; //局部变量
    return a;
&#125;

//返回静态变量引用
int&amp; test02() &#123;
    static int a = 20;
    return a;
&#125;

int main() &#123;

    //不能返回局部变量的引用
    int&amp; ref = test01();
    cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;
    cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;

    //如果函数做左值，那么必须返回引用
    int&amp; ref2 = test02();
    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;
    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;

    test02() = 1000;

    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;
    cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170200.png" alt=""></p>
<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>本质：<strong>引用的本质在C++内部实现是一个指针常量</strong></p>
<p>讲解示例：</p>
<pre><code class="lang-cpp">//发现是引用，转换为 int* const ref = &amp;a;
void func(int&amp; ref)&#123;
    ref = 100; // ref是引用，转换为*ref = 100
&#125;
int main()&#123;
    int a = 10;

    //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int&amp; ref = a; 
    ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;

    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;

    func(a);
    return 0;
&#125;
</code></pre>
<blockquote>
<p>结论：C++推荐引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器帮我们做了</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327170320.png" alt=""></p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p><strong>作用</strong>：常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加<em>const修饰形参</em>，防止形参改变实参</p>
<p><strong>示例</strong>:</p>
<pre><code class="lang-cpp">//引用使用的场景，通常用来修饰形参
void showValue(const int&amp; v) &#123;
    //v += 10;
    cout &lt;&lt; v &lt;&lt; endl;
&#125;

int main() &#123;

    //int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
    //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;
    const int&amp; ref = 10;

    //ref = 100;  //加入const后不可以修改变量
    cout &lt;&lt; ref &lt;&lt; endl;

    //函数中利用常量引用防止误操作修改实参
    int a = 10;
    showValue(a);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>指针</title>
    <url>/posts/73608288.html</url>
    <content><![CDATA[<h2 id="指针的基本概念"><a href="#指针的基本概念" class="headerlink" title="指针的基本概念"></a>指针的基本概念</h2><p><strong>指针的作用</strong>：可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>内存可以利用指针变量保存地址</li>
</ul>
<h2 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h2><p>指针变量定义语法：<code>数据类型 * 变量名</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    //1、指针的定义
    int a = 10; //定义整型变量a

    //指针定义语法： 数据类型 * 变量名 ;
    int * p;

    //指针变量赋值
    p = &amp;a; //指针指向变量a的地址
    cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址
    cout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p

    //2、指针的使用
    //通过*操作指针变量指向的内存
    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据，指针变量存放的是地址</li>
<li>指针变量可以通过” * ”操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1：我们可以通过 &amp; 符号，获取变量的地址</p>
<p>总结2：利用指针可以记录地址</p>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h2 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h2><p>提问：指针也是种数据类型，那么这种数据类型占用多少个内存空间？</p>
<p><strong>示例</strong></p>
<pre><code class="lang-cpp">int main() &#123;

    int a = 10;

    int * p;
    p = &amp;a; //指针指向数据a的地址

    cout &lt;&lt; *p &lt;&lt; endl; //* 解引用
    cout &lt;&lt; sizeof(p) &lt;&lt; endl;
    cout &lt;&lt; sizeof(char *) &lt;&lt; endl;
    cout &lt;&lt; sizeof(float *) &lt;&lt; endl;
    cout &lt;&lt; sizeof(double *) &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h2 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h2><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途</strong>：初始化指针变量</p>
<p><strong>注意</strong>：空指针指向的内存是不可以访问的</p>
<p><strong>示例1</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //指针变量p指向内存地址编号为0的空间
    int * p = NULL;

    //访问空指针报错 
    //内存编号0 ~255为系统占用内存，不允许用户访问
    cout &lt;&lt; *p &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //指针变量p指向内存地址编号为0x1100的空间
    int * p = (int *)0x1100;

    //访问野指针报错 
    cout &lt;&lt; *p &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>空指针和野指针都不是我们申请的空间，因此不要访问</p>
</blockquote>
<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针 ———常量指针</li>
<li>const修饰常量 ———指针常量</li>
<li>const既修饰指针，又修饰常量</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    int a = 10;
    int b = 10;

    //const修饰的是指针，指针指向可以改，指针指向的值不可以更改
    const int * p1 = &amp;a; 
    p1 = &amp;b; //正确
    //*p1 = 100;  报错

    //const修饰的是常量，指针指向不可以改，指针指向的值可以更改
    int * const p2 = &amp;a;
    //p2 = &amp;b; //错误
    *p2 = 100; //正确

    //const既修饰指针又修饰常量
    const int * const p3 = &amp;a;
    //p3 = &amp;b; //错误
    //*p3 = 100; //错误

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量。</p>
</blockquote>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p><strong>作用</strong>：利用指针访问数组中元素</p>
<p><strong>示例</strong></p>
<pre><code class="lang-cpp">int main() &#123;
    int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;

    int * p = arr;  //指向数组的指针

    cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;
    cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;

    for (int i = 0; i &lt; 10; i++)    &#123;
        //利用指针遍历数组
        cout &lt;&lt; *p &lt;&lt; endl;
        p++;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h2><p><strong>作用</strong>：利用指针作函数参考，可以修改实参的值</p>
<p><strong>示例</strong></p>
<pre><code class="lang-cpp">//值传递
void swap1(int a ,int b)&#123;
    int temp = a;
    a = b; 
    b = temp;
&#125;
//地址传递
void swap2(int * p1, int *p2)&#123;
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
&#125;

int main() &#123;

    int a = 10;
    int b = 20;
    swap1(a, b); // 值传递不会改变实参

    swap2(&amp;a, &amp;b); //地址传递会改变实参

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;

    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h2 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h2><p><strong>案例描述</strong>：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = {4,3,6,9,1,2,10,8,7,5};</p>
<p>示例：</p>
<pre><code class="lang-cpp">//冒泡排序函数
void bubbleSort(int * arr, int len) &#123;//int * arr 也可以写为int arr[]
    for (int i = 0; i &lt; len - 1; i++)    &#123;
        for (int j = 0; j &lt; len - 1 - i; j++)        &#123;
            if (arr[j] &gt; arr[j + 1])            &#123;
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            &#125;
        &#125;
    &#125;
&#125;

//打印数组函数
void printArray(int arr[], int len)&#123;
    for (int i = 0; i &lt; len; i++)    &#123;
        cout &lt;&lt; arr[i] &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;;
    int len = sizeof(arr) / sizeof(int);

    bubbleSort(arr, len);

    printArray(arr, len);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<p>看到这里的时候我就会有疑问？为什么数组在函数中不能值传递</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788.html</url>
    <content><![CDATA[<h1 id="快速排序—分治"><a href="#快速排序—分治" class="headerlink" title="快速排序—分治"></a>快速排序—分治</h1><p>快排的步骤主要是下面三步：</p>
<ol>
<li>确定分界点：确认一个数，使他数组分类的分界点<code>x</code>，一般（区间最左端，区间最右端，区间中间，随机）四种挑一个</li>
<li><strong>调整区间</strong>：将数组中比分界点小的数都移到分界点的左边，比分界点大的数都移到分界点右边</li>
<li>递归处理左右两区间：递归处理区间直到没有区间可以处理，这样得到的数组就是一个有序数组</li>
</ol>
<h2 id="调整区间的方法一：开两个额外数组"><a href="#调整区间的方法一：开两个额外数组" class="headerlink" title="调整区间的方法一：开两个额外数组"></a>调整区间的方法一：开两个额外数组</h2><ol>
<li><code>a[],b[]</code></li>
<li>将<code>q[l~r]</code>数组分类<ol>
<li>如果数小于等于<code>x</code>，那么该数就放入<code>a</code>数组</li>
<li>如果数大于<code>x</code>，那么该数就放入<code>b</code>数组</li>
</ol>
</li>
<li>然后将<code>a</code>数组放入<code>q</code>中，再将<code>b</code>数组放入<code>q</code>中</li>
</ol>
<p>这个方法的时间复杂度是 $O(n)$，因为只扫了两边数组，但是需要开辟额外的空间，空间复杂度是 $O(n)$.</p>
<h2 id="调整区间的方法二：使用双指针"><a href="#调整区间的方法二：使用双指针" class="headerlink" title="调整区间的方法二：使用双指针"></a>调整区间的方法二：使用双指针</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323153230.png" alt=""></p>
<p>我们利用双指针i从前往后遍历，找到第一个大于x的值，然后将j指针从后往前遍历没找到第一个小于等于x的值，交换这俩个指针所指的值。重复操作，直到两指针相遇。</p>
<p>这样我们的时间复杂度还是 $O(n)$，但是我们的空间复杂度是 $O(1)$。比之前的方法好上不少。</p>
<h2 id="练习题-785-快速排序"><a href="#练习题-785-快速排序" class="headerlink" title="练习题-785.快速排序"></a>练习题-<strong><a href="https://www.acwing.com/problem/content/description/787/">785.快速排序</a></strong></h2><p>这道题很坑，卡你用左端点作为分界点，我用左端点作为分界点的时候一直Tle，换成中间点作为分界点就AC了。</p>
<p>如果这个数组本来就是有序数组，那么快排耗时就会比较高。</p>
<pre><code class="lang-cpp">#include&lt;iostream&gt;

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn];

void quick_sort(int nums[], int l, int r)&#123;
    if(l &gt;= r) return;
    int target = nums[(l + r) &gt;&gt; 1];
    int i = l - 1, j = r + 1;
    while(i &lt; j)&#123;
        do ++i; while(nums[i] &lt; target);
        do --j; while(nums[j] &gt; target);
        if(i &lt; j) swap(nums[i], nums[j]);
    &#125;
    quick_sort(nums, l, j);
    quick_sort(nums, j + 1, r);
&#125;

int main()&#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;nums[i]);
    &#125;
    quick_sort(nums, 0, n - 1);
    cout &lt;&lt; nums[0];
    for(int i = 1; i &lt; n; i++) cout &lt;&lt; &#39; &#39; &lt;&lt; nums[i];
    cout &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h3 id="快排的应用-786-第k个数"><a href="#快排的应用-786-第k个数" class="headerlink" title="快排的应用-786.第k个数"></a>快排的应用-<strong><a href="https://www.acwing.com/problem/content/788/">786.第k个数</a></strong></h3><p>我们根据快排的原理能够很快的找到一个数在没有重复数字的数组中的位置，因此我们每当确立一个分界点的时候，我们先找到这个分界点的位置，如果该分界点的位置大于k，那么我们只要在分界点左边的数组中找即可，反之，我们在分界点的右边寻找。这样就能大大减少搜索范围。</p>
<pre><code class="lang-cpp">#include&lt;iostream&gt;

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn];
int k;

void quick_sort(int nums[], int l, int r)&#123;
    if(l &gt;= r) return;
    int target = nums[(l + r) &gt;&gt; 1];
    int i = l - 1, j = r + 1;
    while(i &lt; j)&#123;
        do ++i; while(nums[i] &lt; target);
        do --j; while(nums[j] &gt; target);
        if(i &lt; j) swap(nums[i], nums[j]);
    &#125;
    if(j &gt;= k - 1) quick_sort(nums, l, j);
    else quick_sort(nums, j + 1, r);
&#125;

int main()&#123;
    int n;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);
    for(int i = 0; i &lt; n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;nums[i]);
    &#125;
    quick_sort(nums, 0, n - 1);
    printf(&quot;%d\n&quot;, nums[k - 1]);
&#125;
</code></pre>
<h1 id="归并排序—分治"><a href="#归并排序—分治" class="headerlink" title="归并排序—分治"></a>归并排序—分治</h1><p>归并排序的主要步骤是</p>
<ol>
<li>确定分界点。指索引分界点：mid = (right + left) &gt;&gt; 1;</li>
<li>递归排序两个区间[left, mid],[mid + 1,right]。</li>
<li>归并—合二为一</li>
</ol>
<p>归并的具体操作：我们是先递归排序，这样两个区间都是有序的，那么我们合并两个区间的时候只要逐一获取两个区间的较小值即可。</p>
<p>每一轮的时间复杂度是 $O(n)$.因为一直是二分，那么说明递归层数有logn层，那么总时间复杂度是 $O(nlogn)$.</p>
<h2 id="练习题—787-归并排序"><a href="#练习题—787-归并排序" class="headerlink" title="练习题—787.归并排序"></a>练习题—<strong><a href="https://www.acwing.com/problem/content/789/">787.归并排序</a></strong></h2><pre><code class="lang-cpp">//模板题
#include&lt;iostream&gt;

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn];
int tmp[maxn];

void merge_sort(int nums[], int l, int r)&#123;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    merge_sort(nums, l, mid);
    merge_sort(nums, mid + 1, r);

    int i = l, j = mid + 1;
    int idx = 0;
    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;
        if(nums[i] &lt; nums[j]) tmp[idx++] = nums[i++];
        else tmp[idx++] = nums[j++];
    &#125;
    while(i &lt;= mid) tmp[idx++] = nums[i++];
    while(j &lt;= r) tmp[idx++] = nums[j++];
    for(int i = 0; i &lt; idx; i++)&#123;
        nums[l + i] = tmp[i];
    &#125;
&#125;

int main()&#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;nums[i]);
    &#125;
    merge_sort(nums, 0, n - 1);
    printf(&quot;%d&quot;, nums[0]);
    for(int i = 1; i &lt; n; i++)&#123;
        printf(&quot; %d&quot;, nums[i]);
    &#125;
    printf(&quot;\n&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="归并的应用—找逆序对的数量"><a href="#归并的应用—找逆序对的数量" class="headerlink" title="归并的应用—找逆序对的数量"></a>归并的应用—<a href="https://www.acwing.com/problem/content/790/">找逆序对的数量</a></h2><p>每次我们合并两个区间的时候，如果较前面的区间的数大于后面区间的数时，我们就对逆序对进行累加。</p>
<pre><code class="lang-cpp">#include&lt;iostream&gt;

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn], tmp[maxn];
long long ans = 0;

void merge_sort(int q[], int l, int r)&#123;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int idx = 0;
    int i = l, j = mid + 1;
    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;
        if(q[i] &gt; q[j]) &#123;
            ans += (mid - i + 1);
            tmp[idx++] = q[j++];
        &#125;else tmp[idx++] = q[i++];
    &#125;
    while(i &lt;= mid) tmp[idx++] = q[i++];
    while(j &lt;= r) tmp[idx++] = q[j++];
    for(int i = 0; i &lt; idx; i++) q[i + l] = tmp[i];
&#125;

int main()&#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;nums[i]);
    &#125;
    merge_sort(nums, 0, n - 1);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转数组</title>
    <url>/posts/c5ac4b34.html</url>
    <content><![CDATA[<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/description/">162. 寻找峰值</a></h1><p>根据之前灵神对于二分的理解，我们可以这样理解二分，<strong>把整个数组看成一个着色区间，其中红色代表不可能存在峰顶的区间，蓝色代表峰顶及其右边</strong>；</p>
<p>那么我们的范围是<code>[0,n-2]</code>，为什么呢？因为最后一位要么是峰顶要么在峰顶的右侧，因此最后一个位置的颜色就是蓝色。</p>
<p>刚开始我们是不知道<code>[0,n-2]</code>这个区间的颜色，因此我们要用开区间来写，那么开区间的范围就是<code>(-1, n-1)</code>，其中<code>-1</code>位置是红色，<code>n-1</code>位置是蓝色(为了区分才区分红蓝色，其实这两个位置在搜索中是没有的)。</p>
<p>那么我们定好区间之后，就开始确定<code>check</code>方法，我们在取到中间值<code>mid</code>之后，如果<code>nums[mid]&gt;nums[mid+1]</code>，那么说明<code>mid</code>要么是峰值，要么在峰值的右侧，因此我们可以把<code>[mid,right]</code>之间都着色蓝色。反之，说明<code>mid</code>在峰值的左侧，因此我们把区间<code>[left,mid]</code>着色红色。最后我们获取<code>right</code>位置上的索引，因为<code>right</code>及其右边是峰值及其右侧。</p>
<pre><code class="lang-sql">class Solution &#123;
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;
        int left = -1, right = nums.size() - 1;
        while(left  + 1 &lt; right)&#123;
            int mid = left + (right - left) / 2;
            if(nums[mid] &gt; nums[mid + 1])&#123;
                right = mid;
            &#125;else&#123;
                left = mid;
            &#125;
        &#125;
        return right;
    &#125;
&#125;;
</code></pre>
<h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><strong><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153. 寻找旋转排序数组中的最小值</a></strong></h1><p>这道题其实和上面一题一样，都是找峰值，只不过上面找的是峰顶，这里找的是峰底。</p>
<pre><code class="lang-sql">class Solution &#123;
public:
    int findMin(vector&lt;int&gt;&amp; nums) &#123;
        int left = -1, right = nums.size() - 1;
        while(left + 1 &lt; right)&#123;
            int mid = left + (right - left) / 2;
            if(nums[mid] &gt; nums[right])&#123;
                left = mid;
            &#125;else&#123;
                right = mid;
            &#125;
        &#125;
        return nums[right];
    &#125;
&#125;;
</code></pre>
<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><strong><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组</a></strong></h1><p>有两种做法：</p>
<p>一种是根据这个旋转排序数组的性质将数组分为两段有序数组，然后在有序数组中寻找到<code>target</code>，但是这样就需要用到两次二分</p>
<p>另一种是直接寻找，但是要根据这个旋转排序数组的性质来判断红蓝区域。</p>
<p>我们只讨论右边为蓝的情况</p>
<p>第一种，<code>mid</code>在右侧递增位，这个时候我们要想右边为蓝色区域，那就需要判断<code>target</code>在左侧。左侧分为两个有序数组，所以我们要分两种情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323145043.png" alt=""></p>
<p>第一种情况就是<code>target</code>在最初的两个有序数组的左边的数组，这个时候我们只要保证<code>target &gt; nums.back()</code>即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323145304.png" alt=""></p>
<p>第二种情况就是<code>target</code>在灰色数组的左侧，这个时候我们只要保证<code>target &lt; nums[mid]</code>即可。</p>
<p>还有另外一种情况，即<code>mid</code>的位置是蓝色数组的情况，这个时候我们要想让左边的区域是蓝色，那就得让<code>target</code>在左侧的蓝色数组内。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323145525.png" alt=""></p>
<p>这种情况我们只需要判断<code>target</code>是否在<code>[nums.back(),mid]</code>之间即可。</p>
<pre><code class="lang-cpp">class Solution &#123;
public:
    bool check(vector&lt;int&gt; &amp;nums, int target, int mid)&#123;
        if(nums[mid] &gt; nums.back())&#123;
            return nums.back() &lt; target &amp;&amp; target &lt;= nums[mid];
        &#125;else&#123;
            return target &lt;= nums[mid] || target &gt; nums.back();
        &#125;
    &#125;

    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = -1, right = (int)(nums.size());
        while(left + 1 &lt; right)&#123;
            int mid = (left + right) &gt;&gt; 1;
            if(check(nums, target, mid))&#123;
                right = mid;
            &#125;else&#123;
                left = mid;
            &#125;
        &#125;
        // cout &lt;&lt; right &lt;&lt; endl;
        if(right == (int)nums.size() || nums[right] != target) return -1;
        return right;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/posts/2ba40472.html</url>
    <content><![CDATA[<h2 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h2><p>操作系统是控制应用程序执行的程序，并充当应用程序和计算机硬件之间的接口</p>
<ul>
<li>作为用户/计算机接口</li>
<li>作为资源管理器（操作系统控制处理器使用其它系统资源，并控制其它程序的执行时机）</li>
<li>易扩展性</li>
</ul>
<h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><ol>
<li><strong>串行处理</strong>：程序员直接与计算机硬件打交道，因为当时还没操作系统。这些机器在一个控制台上运行，用机器代码编写的程序通过输入设备载入计算机。如果发生错误使得程序停止，错误原因由显示灯指示。如果程序正常完成，输出结果出现在打印机上</li>
<li><strong>简单批处理系统</strong>：中心思想是使用一个称为监控程序的软件。通过使用这类操作系统，用户不再直接访问机器，相反，用户把卡片或磁带种的作业提交给计算机操作员，由他把这些作业按顺序组织成一批，并将整个批作业放在输入设备上，供监控程序使用。每个程序完成处理后返回到监控程序，同时，监控程序自动加载下一个程序</li>
<li><strong>多道批处理系统</strong>：简单批处理系统提供了自动作业序列，但是处理器仍经常空闲，因为对于I/O指令，处理器必须等到其执行完才能继续。内存空间可以保持操作系统和一个用户程序，假设内存空间容得下操作系统和两个用户程序，那么当一个作业需要等到I/O时，处理器可以切换到另一个可能不需要等到I/O的作业。进一步还可以扩展存储器保存三个、四个或更多的程序，并且在他们之间进行切换。这种处理称为多道程序设计或多任务处理，是现代操作系统的主要方案</li>
<li><strong>分时系统</strong>：正如多道程序设计允许处理器同时处理多个批作业一样，它还可以用于处理多个交互作业。对于后一种情况，由于多个用户分享处理器时间，因而该技术称为分时。在分时系统中，多个用户可以通过终端同时访问系统，由操作系统控制每个用户程序以很短的时间为单位交替执行</li>
</ol>
<p>以下为多道批处理系统与分时系统的比较</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>批处理多道程序设计</th>
<th>分时</th>
</tr>
</thead>
<tbody>
<tr>
<td>主要目标</td>
<td>充分使用处理器</td>
<td>减小响应时间</td>
</tr>
<tr>
<td>操作系统指令源</td>
<td>作业控制语言；作业提供的命令</td>
<td>终端输入的命令</td>
</tr>
</tbody>
</table>
</div>
<h2 id="现代操作系统"><a href="#现代操作系统" class="headerlink" title="现代操作系统"></a>现代操作系统</h2><p>对操作系统要求上的变化速度之快不仅需要修改和增强现有的操作系统体系结构，而且需要有新的操作系统组织方法。在实验用和商用操作系统中有很多不同的方法和设计要素，大致分为以下几类：</p>
<ul>
<li>微内核体系结构</li>
<li>多线程</li>
<li>对称多处理：是一种计算机系统架构，其中多个处理器核心对称地共享系统资源和执行任务。在 SMP 架构中，每个处理器核心都可以独立执行指令，并且可以访问共享的内存、外部设备和其他系统资源。</li>
<li>分布式操作系统：</li>
<li>面向对象设计</li>
</ul>
<p><strong>大内核</strong>：至今为止大多数操作系统都有一个单体内核，操作系统应该提供的大多数功能由这些大内核提供，包括调度、文件系统、网络、设备管理器、存储管理等。典型情况下，这个大内核是作为一个进程实现的，所有元素共享相同的地址空间</p>
<p><strong>微内核</strong>：微内核体系结构只给内核分配一些最基本的功能，包括地址空间，进程间通信和基本的调度。其它操作系统服务都是由运行在用户态下且与其他应用程序类似的进程提供，这些进程可以根据特定应用和环境定制。这种方法把内核和服务程序的开发分离开，可以为特定的应用程序或环境要求定制服务程序。可以使系统结构的设计更简单、灵活，很适合于分布式环境</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>数组—一维数组</title>
    <url>/posts/c0086366.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素。</p>
<p>特点：</p>
<ol>
<li>数组中的每个<em>数据元素都是相同的数据类型</em></li>
<li>数组是由<em>连续的内存</em>位置组成的</li>
</ol>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="一维数组定义的三种方式："><a href="#一维数组定义的三种方式：" class="headerlink" title="一维数组定义的三种方式："></a>一维数组定义的三种方式：</h3><ol>
<li><code>数据类型 数组名[数组长度];</code></li>
<li><code>数据类型 数组名[数组长度] = &#123;值1,值2,...&#125;;</code></li>
<li><code>数据类型 数组名[] = &#123;值1,值2,...&#125;;</code></li>
</ol>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;

    //定义方式1
    //数据类型 数组名[元素个数];
    int score[10];

    //利用下标赋值
    score[0] = 100;
    score[1] = 99;
    score[2] = 85;

    //利用下标输出
    cout &lt;&lt; score[0] &lt;&lt; endl;
    cout &lt;&lt; score[1] &lt;&lt; endl;
    cout &lt;&lt; score[2] &lt;&lt; endl;

    //第二种定义方式
    //数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;
    //如果&#123;&#125;内不足10个数据，剩余数据用0补全
    int score2[10] = &#123;100,90,80,70,60,50,40,30,20,10 &#125;;

    //逐个输出
    //cout &lt;&lt; score2[0] &lt;&lt; endl;
    //cout &lt;&lt; score2[1] &lt;&lt; endl;

    //一个一个输出太麻烦，因此可以利用循环进行输出
    for (int i = 0; i &lt; 10; i++)    &#123;
        cout &lt;&lt; score2[i] &lt;&lt; endl;
    &#125;

    //定义方式3
    //数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;
    int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;;

    for (int i = 0; i &lt; 10; i++)    &#123;
        cout &lt;&lt; score3[i] &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h3 id="一维数组的数组名"><a href="#一维数组的数组名" class="headerlink" title="一维数组的数组名"></a>一维数组的数组名</h3><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    //数组名用途
    //1、可以获取整个数组占用内存空间大小
    int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;

    cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
    cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
    cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;

    //2、可以通过数组名获取到数组首地址
    cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;
    cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;
    cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;

    //arr = 100; 错误，数组名是常量，因此不可以赋值

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
<p>总结2：对数组进行sizeof，可以获取整个数组站内存空间的大小</p>
</blockquote>
<p><strong>练习案例1：五只小猪称体重</strong></p>
<p><strong>案例描述</strong>：</p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<pre><code class="lang-cpp">int main()&#123;
    int arr[5] = &#123;300,350,200,400,250&#125;;
    int max_weight = arr[0];

    for(int i = 1; i &lt; 5; i++)&#123;
        if(max_weight &lt; arr[i])&#123;
            max_weight = arr[i];
        &#125;
    &#125;

    cout &lt;&lt; &quot;最重的小猪体重是 &quot; &lt;&lt; max_weight &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324101604.png" alt=""></p>
<p><strong>练习案例2：数组元素逆置</strong></p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<pre><code class="lang-cpp">int main()&#123;
    int arr[5] = &#123;1, 3, 2, 5, 4&#125;;
    for(int i = 0; i &lt; 2; i++)&#123;
        int a = arr[i];
        arr[i] = arr[5 - i];
        arr[5 - i] = a;
    &#125;

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324101827.png" alt=""></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>作用</strong>：最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><strong>示例</strong>：将数组 {4,2,8,0,5,7,1,3,9} 进行升序排序</p>
<pre><code class="lang-cpp">int main() &#123;

    int arr[9] = &#123;4,2,8,0,5,7,1,3,9&#125;;

    for (int i = 0; i &lt; 9 - 1; i++)    &#123;
        for (int j = 0; j &lt; 9 - 1 - i; j++)        &#123;
            if (arr[j] &gt; arr[j + 1])            &#123;
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            &#125;
        &#125;
    &#125;

    for (int i = 0; i &lt; 9; i++)    &#123;
        cout &lt;&lt; arr[i] &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324101917.png" alt=""></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组—二维数组</title>
    <url>/posts/82583a29.html</url>
    <content><![CDATA[<p>二维数组就是在一维数组上，多加一个维度</p>
<h2 id="二维数组的定义方式"><a href="#二维数组的定义方式" class="headerlink" title="二维数组的定义方式"></a>二维数组的定义方式</h2><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型 数组名[行数][列数];</code></li>
<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code>数据类型 数组名[ ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上四种定义方式，利用<em>第二种更加只管，提高代码的可读性</em></p>
</blockquote>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;

    //方式1  
    //数组类型 数组名 [行数][列数]
    int arr[2][3];
    arr[0][0] = 1;
    arr[0][1] = 2;
    arr[0][2] = 3;
    arr[1][0] = 4;
    arr[1][1] = 5;
    arr[1][2] = 6;

    for (int i = 0; i &lt; 2; i++)&#123;
        for (int j = 0; j &lt; 3; j++)&#123;
            cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;

    //方式2 
    //数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;
    int arr2[2][3] = &#123;
        &#123;1,2,3&#125;,
        &#123;4,5,6&#125;
    &#125;;

    //方式3
    //数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;
    int arr3[2][3] = &#123; 1,2,3,4,5,6 &#125;; 

    //方式4 
    //数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;
    int arr4[][3] = &#123; 1,2,3,4,5,6 &#125;;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数。</p>
</blockquote>
<h2 id="二维数组数组名"><a href="#二维数组数组名" class="headerlink" title="二维数组数组名"></a>二维数组数组名</h2><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //二维数组数组名
    int arr[2][3] =    &#123;
        &#123;1,2,3&#125;,
        &#123;4,5,6&#125;
    &#125;;

    cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
    cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
    cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;

    cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;
    cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;

    //地址
    cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;
    cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;
    cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;

    cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;
    cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324102024.png" alt=""></p>
<h2 id="二维数组应用案例"><a href="#二维数组应用案例" class="headerlink" title="二维数组应用案例"></a>二维数组应用案例</h2><p><strong>考试成绩统计</strong>：</p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-cpp">int main() &#123;
    int scores[3][3] = &#123;
        &#123;100,100,100&#125;,
        &#123;90,50,100&#125;,
        &#123;60,70,80&#125;,
    &#125;;

    string names[3] = &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;;

    for (int i = 0; i &lt; 3; i++)    &#123;
        int sum = 0;
        for (int j = 0; j &lt; 3; j++)        &#123;
            sum += scores[i][j];
        &#125;
        cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>模板</title>
    <url>/posts/f6010553.html</url>
    <content><![CDATA[<h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如一寸照模板</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/template-ph1.png" alt=""></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li>C++另一种编程思想称为<em>泛型编程</em>，主要利用的技术就是模板</li>
<li>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></li>
</ul>
<h3 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h3><p>函数模板作用：</p>
<p>建议一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表</p>
<p><strong>语法</strong>：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
函数声明或定义
</code></pre>
<p>解释：</p>
<p>template ——— 声明创建模板</p>
<p>typename ——— 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T———通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//交换整型函数
void swapInt(int&amp; a, int&amp; b) &#123;
    int temp = a;
    a = b;
    b = temp;
&#125;

//交换浮点型函数
void swapDouble(double&amp; a, double&amp; b) &#123;
    double temp = a;
    a = b;
    b = temp;
&#125;

//利用模板提供通用的交换函数
template&lt;typename T&gt;
void mySwap(T&amp; a, T&amp; b)&#123;
    T temp = a;
    a = b;
    b = temp;
&#125;

void test01()&#123;
    int a = 10;
    int b = 20;

    //swapInt(a, b);

    //利用模板实现交换
    //1、自动类型推导
    mySwap(a, b);

    //2、显示指定类型
    mySwap&lt;int&gt;(a, b);

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<ul>
<li>总结：<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
</li>
</ul>
<h3 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h3><ul>
<li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//利用模板提供通用的交换函数
template&lt;class T&gt;
void mySwap(T&amp; a, T&amp; b)&#123;
    T temp = a;
    a = b;
    b = temp;
&#125;

// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用
void test01()&#123;
    int a = 10;
    int b = 20;
    char c = &#39;c&#39;;

    mySwap(a, b); // 正确，可以推导出一致的T
    //mySwap(a, c); // 错误，推导不出一致的T类型
&#125;

// 2、模板必须要确定出T的数据类型，才可以使用
template&lt;class T&gt;
void func()&#123;
    cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;
&#125;

void test02()&#123;
    //func(); //错误，模板不能独立使用，必须确定出T的类型
    func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板
&#125;

int main() &#123;

    test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331121858.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331121858.png"></p>
<ul>
<li>总结<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
</li>
</ul>
<h3 id="普通函数和函数模板的区别"><a href="#普通函数和函数模板的区别" class="headerlink" title="普通函数和函数模板的区别"></a>普通函数和函数模板的区别</h3><ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//普通函数
int myAdd01(int a, int b)&#123;
    return a + b;
&#125;

//函数模板
template&lt;class T&gt;
T myAdd02(T a, T b) &#123;
    return a + b;
&#125;

//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()&#123;
    int a = 10;
    int b = 20;
    char c = &#39;c&#39;;

    cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#39;c&#39;隐式转换为int类型  &#39;c&#39; 对应 ASCII码 99

    //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换

    myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331121938.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331121938.png"></p>
<ul>
<li><p>总结</p>
<p>  建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
</li>
</ul>
<h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//普通函数与函数模板调用规则
void myPrint(int a, int b)&#123;
    cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;
&#125;

template&lt;typename T&gt;
void myPrint(T a, T b) &#123; 
    cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;
&#125;

template&lt;typename T&gt;
void myPrint(T a, T b, T c) &#123; 
    cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; 
&#125;

void test01()&#123;
    //1、如果函数模板和普通函数都可以实现，优先调用普通函数
    // 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到
    int a = 10;
    int b = 20;
    myPrint(a, b); //调用普通函数

    //2、可以通过空模板参数列表来强制调用函数模板
    myPrint&lt;&gt;(a, b); //调用函数模板

    //3、函数模板也可以发生重载
    int c = 30;
    myPrint(a, b, c); //调用重载的函数模板

    //4、 如果函数模板可以产生更好的匹配,优先调用函数模板
    char c1 = &#39;a&#39;;
    char c2 = &#39;b&#39;;
    myPrint(c1, c2); //调用函数模板
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331122018.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
</li>
</ul>
<h3 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h3><ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如</strong>：</p>
<pre><code class="lang-cpp">template&lt;class T&gt;
void f(T a, T b)&#123; 
    a = b;
&#125;
</code></pre>
<p>在上述代码中提供的赋值操作，如果穿了的a和b是一个数组，就无法实现了</p>
<p><strong>再例如</strong>：</p>
<pre><code class="lang-cpp">template&lt;class T&gt;
void f(T a, T b)&#123; 
   if(a &gt; b) &#123; ... &#125;
&#125;
</code></pre>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include&lt;iostream&gt;
using namespace std;

#include &lt;string&gt;

class Person&#123;
public:
    Person(string name, int age)    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;
    string m_Name;
    int m_Age;
&#125;;

//普通函数模板
template&lt;class T&gt;
bool myCompare(T&amp; a, T&amp; b)&#123;
    if (a == b)    &#123;
        return true;
    &#125;    else    &#123;
        return false;
    &#125;
&#125;

//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型
//具体化优先于常规模板
template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123;
    if ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)    &#123;
        return true;
    &#125;    else    &#123;
        return false;
    &#125;
&#125;

void test01()&#123;
    int a = 10;
    int b = 20;
    //内置数据类型可以直接使用通用的函数模板
    bool ret = myCompare(a, b);
    if (ret)    &#123;
        cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;
    &#125;    else    &#123;
        cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;
    &#125;
&#125;

void test02()&#123;
    Person p1(&quot;Tom&quot;, 10);
    Person p2(&quot;Tom&quot;, 10);
    //自定义数据类型，不会调用普通的函数模板
    //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
    bool ret = myCompare(p1, p2);
    if (ret)    &#123;
        cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;
    &#125;    else    &#123;
        cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331122249.png" alt=""></p>
<ul>
<li>总结<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
</li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h3><p>类模板作用：</p>
<p>建立一个通用类，类中的成员，数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法</strong>：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
类
</code></pre>
<p>解释：</p>
<p>template ——— 声明创建模板</p>
<p>typename ——— 表明其后面的符号是一种护具类型，可以用class代替</p>
<p>T ——— 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType&gt; 
class Person&#123;
public:
    Person(NameType name, AgeType age)    &#123;
        this-&gt;mName = name;
        this-&gt;mAge = age;
    &#125;
    void showPerson()    &#123;
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
    &#125;
public:
    NameType mName;
    AgeType mAge;
&#125;;

void test01()&#123;
    // 指定NameType 为string类型，AgeType 为 int类型
    Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);
    P1.showPerson();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331122445.png" alt=""></p>
<ul>
<li><p>总结：</p>
<p>  类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
</li>
</ul>
<h3 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h3><p>区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType = int&gt; 
class Person&#123;
public:
    Person(NameType name, AgeType age)    &#123;
        this-&gt;mName = name;
        this-&gt;mAge = age;
    &#125;
    void showPerson()    &#123;
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
    &#125;
public:
    NameType mName;
    AgeType mAge;
&#125;;

//1、类模板没有自动类型推导的使用方式
void test01()&#123;
    // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导
    Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板
    p.showPerson();
&#125;

//2、类模板在模板参数列表中可以有默认参数
void test02()&#123;
    Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数
    p.showPerson();
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331122536.png" alt=""></p>
<ul>
<li>总结：<ul>
<li>类模板使用只能用显式指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
</li>
</ul>
<h3 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建实际是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person1&#123;
public:
    void showPerson1()    &#123;
        cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Person2&#123;
public:
    void showPerson2()    &#123;
        cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;
    &#125;
&#125;;

template&lt;class T&gt;
class MyClass&#123;
public:
    T obj;

    //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成

    void fun1() &#123; obj.showPerson1(); &#125;
    void fun2() &#123; obj.showPerson2(); &#125;

&#125;;

void test01()&#123;
    MyClass&lt;Person1&gt; m;

    m.fun1();

    //m.fun2();//编译会出错，说明函数调用才会去创建成员函数
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331122809.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
</li>
</ul>
<h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式</p>
<ol>
<li>指定传入的类型 ——— 直接显示对象的数据类型</li>
<li>参数模板化 ——— 将对象中的参数变为模板进行传递</li>
<li>整个类模板化 ——— 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType = int&gt; 
class Person&#123;
public:
    Person(NameType name, AgeType age)    &#123;
        this-&gt;mName = name;
        this-&gt;mAge = age;
    &#125;
    void showPerson()    &#123;
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
    &#125;
public:
    NameType mName;
    AgeType mAge;
&#125;;

//1、指定传入的类型
void printPerson1(Person&lt;string, int&gt; &amp;p) &#123;
    p.showPerson();
&#125;
void test01()&#123;
    Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);
    printPerson1(p);
&#125;

//2、参数模板化
template &lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123;
    p.showPerson();
    cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;
    cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;
&#125;
void test02()&#123;
    Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);
    printPerson2(p);
&#125;

//3、整个类模板化
template&lt;class T&gt;
void printPerson3(T &amp; p)&#123;
    cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;
    p.showPerson();

&#125;
void test03()&#123;
    Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30);
    printPerson3(p);
&#125;

int main() &#123;

    test01();
    test02();
    test03();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331122854.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  通过类模板创建的对象，可以有三种方式向函数中进行传参</p>
<p>  使用比较广泛是第一种：指定传入的类型</p>
</li>
</ul>
<h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">template&lt;class T&gt;
class Base&#123;
    T m;
&#125;;

//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son :public Base&lt;int&gt; //必须指定一个类型
&#123;
&#125;;
void test01()&#123;
    Son c;
&#125;

//类模板继承类模板 ,可以用T2指定父类中的T类型
template&lt;class T1, class T2&gt;
class Son2 :public Base&lt;T2&gt;&#123;
public:
    Son2()    &#123;
        cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;
        cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;
    &#125;
&#125;;

void test02()&#123;
    Son2&lt;int, char&gt; child1;
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331123018.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  如果父类是类模板，子类需要指定出父类中T的数据类型</p>
</li>
</ul>
<h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><p>学习目标： 能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;string&gt;

//类模板中成员函数类外实现
template&lt;class T1, class T2&gt;
class Person &#123;
public:
    //成员函数类内声明
    Person(T1 name, T2 age);
    void showPerson();

public:
    T1 m_Name;
    T2 m_Age;
&#125;;

//构造函数 类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
&#125;

//成员函数 类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson() &#123;
    cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
&#125;

void test01()&#123;
    Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);
    p.showPerson();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230331123148.png" alt=""></p>
<ul>
<li><p>总结</p>
<p>  类模板中成员函数类外实现时，需要加上模板参数列表</p>
</li>
</ul>
<h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p>学习目标：</p>
<p>掌握类模板成员函数分文件编写产生的问题以及解决方式</p>
<p>问题：</p>
<p>类模板中成员函数创建时机是在调用阶段，导致份文件编写时链接不到</p>
<p>解决：</p>
<ol>
<li>直接包含.cpp源文件</li>
<li>将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ol>
<p><strong>示例</strong>：</p>
<p>person.hpp代码</p>
<pre><code class="lang-cpp">#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &lt;string&gt;

template&lt;class T1, class T2&gt;
class Person &#123;
public:
    Person(T1 name, T2 age);
    void showPerson();
public:
    T1 m_Name;
    T2 m_Age;
&#125;;

//构造函数 类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
&#125;

//成员函数 类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson() &#123;
    cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
&#125;
</code></pre>
<p>类模板分文件编写.cpp中代码</p>
<pre><code class="lang-cpp">#include&lt;iostream&gt;
using namespace std;

//#include &quot;person.h&quot;
#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include &quot;person.hpp&quot;
void test01()&#123;
    Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);
    p.showPerson();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<ul>
<li><p>总结</p>
<p>  主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
</li>
</ul>
<h3 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h3><p>学习目标：</p>
<p>掌握类模板配合友元函数的类内和类外实现</p>
<p>全局函数类内实现 ——— 直接在类内声明友元即可</p>
<p>全局函数类外实现 ——— 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">#include &lt;string&gt;

//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元
template&lt;class T1, class T2&gt; class Person;

//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); 

template&lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123;
    cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;
&#125;

template&lt;class T1, class T2&gt;
class Person&#123;
    //1、全局函数配合友元   类内实现
    friend void printPerson(Person&lt;T1, T2&gt; &amp; p)    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;
    &#125;

    //全局函数配合友元  类外实现
    friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);

public:
    Person(T1 name, T2 age)    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;

private:
    T1 m_Name;
    T2 m_Age;
&#125;;

//1、全局函数在类内实现
void test01()&#123;
    Person &lt;string, int &gt;p(&quot;Tom&quot;, 20);
    printPerson(p);
&#125;

//2、全局函数在类外实现
void test02()&#123;
    Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30);
    printPerson2(p);
&#125;

int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<ul>
<li><p>总结</p>
<p>  建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++提高</category>
      </categories>
  </entry>
  <entry>
    <title>环形链表II</title>
    <url>/posts/7ad2c734.html</url>
    <content><![CDATA[<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876.链表的中间结点"></a><strong><a href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">876.链表的中间结点</a></strong></h2><p>这道题就是一道典型的快慢指针的问题，让我们找一串链表的中间位置。</p>
<p>暴力的做法是先扫一遍，看看这个链表的长度，然后根据长度找到目标值。</p>
<p>有没有更巧妙的做法呢？有，就是快慢指针，因为我们要求链表的中间节点，那么我们设置两个指针，一个指针一次走两格，另一个指针一次走一格。这样我们就能保证走一格的指针始终是走两格的指针的中间，当走得快的指针走到终点的时候返回走得慢的指针即可。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* middleNode(ListNode* head) &#123;
        ListNode* p = head;
        while(p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;next != NULL)&#123;
            head = head-&gt;next;
            p = p-&gt;next-&gt;next;
        &#125;
        if(p-&gt;next == NULL) return head;
        else return head-&gt;next;
    &#125;
&#125;;
</code></pre>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a><strong><a href="https://leetcode.cn/problems/linked-list-cycle/description/">141.环形链表</a></strong></h2><p>证明链表是否有环，我们只要根据链表的next指针一直往下走就行，如果遇到空指针，那么说明没有环，但是我们什么时候推出寻找next呢？万一有环不是得一直寻找下去吗？所以这个方法不行。</p>
<p>我们可以用快慢指针来解决这个问题。</p>
<p>快指针还是一次走两格，满指针一次走一格。</p>
<p>用递归法证明，快慢指针一定会相遇：</p>
<ol>
<li>快指针与慢指针之间差一步。此时继续往后走，满指针前进一步，快指针前进两步，两者相遇。</li>
<li>快指针与满指针之间差两步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，转化为第一种情况。</li>
<li>快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差（N+1-2）即N-2步。重复这个过程，直到快指针和慢指针相遇。</li>
</ol>
<ul>
<li><p>推导：慢指针进入环后，快指针最多多绕一个圈</p>
<p>  快指针F先进环，慢指针S后进</p>
<p>  假设慢指针进环那一刻快指针差m步能追上（0≤m≤Length环），根据上边的结论，两个指针走m次就会相遇了</p>
<p>  因为m&lt;Length环，所以快指针在慢指针进环那一刻最多比慢指针多绕一个圈。</p>
</li>
</ul>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    bool hasCycle(ListNode *head) &#123;
        if(head == NULL) return false;
        ListNode* p = head;
        while(p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;next != NULL)&#123;
            p = p-&gt;next-&gt;next;
            head = head-&gt;next;
            if(p == head) return true;
        &#125;
        return false;
    &#125;
&#125;;
</code></pre>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a><strong><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142.环形链表 II</a></strong></h2><p>这道题有一个证明：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230326144715.png" alt=""></p>
<p>其中a是head到入口的距离，b是入口到快慢指针相遇的距离，c是相遇点到入口的长度。</p>
<p>这样我们就能知道3个关系式</p>
<ol>
<li>环长:b+c</li>
<li>慢指针移动距离:a+b</li>
<li>快指针移动距离:a+b+k(b+c)</li>
</ol>
<p>因为快指针移动速度是慢指针移动速度的两倍</p>
<p>所以: a+b+k(b+c) = 2(a+b)</p>
<p>⇒a+b+b+c+(k-1)(b+c)=a+a+b+b</p>
<p>⇒a=(k-1)(b+c)-c</p>
<p>⇒a=(k-1)*Length环+c</p>
<p>因此当快慢指针相遇后，一个一次只移动一格的指针到达入口时，慢指针也刚好从相遇点到入口。这时两个指针就相遇了。</p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        if(head == NULL) return head;
        ListNode *p = head, *ans = head;
        while(head-&gt;next != NULL &amp;&amp; head-&gt;next-&gt;next != NULL)&#123;
            head = head-&gt;next-&gt;next;
            p = p-&gt;next;
            if(head == p) break;
        &#125;
        if(head-&gt;next == NULL || head-&gt;next-&gt;next == NULL) return NULL;
        while(ans != p)&#123;
            ans = ans-&gt;next;
            p = p-&gt;next;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143.重排链表"></a><strong><a href="https://leetcode.cn/problems/reorder-list/description/">143.重排链表</a></strong></h2><p>看到题目的要求，让我们将前面一半的链表以及后面一般的链表倒置进行合并。</p>
<p>这样我们就需要用到上一篇用到的反转链表的方法，之后再进行合并。</p>
<p>合并的具体步骤如下：</p>
<ol>
<li>两个初始链表，head1、head2是两个链表的头指针，s记录合并链表的当前位置</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230326152438.png" alt=""></p>
<ol>
<li>第一个链表的头指针向后移动一位</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230326152510.png" alt=""></p>
<ol>
<li>我们更改当前节点的next指针，将next指针指向另外一条链表的头指针</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230326152738.png" alt=""></p>
<ol>
<li>移动s指针，将s移到s的next位置，再将head2指针往后移一个</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230326153033.png" alt=""></p>
<ol>
<li>继续移动s指针，再回到第一步</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230326153129.png" alt=""></p>
<pre><code class="lang-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* revserseList(ListNode* head)&#123;
        ListNode *t = NULL, *p = head;
        while(head)&#123;
            head = head-&gt;next;
            p-&gt;next = t;
            t = p;
            p = head;
        &#125;
        return t;
    &#125;

    void reorderList(ListNode* head) &#123;
        if(head-&gt;next == NULL) return;
        ListNode* f = head, *s = head, *t = head;
        while(f-&gt;next != NULL &amp;&amp; f-&gt;next-&gt;next != NULL)&#123;
            f = f-&gt;next-&gt;next;
            t = s;
            s = s-&gt;next;
        &#125;
        ListNode *list1;
        if(f-&gt;next == NULL)&#123;
            t-&gt;next = NULL;
            list1 = revserseList(s);
        &#125;else&#123;
            t = s;
            s = s-&gt;next;
            t-&gt;next = NULL;
            list1 = revserseList(s);
        &#125;

        f = head, s = head, t = head;
        ListNode *ans = head;
        while(head)&#123;
            s = head;
            head = head-&gt;next;
            s-&gt;next = list1;
            s = s-&gt;next;
            list1 = list1-&gt;next;
            s-&gt;next = head;
        &#125;
        if(list1)&#123;
            s-&gt;next = list1;
        &#125;
        head = ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器 接雨水</title>
    <url>/posts/a055a13d.html</url>
    <content><![CDATA[<h1 id="盛最多水的容器-接雨水"><a href="#盛最多水的容器-接雨水" class="headerlink" title="盛最多水的容器 接雨水"></a>盛最多水的容器 接雨水</h1><h1 id="11-盛最多水的容器-Medium"><a href="#11-盛最多水的容器-Medium" class="headerlink" title="11. 盛最多水的容器(Medium)"></a><strong><a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器</a>(Medium)</strong></h1><p>这道题的双指针刚开始用着很迷茫，因为不知道怎么验证这个双指针的正确性，然后我在题解中找到了一篇有关他的<a href="https://leetcode.cn/problems/container-with-most-water/solutions/11491/container-with-most-water-shuang-zhi-zhen-fa-yi-do/">正确性验证</a>。大佬讲的很细致！</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/lcsszz.png" alt=""></p>
<p>这道题用的双指针做法，我们用两个指针来表示区间的一头一尾，比较头尾指针的挡板高度之后再决定调整哪块挡板。调整的时候我们会消去一些状态，之前我就一直迷惑万一这些状态会不会有隐藏最大值，但是通过上面的证明的时候我才解开疑惑。每次更新头尾指针之后消去的状态他们所包含的最大值肯定是小于等于当前状态的，比如上面图片中因为S(i,j)→S(i+1,j)而消去的S(i,j-1),S(i,j-2),…,S(i,i+1)，他们所表示的面积时小于S(i,j)的，因为他们的短板要么是h[i],如果不是h[i]那就说明短板比h[i]更小，那么决定面积的短板高度因素就能排除在外了，之后再看底边宽度，因为原来的宽度时j-i，而后面的底边宽度范围时[1,j-i-1]，两者都比S(i,j)要小，因此S(i,j-1),S(i,j-2),…,S(i,i+1)这些都是小于S(i,j)的，我们最后只要比较S(i,j)和其他组合的比较即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-sql">class Solution &#123;
public:
    int maxArea(vector&lt;int&gt;&amp; height) &#123;
        int left = 0, right = height.size() - 1;
        int res = 0;
        while(right &gt; left)&#123;
            res = max(res, (right - left) * min(height[right], height[left]));
            if(height[right] &lt; height[left]) right--;
            else left++;
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="42-接雨水-Hard"><a href="#42-接雨水-Hard" class="headerlink" title="42. 接雨水(Hard)"></a><strong><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水</a>(Hard)</strong></h1><p>这道题有两种做法，一种就是前后缀，另一种是双指针。</p>
<h2 id="前后缀"><a href="#前后缀" class="headerlink" title="前后缀"></a>前后缀</h2><p>这里的前缀是指从头往后当前遇到的最高的高度，比如说如果高度数组是<code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>，那么前缀数组就是<code>[0,1,1,2,2,2,2,3,3,3,3,3]</code>，这个数组中的数字代表从起始点到当前点所遇到的圆柱最高点，后缀数组是<code>[3,3,3,3,3,3,3,3,2,2,2,1]</code>，这两个数组有什么作用呢？我们根据索引依次遍历数组，当遍历到索引为<code>0</code>的时候，前缀数组是<code>0</code>，后缀数组是<code>3</code>，根据短板原理，我们这时只能取到<code>0</code>，当遍历到索引为<code>6</code>时，前缀数组是<code>2</code>，后缀数组是<code>3</code>，这时候根据短板原理水深应该是<code>2</code>，但是这个索引下高度本身就是<code>1</code>，那么水深就是<code>1</code>.根据这个思想我们统计所有索引值下的水深。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">class Solution &#123;
public:
    int trap(vector&lt;int&gt;&amp; height) &#123;
        int ans = 0;
        int height_len = height.size();
        if(!height_len)&#123;
            return 0;
        &#125;
        vector&lt;int&gt; max_left, max_right;
        max_left.emplace_back(height[0]);
        for(int i = 1; i &lt; height_len; i++)&#123;
            max_left.emplace_back(max(height[i], max_left[i - 1]));
        &#125;
        max_right.emplace_back(height[height_len - 1]);
        int k = 0;
        for(int i = height_len - 2; i &gt;= 0; i--)&#123;
            max_right.emplace_back(max(height[i], max_right[k++]));
        &#125;
        for(int i = 1; i &lt; height_len - 1; i++)&#123;
            ans += min(max_left[i], max_right[height_len - i - 1]) - height[i];
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h2><p>这里的思想就和上面的盛最多的水一样，都是增加短板，慢慢更新。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">class Solution &#123;
public:
    int trap(vector&lt;int&gt; &amp;height) &#123;
        int ans = 0, left = 0, right = height.size() - 1, pre_max = 0, suf_max = 0;
        while (left &lt;= right) &#123;
            pre_max = max(pre_max, height[left]);
            suf_max = max(suf_max, height[right]);
            ans += pre_max &lt; suf_max ? pre_max - height[left++] : suf_max - height[right--];
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>程序流程结构(一)—选择结构</title>
    <url>/posts/69cbb075.html</url>
    <content><![CDATA[<p>C/C++支持最基本的三种程序运行结构：<em>顺序结构、选择结构、循环结构</em>。</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p><strong>作用</strong>：执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li>单行格式if语句</li>
<li>多行格式if语句</li>
<li>多条件的if语句</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件)&#123;条件满足执行的语句&#125;</code></p>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/select_1.png" alt=""></p>
<p> 示例：</p>
<pre><code class="lang-cpp"> int main() &#123;

        //选择结构-单行if语句
        //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印

        int score = 0;
        cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;
        cin &gt;&gt; score;

        cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;

        //if语句
        //注意事项，在if判断语句后面，不要加分号
        if (score &gt; 600)       &#123;
            cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;
        &#125;

        system(&quot;pause&quot;);

        return 0;
 &#125;
</code></pre>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324100442.png" alt=""></p>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
</li>
<li><p>多行格式if语句：<code>if(条件)&#123;条件满足执行的语句&#125;else&#123;条件不满足执行的语句&#125;</code></p>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/select_2.png" alt=""></p>
<p> 示例：</p>
<pre><code class="lang-cpp"> int main() &#123;

     int score = 0;

     cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

     cin &gt;&gt; score;

     if (score &gt; 600)    &#123;
         cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
     &#125;    else    &#123;
         cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;
     &#125;

     system(&quot;pause&quot;);

     return 0;
 &#125;
</code></pre>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324100546.png" alt=""></p>
<ol>
<li><p>多条件的if语句：<code>if(条件1)&#123;条件1满足执行的语句&#125;else if(条件2)&#123;条件2满足执行的语句&#125;…else&#123;都不满足执行的语句&#125;</code></p>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/select_3.png" alt=""></p>
<p> 示例：</p>
<pre><code class="lang-cpp"> int main() &#123;

     int score = 0;

     cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;

     cin &gt;&gt; score;

     if (score &gt; 600)    &#123;
         cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
     &#125;    else if (score &gt; 500)    &#123;
         cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
     &#125;    else if (score &gt; 400)    &#123;
         cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
     &#125;    else    &#123;
         cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
     &#125;

     system(&quot;pause&quot;);

     return 0;
 &#125;
</code></pre>
<p> <img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324100708.png" alt=""></p>
</li>
</ol>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断<ul>
<li>分数如果大于600分视为考上一本</li>
<li>大于500分考上二本</li>
<li>大于400分考上三本</li>
<li>其余视为考上本科</li>
</ul>
</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp">int main() &#123;

    int score = 0;

    cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;
    cin &gt;&gt; score;

    if (score &gt; 600)&#123;
        cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;
        if (score &gt; 700)&#123;
            cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;
        &#125;else if (score &gt; 650)&#123;
            cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;
        &#125;else&#123;
            cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;
        &#125;    
    &#125;else if (score &gt; 500)&#123;
        cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;
    &#125;else if (score &gt; 400)&#123;
        cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;
    &#125;    else    &#123;
        cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324100750.png" alt=""></p>
<p><strong>练习案例</strong>：三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？</p>
<pre><code class="lang-cpp">int main()&#123;
    int weightA, weightB, weightC;

    cout &lt;&lt; &quot;请输入小猪A的体重: &quot;;
    cin &gt;&gt; weightA;

    cout &lt;&lt; &quot;请输入小猪B的体重: &quot;;
    cin &gt;&gt; weightB;

    cout &lt;&lt; &quot;请输入小猪C的体重: &quot;;
    cin &gt;&gt; weightC;

    if(weightA &gt; weightB)&#123;
        if(weightA &gt; weightC)&#123;
            cout &lt;&lt; &quot;小猪A最重&quot; &lt;&lt; endl;
        &#125; else &#123;
            cout &lt;&lt; &quot;小猪C最重&quot; &lt;&lt; endl;
        &#125;
    &#125;else&#123;
        if(weightB &gt; weightC)&#123;
            cout &lt;&lt; &quot;小猪B最重&quot; &lt;&lt; endl;
        &#125;else&#123;
            cout &lt;&lt; &quot;小猪C最重&quot; &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324100914.png" alt=""></p>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p><strong>作用</strong>：通过三目运算符实现简单的判断</p>
<p><strong>语法</strong>：<code>表达式1 ? 表达式2 : 表达式3;</code></p>
<p><strong>解释</strong>：</p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的值；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的值。</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    int a = 10;
    int b = 20;
    int c = 0;

    c = a &gt; b ? a : b;
    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

    //C++中三目运算符返回的是变量,可以继续赋值

    (a &gt; b ? a : b) = 100;//给较大值赋值100

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324100955.png" alt=""></p>
<blockquote>
<p>总结：和if语句比较，三目运算符的优点是短小整洁，缺点是如果用嵌套，结构不清晰。</p>
</blockquote>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p><strong>作用</strong>：执行多条分支语句</p>
<p><strong>语法</strong>：</p>
<pre><code class="lang-cpp">switch(表达式)&#123;

    case 结果1：执行语句;break;

    case 结果2：执行语句;break;

    ...

    default:执行语句;break;//必定是最后执行，就算default放在第一位也是最后执行。

&#125;
</code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //请给电影评分 
    //10 ~ 9   经典   
    // 8 ~ 7   非常好
    // 6 ~ 5   一般
    // 5分以下 烂片

    int score = 0;
    cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;
    cin &gt;&gt; score;

    switch (score)&#123;
    case 10:
    case 9:
        cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;
        break;
    case 8:
        cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;
        break;
    case 7:
    case 6:
        cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;
        break;
    default:
        cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;
        break;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符串</p>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
<p>总结：与if语句相比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>程序流程结构(三)—跳转语句</title>
    <url>/posts/5d341b74.html</url>
    <content><![CDATA[<h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p><strong>作用</strong>：用于跳出<em>选择结构</em>或者<em>循环结构</em></p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch语句</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //1、在switch 语句中使用break
    cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl;

    int num = 0;
    cin &gt;&gt; num;

    switch (num)    &#123;
    case 1:
        cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;
        break;
    case 2:
        cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;
        break;
    case 3:
        cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;
        break;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>示例2</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //2、在循环语句中用break
    for (int i = 0; i &lt; 10; i++)    &#123;
        if (i == 5)&#123;
            break; //跳出循环语句
        &#125;
        cout &lt;&lt; i &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>示例3</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    //在嵌套循环语句中使用break，退出内层循环
    for (int i = 0; i &lt; 10; i++)    &#123;
        for (int j = 0; j &lt; 10; j++)        &#123;
            if (j == 5)            &#123;
                break;
            &#125;
            cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p><strong>作用</strong>：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    for (int i = 0; i &lt; 100; i++)    &#123;
        if (i % 2 == 0)    &#123;
            continue;
        &#125;
        cout &lt;&lt; i &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p><strong>作用</strong>：可以无条件跳转语句</p>
<p><strong>语法</strong>：<code>goto 标记;</code></p>
<p><strong>解释</strong>：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;

    goto FLAG;

    cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;

    FLAG:

    cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>程序流程结构(二)—循环结构</title>
    <url>/posts/1e3009f2.html</url>
    <content><![CDATA[<h2 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h2><p><strong>作用</strong>：满足循环条件，执行循环语句</p>
<p><strong>语法</strong>：<code>while(循环条件)&#123;循环语句&#125;</code></p>
<p><strong>解释</strong>：<em>只要循环条件的结果为真，就执行循环语句</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/cycle-1.png" alt=""></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    int num = 0;
    while (num &lt; 10)&#123;
        cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
        num++;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324101134.png" alt=""></p>
<blockquote>
<p>注意：在执行循环语句时，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<h2 id="do…while循环语句"><a href="#do…while循环语句" class="headerlink" title="do…while循环语句"></a>do…while循环语句</h2><p><strong>作用</strong>：满足循环条件，执行循环语句</p>
<p><strong>语法</strong>：<code>do&#123;循环语句&#125;while(循环条件);</code></p>
<p><strong>注意</strong>：与while的区别在于<em>do…whlie会先执行一次循环语句</em>，再判断循环条件</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/cycle-2.png" alt=""><br><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;
    int num = 0;

    do&#123;
        cout &lt;&lt; num &lt;&lt; endl;
        num++;

    &#125; while (num &lt; 10);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324101244.png" alt=""></p>
<p><strong>案例练习：水仙花数</strong></p>
<p><strong>案例描述</strong>：水仙花数是指一个3位数，它的每个位上的数字的3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3 + 3^3 = 153</p>
<p>请利用do…while语句，求出所有三位数的水仙花数</p>
<pre><code class="lang-cpp">int main()&#123;
    int num = 100;
    while(num &lt; 1000)&#123;
        int a = num % 10;
        int b = (num / 10) % 10;
        int c = num / 100;
        if(a * a * a + b * b * b + c * c * c == num)&#123;
            cout &lt;&lt; num &lt;&lt; endl;
        &#125;
        num++;
    &#125;
    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230324101407.png" alt=""></p>
<h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><p><strong>作用</strong>：满足循环条件，执行循环语句</p>
<p><strong>语法</strong>：<code>for(起始表达式;条件表达式;末尾循环体)&#123;循环语句;&#125;</code></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    for (int i = 0; i &lt; 10; i++)
    &#123;
        cout &lt;&lt; i &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/cycle-3.png" alt=""></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分割</p>
<p>总结：while，do…while，for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p>练习案例：敲桌子</p>
<p>案例描述：从1开始数到数字100，如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<pre><code class="lang-cpp">int main()&#123;
    for(int i = 1; i &lt;= 100; i++)&#123;
        if(i % 10 == 7)&#123;
            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt; endl;
        &#125; else if(i / 10 == 7)&#123;
            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt; endl;
        &#125; else if(i % 7 == 0)&#123;
            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt; endl;
        &#125; else &#123;
            cout &lt;&lt; i &lt;&lt; endl;
        &#125;
    &#125;

    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><p><strong>作用</strong>：在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/cycle-4.png" alt=""></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">int main() &#123;

    //外层循环执行1次，内层循环执行1轮
    for (int i = 0; i &lt; 10; i++)    &#123;
        for (int j = 0; j &lt; 10; j++)    &#123;
            cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>线程</title>
    <url>/posts/15fc6e8c.html</url>
    <content><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li><strong>进程</strong>是操作系统进行资源分配的基本单位</li>
<li><strong>线程</strong>是调度的基本单位</li>
</ul>
<p>进程中的所有线程共享该进程的状态和资源，进程和线程的关系如下图：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518102036.png" alt="Img"></p>
<p>从性能上比较，线程具有如下优点：</p>
<ol>
<li>在一个已有进程中创建一个新线程比创建一个全新进程所需的时间要少许多</li>
<li>终止一个线程比终止一个进程花费的时间少</li>
<li>同一进程内线程间切换比进程间切换花费的时间少</li>
<li>线程提高了不同的执行程序间通信的效率（在大多数操作系统中，独立进程间的通信需要内核的介入，以提供保护和通信所需要的机制。但是，由于在同一个进程中的线程共享内存和文件，它们无须调用内核就可以互相通信）</li>
</ol>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>和进程一样，线程的关键状态有运行态、就绪态和阻塞态。一般来说，挂起态对线程没有什么意义。这是由于此类状态是一个进程级的概念。特别地，如果一个进程被换出，由于它的所有线程都共享该进程的地址空间，因此它们必须都被换出</p>
<p>有4种与线程相关的基本操作：</p>
<ul>
<li><strong>派生</strong>：在典型情况下，当派生一个新进程时，同时也为该进程派生了一个线程。随后，进程中的线程可以在同一进程中派生另一个线程，并为新线程提供指令指针和参数；新线程拥有自己的寄存器上下文和栈空间，且被放置在就绪队列中</li>
<li><strong>阻塞</strong>：当线程需要等待一个事件时，它将被阻塞（保存它的用户寄存器、程序计数器和栈指针），此时处理器转而执行另一个处于同一进程中或不同进程中的就绪线程</li>
<li><strong>解除阻塞</strong>：当阻塞一个线程的事件发生时，该线程被转移到就绪队列中</li>
<li><strong>结束</strong>：当一个线程完成时，其寄存器上下文和栈都被释放</li>
</ul>
<p>线程的生命周期</p>
<p>线程的一些状态：</p>
<ol>
<li><strong>新建</strong>：创建线程对象</li>
<li><strong>就绪</strong>：线程有执行资格，没有执行权</li>
<li><strong>运行</strong>：有执行资格，有执行权</li>
<li><strong>阻塞</strong>：由于一些操作让线程改变了状态，没有执行资格，没有执行权；另一些操作可以把它给激活，激活处于就绪状态</li>
<li><strong>死亡</strong>：线程对象变成垃圾，等待被回收</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518102636.png" alt="Img"></p>
<h2 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h2><p>线程的实现可以分为两大类：</p>
<ul>
<li><strong>用户级线程</strong>：有关线程管理的所有工作都由应用程序完成(使用线程库)，内核意识不到线程的存在</li>
<li><strong>内核级线程</strong>：有关线程管理的所有工作都由内核完成，应用程序部分没有进行线程管理的代码</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518102843.png" alt="Img"></p>
<h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>在用户级线程中，进程和线程的状态可能有如下转换</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518103007.png" alt="Img"></p>
<ul>
<li>a)-&gt;b)：<strong>线程2中执行的应用程序代码进行系统调用</strong>，阻塞了进程B。例如，进行一次I/O调用。这导致控制转移到内核，内核启动I/O操作，把进程B置于阻塞状态，并切换到另一个进程。在此期间，根据线程库维护的数据结构，进程B的线程2仍处于运行状态。值得注意的是，从处理器上执行的角度看，线程2实际上并不处于运行态，但是在线程库看来，它处于运行态</li>
<li>a)-&gt;c)：<strong>时钟中断把控制传递给内核</strong>，内核确定当前正在运行的进程B已经用完了它的时间片。内核把进程B置于就绪态并切换到另一个进程。同时，根据线程库维护的数据结构，进程B的线程2仍处于运行态</li>
<li>a)-&gt;d)：<strong>线程2运行到需要进程B的线程1执行某些动作的一个点</strong>。此时，线程2进入阻塞态，而线程1从就绪态转换到运行态。进程自身保留在运行态</li>
</ul>
<p>在前两种情况中，当内核把控制切换回进程B时，线程2会恢复执行</p>
<p>还需注意，<strong>进程在执行线程库中的代码时可以被中断</strong>，或者是由于它的时间片用完了，或者是由于被一个更高优先级的进程所抢占。因此在中断时，进程可能处于线程切换的中间时刻。当该进程被恢复时，线程库得以继续运行，并完成线程切换和把控制转移给另一个线程</p>
<p><strong>用户级线程的优点</strong></p>
<ol>
<li>由于所有线程管理数据结构都在一个进程的用户地址空间中，线程切换不需要内核态特权，节省了两次状态转换的开销</li>
<li>调度可以是应用程序相关的（一个应用程序可能更适合简单的轮转调度，另一个可能更适合基于优先级的调度），可以为应用量身定做调度算法而不扰乱底层操作系统调度程序</li>
<li>可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程</li>
</ol>
<p><strong>用户级线程的缺点</strong></p>
<ol>
<li>当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞</li>
<li>一个多线程应用程序不能利用多处理技术。内核一次只把一个进程分配给一个处理器，因此一次进程中只有一个线程可以执行（事实上，在一个进程内，相当于实现了应用程序级别的多道程序）</li>
</ol>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核能意识到线程的存在</p>
<p><strong>内核级线程的优点</strong></p>
<ol>
<li>内核可以同时把同一进程中的多个线程调度到多个处理器中同时运行</li>
<li>如果进程中一个线程被阻塞，内核可以调度其它线程</li>
<li>内核例程自身也可以使用多线程</li>
</ol>
<p><strong>内核级线程的缺点</strong></p>
<ol>
<li>把控制从一个线程转移到用一进程的另一线程时，需要到内核的状态切换</li>
</ol>
<h3 id="混合方案"><a href="#混合方案" class="headerlink" title="混合方案"></a>混合方案</h3><p>可以混合使用用户级和内核级线程。在混合方案中，同一应用程序中的多个线程可以在多个处理器上并行地运行，某个会引起阻塞的系统调用不会阻塞整个进程</p>
<p>如果设计正确，该方法将会结合纯粹用户级线程和内核级线程方法的优点，同时克服它们的缺点</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/posts/b7747429.html</url>
    <content><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p><strong>语法</strong>：<code>struct 结构体名&#123;结构体成员列表&#125;;</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构提名 变量名 = {成员值1, 成员值2, …}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="lang-cpp">//结构体定义
struct student&#123;
    //成员列表
    string name;  //姓名
    int age;      //年龄
    int score;    //分数
&#125;stu3; //结构体变量创建方式3 

int main() &#123;

    //结构体变量创建方式1
    struct student stu1; //struct 关键字可以省略

    stu1.name = &quot;张三&quot;;
    stu1.age = 18;
    stu1.score = 100;

    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;

    //结构体变量创建方式2
    struct student stu2 = &#123; &quot;李四&quot;,19,60 &#125;;

    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;

    stu3.name = &quot;王五&quot;;
    stu3.age = 18;
    stu3.score = 80;


    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结1：定义结构体时的关键字时struct，不可省略</p>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
<p>总结3：结构体便俩个利用操作符 “.” 访问成员</p>
</blockquote>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p><strong>作用</strong>：将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法</strong>：<code>struct 结构体名 数组名[元素个数] = &#123; &#123;&#125;, &#123;&#125;, ..., &#123;&#125;&#125;</code></p>
<p><strong>示例</strong></p>
<pre><code class="lang-cpp">//结构体定义
struct student&#123;
    //成员列表
    string name;  //姓名
    int age;      //年龄
    int score;    //分数
&#125;

int main() &#123;

    //结构体数组
    struct student arr[3]=
    &#123;
        &#123;&quot;张三&quot;,18,80 &#125;,
        &#123;&quot;李四&quot;,19,60 &#125;,
        &#123;&quot;王五&quot;,20,70 &#125;
    &#125;;

    for (int i = 0; i &lt; 3; i++)    &#123;
        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p><strong>作用</strong>：通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符<code>-&gt;</code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//结构体定义
struct student&#123;
    //成员列表
    string name;  //姓名
    int age;      //年龄
    int score;    //分数
&#125;;

int main() &#123;

    struct student stu = &#123; &quot;张三&quot;,18,100, &#125;;

    struct student * p = &amp;stu;

    p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员

    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符来访问结构体中的成员</p>
</blockquote>
<h2 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h2><p><strong>作用</strong>：结构体中的成员可以时另一个结构体</p>
<p><strong>例如</strong>：每一个老师辅导一个学生，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//学生结构体定义
struct student&#123;
    //成员列表
    string name;  //姓名
    int age;      //年龄
    int score;    //分数
&#125;;

//教师结构体定义
struct teacher&#123;
    //成员列表
    int id; //职工编号
    string name;  //教师姓名
    int age;   //教师年龄
    struct student stu; //子结构体 学生
&#125;;

int main() &#123;

    struct teacher t1;
    t1.id = 10000;
    t1.name = &quot;老王&quot;;
    t1.age = 40;

    t1.stu.name = &quot;张三&quot;;
    t1.stu.age = 18;
    t1.stu.score = 100;

    cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;

    cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
</blockquote>
<h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h2><p><strong>作用</strong>：将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//学生结构体定义
struct student&#123;
    //成员列表
    string name;  //姓名
    int age;      //年龄
    int score;    //分数
&#125;;

//值传递
void printStudent(student stu )
&#123;
    stu.age = 28;
    cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;
&#125;

//地址传递
void printStudent2(student *stu)
&#123;
    stu-&gt;age = 28;
    cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;
&#125;

int main() &#123;

    student stu = &#123; &quot;张三&quot;,18,100&#125;;
    //值传递
    printStudent(stu);
    cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

    cout &lt;&lt; endl;

    //地址传递
    printStudent2(&amp;stu);
    cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h2 id="结构体中-const使用场景"><a href="#结构体中-const使用场景" class="headerlink" title="结构体中 const使用场景"></a>结构体中 const使用场景</h2><p><strong>作用</strong>：用const来防止误操作</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//学生结构体定义
struct student&#123;
    //成员列表
    string name;  //姓名
    int age;      //年龄
    int score;    //分数
&#125;;

//const使用场景
void printStudent(const student *stu) &#123;//加const防止函数体中的误操作
    //stu-&gt;age = 100; //操作失败，因为加了const修饰
    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;

&#125;

int main() &#123;

    student stu = &#123; &quot;张三&quot;,18,100 &#125;;

    printStudent(&amp;stu);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++基础</category>
      </categories>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/posts/2bf420ab.html</url>
    <content><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h2 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h2><p><strong>作用</strong>：实现两个自定义数据类型相加的运算</p>
<pre><code class="lang-cpp">class Person &#123;
public:
    Person() &#123;&#125;;
    Person(int a, int b)
    &#123;
        this-&gt;m_A = a;
        this-&gt;m_B = b;
    &#125;
    //成员函数实现 + 号运算符重载
    Person operator+(const Person&amp; p) &#123;
        Person temp;
        temp.m_A = this-&gt;m_A + p.m_A;
        temp.m_B = this-&gt;m_B + p.m_B;
        return temp;
    &#125;

public:
    int m_A;
    int m_B;
&#125;;

//全局函数实现 + 号运算符重载
//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;
//    Person temp(0, 0);
//    temp.m_A = p1.m_A + p2.m_A;
//    temp.m_B = p1.m_B + p2.m_B;
//    return temp;
//&#125;

//运算符重载 可以发生函数重载 
Person operator+(const Person&amp; p2, int val)  
&#123;
    Person temp;
    temp.m_A = p2.m_A + val;
    temp.m_B = p2.m_B + val;
    return temp;
&#125;

void test() &#123;

    Person p1(10, 10);
    Person p2(20, 20);

    //成员函数方式
    Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;

    Person p4 = p3 + 10; //相当于 operator+(p3,10)
    cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;

&#125;

int main() &#123;

    test();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329152831.png" alt=""></p>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的运算符是不可能改变的</p>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h2 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h2><p>作用：可以输出自定义数据类型</p>
<pre><code class="lang-cpp">class Person &#123;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);

public:
    Person(int a, int b)    &#123;
        this-&gt;m_A = a;
        this-&gt;m_B = b;
    &#125;

    //成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果
    //void operator&lt;&lt;(Person&amp; p)&#123;
    //&#125;

private:
    int m_A;
    int m_B;
&#125;;

//全局函数实现左移重载
//ostream对象只能有一个
ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;
    out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;
    return out;
&#125;

void test() &#123;
    Person p1(10, 20);
    cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程
&#125;

int main() &#123;

    test();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329152911.png" alt=""></p>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h2 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a><strong>递增运算符重载</strong></h2><p><strong>作用</strong>：通过重载递增运算符，实现自己的整型数据</p>
<pre><code class="lang-cpp">class MyInteger &#123;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);

public:
    MyInteger() &#123;
        m_Num = 0;
    &#125;
    //前置++
    MyInteger&amp; operator++() &#123;
        //先++
        m_Num++;
        //再返回
        return *this;
    &#125;

    //后置++
    MyInteger operator++(int) &#123;
        //先返回
        MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
        m_Num++;
        return temp;
    &#125;

private:
    int m_Num;
&#125;;

ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;
    out &lt;&lt; myint.m_Num;
    return out;
&#125;

//前置++ 先++ 再返回
void test01() &#123;
    MyInteger myInt;
    cout &lt;&lt; ++myInt &lt;&lt; endl;
    cout &lt;&lt; myInt &lt;&lt; endl;
&#125;

//后置++ 先返回 再++
void test02() &#123;

    MyInteger myInt;
    cout &lt;&lt; myInt++ &lt;&lt; endl;
    cout &lt;&lt; myInt &lt;&lt; endl;
&#125;

int main() &#123;

    test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153116.png" alt=""></p>
<blockquote>
<p>总结：前置递增返回引用，后置递增返回值</p>
</blockquote>
<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>C++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数，对属性值进行值拷贝</li>
<li>赋值运算符 operator=， 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现浅拷贝问题</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person&#123;
public:

    Person(int age)    &#123;
        //将年龄数据开辟到堆区
        m_Age = new int(age);
    &#125;

    //重载赋值运算符 
    Person&amp; operator=(Person &amp;p)    &#123;
        if (m_Age != NULL)        &#123;
            delete m_Age;
            m_Age = NULL;
        &#125;
        //编译器提供的代码是浅拷贝
        //m_Age = p.m_Age;

        //提供深拷贝 解决浅拷贝的问题
        m_Age = new int(*p.m_Age);

        //返回自身
        return *this;
    &#125;

    ~Person()    &#123;
        if (m_Age != NULL)        &#123;
            delete m_Age;
            m_Age = NULL;
        &#125;
    &#125;

    //年龄的指针
    int *m_Age;

&#125;;

void test01()&#123;
    Person p1(18);

    Person p2(20);

    Person p3(30);

    p3 = p2 = p1; //赋值操作

    cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;

    cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;

    cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    //int a = 10;
    //int b = 20;
    //int c = 30;

    //c = b = a;
    //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    //cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
    //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153220.png" alt=""></p>
<h2 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h2><p><strong>作用</strong>：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person&#123;
public:
    Person(string name, int age)    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;;

    bool operator==(Person &amp; p)    &#123;
        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)        &#123;
            return true;
        &#125;else&#123;
            return false;
        &#125;
    &#125;

    bool operator!=(Person &amp; p)    &#123;
        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;
            return false;
        &#125;    else    &#123;
            return true;
        &#125;
    &#125;

    string m_Name;
    int m_Age;
&#125;;

void test01()&#123;
    //int a = 0;
    //int b = 0;

    Person a(&quot;孙悟空&quot;, 18);
    Person b(&quot;孙悟空&quot;, 18);

    if (a == b)    &#123;
        cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
    &#125;    else    &#123;
        cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
    &#125;

    if (a != b)    &#123;
        cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
    &#125;    else    &#123;
        cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153320.png" alt=""></p>
<h2 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h2><ul>
<li>函数调用运算符()也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class MyPrint&#123;
public:
    void operator()(string text)    &#123;
        cout &lt;&lt; text &lt;&lt; endl;
    &#125;

&#125;;
void test01()&#123;
    //重载的（）操作符 也称为仿函数
    MyPrint myFunc;
    myFunc(&quot;hello world&quot;);
&#125;

class MyAdd&#123;
public:
    int operator()(int v1, int v2)    &#123;
        return v1 + v2;
    &#125;
&#125;;

void test02()&#123;
    MyAdd add;
    int ret = add(10, 10);
    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;

    //匿名对象调用  
    cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;
&#125;

int main() &#123;

    test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153358.png" alt=""></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>计算机系统概述</title>
    <url>/posts/47ad01c5.html</url>
    <content><![CDATA[<h2 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h2><p>计算机的四个主要组件</p>
<ul>
<li>处理器：也称为中央处理器(Central Processing Unit, 简称CPU)，是计算机系统中的一个核心组件，它是一种能够执行计算机指令的硬件设备</li>
<li>内存：用于存储数据和程序的硬件设备，是计算机系统中的一种临时存储介质，用于暂时存放正在执行的程序和数据，以供处理器快速访问</li>
<li>I/O模块：是计算机系统中用于处理输入和输出设备的硬件模块，负责处理计算机系统与外部设备之间的数据传输和交互</li>
<li>系统总线：是计算机系统中用于连接主要组件的集线器，它扮演着数据和信号传输的通道角色</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230516203050.png" alt="Img"></p>
<h2 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a>指令的执行</h2><p>基本指令周期，指令处理包括2步：</p>
<ul>
<li>处理器从存储器一次读一条指令</li>
<li>执行每条指令</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230516204104.png" alt="Img"></p>
<p>处理器中的PC保存下一条指令的地址，IR保存当前即将执行的指令。</p>
<p>PC：程序计数器（Program Conter），也称为指令指针或指令计数器。PC是处理器（CPU）中的一个寄存器，用于存储下一条将要执行的指令的内存地址。在执行程序时，处理器根据PC中存储的地址来获取下一条指令，并将PC的值增加以指向下一条指令的地址，从而实现顺序执行。</p>
<p>IR：指令寄存器（Instruction Register），也称为指令缓冲寄存器或指令译码器。IR时处理器中的一个寄存器，用于存储当前正在执行的指令。当处理器从内存中读取指令并准备执行时，指令会被加载到IR中，供处理器进行解码和执行。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>允许“其它模块”（I/O、存储器）中断“处理器”正常处理过程的机制</strong></p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>提高CPU利用率，防止一个程序垄断CPU资源</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li>程序中断：是操作系统中的一种机制，用于在程序执行过程中暂停当前的指令流，并转而执行一个特定的中断处理程序。</li>
<li>时钟中断：是指由计时器或时钟设备触发的一种中断</li>
<li>I/O中断：是操作系统中的一种中断类型，用于处理外部设备产生的事件和请求</li>
<li>硬件失效中断：指由于硬件故障或错误导致的计算机系统中断。当计算机系统中的硬件设备出现故障或错误时，它可能无法继续正常工作，这时系统会产生硬件失效中断信号，通知操作系统或其他软件程序中断正在进行的处理并采取相应的措施。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230516204925.png" alt="Img"></p>
<h3 id="中断控制流"><a href="#中断控制流" class="headerlink" title="中断控制流"></a>中断控制流</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230516210016.png" alt="Img"></p>
<p>I/O程序：</p>
<ul>
<li>指令序号4：为实际I/O做准备</li>
<li>I/O命令：如果不使用中断，执行命令时，程序必须等待I/O设备执行请求的函数（或周期性地检测I/O设备的状态或轮询I/O设备）。程序可能通过简单地重复执行一个测试操作的方式进行等待，以确定I/O操作是否完成</li>
<li>指令序号5：操作完成，包括设置成功或失败标签</li>
</ul>
<p>中断：短I/O等待</p>
<ul>
<li>利用中断功能，处理器可以在I/O操作的执行过程中执行其它指令：用户程序到达系统调用WRITE处，但涉及的I/O程序仅包括准备代码和真正的I/O命令。在这些为数不多的几条指令执行后，控制返回到用户程序。在这期间，外部设备忙于从计算机存储器接收数据并打印。这种I/O操作和用户程序中指令的执行是并发的</li>
<li>当外部设备做好服务的准备时，也就是说，当它准备好从处理器接收更多的数据时，该外部设备的I/O模块给处理器发送一个中断请求信号。这是处理器会做出响应，暂停当前程序的处理，转去处理服务于特定I/O设备的程序，这个程序称为中断处理程序。在对该设备的服务响应完成后，处理器恢复原先的执行</li>
</ul>
<p>中断：长I/O等待</p>
<ul>
<li>对于如打印机等较慢的设备来说，I/O操作比执行一系列用户指令的时间长得多，因此在下一次I/O操作时，前一次I/O可能还未执行完。在上图c中，第二次WRITE调用时，第一次WRITE的I/O还未执行完，结果是用户程序会在这挂起，当前面I/O完成后，才能继续新的WRITE调用</li>
</ul>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>中断激活了很多事件，包括处理器硬件中的事件以及软件中的事件</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230516211026.png" alt="Img"></p>
<p>被中断程序的信息保存与恢复：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230517234021.png" alt="Img"></p>
<h3 id="多个中断"><a href="#多个中断" class="headerlink" title="多个中断"></a>多个中断</h3><p>在处理一个中断的过程中，可能会发生另一个中断，处理多个中断有2种方法</p>
<pre><code>- **当正在处理一个中断时，禁止再发生中断**：如果有新的中断请求信号，处理器不予理睬。通常在处理中断期间发生的中断被挂起，当处理器再次允许中断时再处理
- **定义中断优先级**：允许高优先级的中断处理打断低优先级的中断处理程序的允许
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230517234241.png" alt="Img"></p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230517234331.png" alt="Img"></p>
<p>从上往下看，会出现以下情况：</p>
<pre><code>- 每“位”的价格递减
- 容量递增
- 存取时间递增
- 处理器访问存储器的频率笛剑（有效的基础是访问的局部性原理）
</code></pre><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>内存的存储周期跟不上处理器周期，因此，利用局部性原理在处理器和内存间提供一个容量小而速度快的存储器，称为高速缓存</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230517234533.png" alt="Img"></p>
<p>上图中高速缓存通常分为多级：L1、L2、L3</p>
<h2 id="直接内存存取（DMA）"><a href="#直接内存存取（DMA）" class="headerlink" title="直接内存存取（DMA）"></a>直接内存存取（DMA）</h2><p>针对I/O操作有3种可能的技术</p>
<ul>
<li>可编程（控制程序）I/O（需处理器干预）</li>
<li>中断驱动I/O（需处理器干预）</li>
<li>直接内存存取</li>
</ul>
<p>当处理器正在执行程序并遇到一个I/O相关的指令时，它通过给相应的I/O模块发命令来执行这个指令：</p>
<ol>
<li>使用可编程I/O时，I/O模块执行请求的动作并设置I/O状态寄存器中相应的位，<strong>但它并不进一步通知处理器，尤其是它并不中断处理器</strong>，因此处理器在执行I/O指令后，还需定期检查I/O模块的状态。为了确定I/O模块是否做好了接收或发送更多数据的准备，处理器等待期间必须不断询问I/O模块的状态，这会严重降低整个系统的性能</li>
<li><p>如果是中断驱动I/O，在给I/O模块发送I/O命令后，处理器可以继续做其它事。当I/O模块准备好与处理器交换数据时，会中断处理器并请求服务，处理器接着响应中断，完成后再恢复以前的执行过程。</p>
<p> 尽管中断驱动I/O比可编程I/O更有效，但是<strong>处理器仍需要主动干预在存储器和I/O模块直接的数据传输，并且任何数据传送都必须完全通过处理器</strong>。由于需要处理器干预，这两种I/O存在下列缺陷：</p>
<ul>
<li>I/O传送速度受限于处理器测试设备和提供服务的速度（数据传送受限于处理器）</li>
<li>处理器忙于管理I/O传送工作，必须执行很多指令以完成I/O传送（处理器为数据传送需要做很多事）</li>
</ul>
</li>
<li><p>因此，当需要移动大量数据时，需要使用一种更有效的技术：直接内存存取。DMA功能可以由系统总线种一个独立的模块完成，也可以并入到一个I/O模块中。</p>
</li>
</ol>
<p>DMA的工作方式如下，当处理器需要读写一块数据时，它给DMA模块产生一条命令，发送下列信息：</p>
<ul>
<li>是否请求一次读或写</li>
<li>涉及的I/O设备的地址</li>
<li>开始读或写的存储单元</li>
<li>需要读或写的子树</li>
</ul>
<p>之后处理器继续其它工作。处理器将这个操作委托给DMA模块，DMA模块直接与存储器交换，这个操作过程不需要处理器参与。当传送完成后，DMA模块发送一个中断信号给处理器。因此只有在开始和结束时，处理器才会参与</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518000544.png" alt="Img"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>进程</title>
    <url>/posts/31a6b40.html</url>
    <content><![CDATA[<h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>进程有以下定义：</p>
<ul>
<li>一个正在执行中的程序</li>
<li>一个正在计算机上执行的程序实例</li>
<li>能分配给处理器并由处理器执行的实体</li>
<li>一个具有以下特征的活动单元：一组指令序列的执行、一个当前状态和相关的系统资源集</li>
</ul>
<p>也可以把进程视为由<strong>程序代码、和代码相关联的数据集、进程控制块</strong>组成的实体</p>
<p><strong>进程控制块</strong>：由操作系统创建和管理。进程控制块包含了充分的信息，这样就可以中断一个进程的执行，并且在后来恢复执行进程时就好像进程未被中断过一样。进程控制块是操作系统能够支持多进程和提供多重处理技术的关键，<strong>进程控制块是操作系统中最重要的数据结构，每个进程控制块包含操作系统所需要的关于进程的所有信息</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518095136.png" alt="Img"></p>
<ul>
<li>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享内存块的指针</li>
<li>上下文数据：进程执行时处理器寄存器中的数据</li>
</ul>
<p>进程被中断时，操作系统会把程序计数器和上下文数据保存到进程控制块中的相应位置</p>
<p><strong>程序状态字(PSW)</strong>：所有处理器设计都包括一个或一组通常称为程序状态字的寄存器，包含有进程的状态信息</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p>进程按以下步骤创建：</p>
<ol>
<li>给新进程分配一个唯一的进程标识符</li>
<li>给新进程分配空间（包括进程映像中的所有元素）</li>
<li>初始化进程控制块</li>
<li>设置正确的连接（保存到相应队列）</li>
</ol>
<p>会导致创建进程的事件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518095357.png" alt="Img"></p>
<p>会导致终止进程的事件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518095443.png" alt="Img"></p>
<h3 id="两状态模型"><a href="#两状态模型" class="headerlink" title="两状态模型"></a>两状态模型</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518095520.png" alt="Img"></p>
<h3 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a>五状态模型</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518095551.png" alt="Img"></p>
<p><strong>运行态-&gt;就绪态</strong>：<br>1）超时：即正在运行的进程到达了”允许不中断执行“的最大时间段（所有多道程序操作系统都实现了这类时间限定）<br>2）优先级低的进程被优先级高进程抢占（并不是所有操作系统都实现了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518095646.png" alt="Img"></p>
<p>图b)中一个事件对应一个队列。当事件发生时，相应队列中的所有进程都转换到就绪态</p>
<p>除此之外，就绪队列也可以按照优先级组织成多个队列</p>
<h3 id="引入”挂起态“的进程模型"><a href="#引入”挂起态“的进程模型" class="headerlink" title="引入”挂起态“的进程模型"></a>引入”挂起态“的进程模型</h3><p><strong>为何引入？</strong></p>
<p>考虑一个没有使用虚拟内存的系统，每个被执行的进程必须完全载入内存，因此，2.3图b)中，所有队列中的所有进程必须驻留在内存中</p>
<p>所有这些设计机制的原因都是由于I/O活动比计算速度慢得多，因此在单道程序系统中的处理器大多数时候是空闲的。但是2.3图b)的方案并未完全解决这个问题。在这种情况下，内存保存有多个进程，当一个进程正在等待时，处理器可以转移到另一个进程，但是处理器比I/O要快的多，以至于内存中所有的进程都在等待I/O的情况很常见。因此，即使是多道程序设计，大多数时候处理器仍然处于空闲</p>
<p>因此，<strong>可以把内存中某个进程的一部分或全部移出到磁盘中</strong>。当内存中没有处于就绪状态的进程时，操作系统就把被阻塞的进程换出到磁盘中的”挂起队列“。操作系统在此之后取出挂起队列中的另一个进程，或者接受一个新进程的请求，将其纳入内存运行</p>
<p>“交换”是一个I/O操作，因而也可能使问题更加恶化。但是由于磁盘I/O一般是系统中最快的I/O(相对于磁带或打印机I/O)，所以交换通常会提高性能</p>
<p><strong>进程模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518100141.png" alt="Img"></p>
<ul>
<li><strong>就绪/挂起-&gt;就绪</strong>：1）内存中没有就绪态进程，需要调入一个进程继续执行；2）处于就绪/挂起的进程具有更高优先级</li>
<li><strong>就绪-&gt;就绪/挂起</strong>：1）如果释放空间以得到足够空间的唯一方法是挂起一个就绪态的进程；2）如果操作系统确信高优先级的阻塞态进程很快将会就绪，那么可能会挂起一个低优先级的就绪态进程而不是一个高优先级的阻塞态进程</li>
<li><strong>新建-&gt;就绪/挂起</strong>：进程创建需要为其分配内存空间，如果内存中没有足够的空间分配给新进程，会使用”新建-&gt;就绪/挂起“转换</li>
<li><strong>阻塞/挂起-&gt;阻塞</strong>：比较少见。如果一个进程终止，释放了一些内存空间，阻塞/挂起队列中有一个进程比就绪/挂起队列中任何进程的优先级都要高，并且操作系统有理由相信阻塞进程的事件很快就会发生</li>
<li><strong>运行-&gt;就绪/挂起</strong>：如果位于阻塞/挂起队列中的具有较高优先级的进程变得不再阻塞，操作系统抢占这个进程，也可以直接把这个进程转换到就绪/挂起队列中，并释放一些内存</li>
</ul>
<p><strong>导致进程挂起的原因</strong><br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518100434.png" alt="Img"></p>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>操作系统为了管理进程和资源，必须掌握关于每个进程和资源当前状态的信息。普遍使用的方法是：操作系统构造并维护它所管理的每个实体的信息表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518100702.png" alt="Img"></p>
<p>内存表用于跟踪内(实)存和外存(虚拟内存)</p>
<p>使用<strong>进程映像</strong>来描述一个进程，进程镜像包括：<strong>程序、数据、栈和进程控制块(属性的集合)：</strong><br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518100753.png" alt="Img"></p>
<p>下图为一个典型的<strong>进程映像</strong>结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518100813.png" alt="Img"></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a>执行模式</h3><p>大多数处理器至少支持两种执行模式：</p>
<ul>
<li><strong>用户态</strong></li>
<li><strong>内核态(系统态、控制态)</strong>：软件具有对处理器及所有指令、寄存器和内存的控制能力</li>
</ul>
<p>使用两种模式的原因是很显然的，它可以保护操作系统和重要的操作系统表(如进程控制块)不受用户程序的干涉</p>
<p><strong>处理器如何知道它正在什么模式下执行及如何改变模式？</strong></p>
<p>程序状态字(PSW)中有一位表示执行模式，这一位应某些事件的要求而改变。在典型情况下</p>
<ul>
<li>当用户调用一个操作系统服务或中断触发系统例程的执行时，执行模式被设置为内核态</li>
<li>当从系统服务返回到用户进程时，执行模式被设为用户态</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>在下列事件中，进程可能把控制权交给操作系统：<br><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230518101105.png" alt="Img"></p>
<ul>
<li><strong>系统中断</strong><ul>
<li><strong>中断</strong>：与当前正在运行的进程无关的某种类型的外部事件相关。控制首先转移给中断处理器，做一些基本的辅助工作后，转到与已经发生的特定类型的中断相关的操作系统例程</li>
<li><strong>陷阱</strong>：与当前正在运行的进程所产生的错误或异常条件相关。操作系统首先确定错误或异常条件是否是致命的。1）如果是，当前进程被换到退出态，发生进程转换；2）如果不是，动作取决于错误的种类或操作系统的设计，可能会进行一次进程切换或者继续执行当前进程</li>
</ul>
</li>
<li><strong>系统调用</strong>：转移到作为操作系统代码一部分的一个例程上执行。通常，使用系统调用会把用户进程置为阻塞态</li>
</ul>
<p>进程切换步骤如下：</p>
<ol>
<li>保存处理器上下文环境（包括程序计数器和其它寄存器）</li>
<li>更新当前处于运行态进程的进程控制块（状态和其它信息）</li>
<li>将进程控制块移到相应队列</li>
<li>选择另一个进程执行</li>
<li>更新所选择进程的进程控制块（包括将状态变为运行态）</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器在被选择的进程最近一次切换出运行状态时的上下文环境</li>
</ol>
<blockquote>
<p><strong>进程切换一定有模式切换；模式切换不一定有进程切换</strong>（中断会发生模式切换，但是在大多数操作系统中，中断的发生并不是必须伴随着进程的切换的。可能是中断处理器执行之后，当前正在运行的程序继续执行）；</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/posts/f79e4123.html</url>
    <content><![CDATA[<p>一个进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但是程序员或用户感觉到的是一个更大的内存，通常它被分配在磁盘上，称为虚拟内存，简称虚存</p>
<p><strong>虚存使得程序不必完全载入内存才能运行</strong>，每次可以只有部分驻留在内存中。如果处理器访问一个不在内存中的逻辑地址，则产生一个中断，说明产生了内存访问故障。操作系统把被中断的进程置于阻塞态。为了能继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块读入内存。为此，操作系统产生一个磁盘I/O读请求。在此期间，可以调度另一个进程运行。一旦需要的块被读入内存，则产生一个I/O中断，操作系统把由于缺少该块而被阻塞的进程置为就绪态</p>
<p><strong>不必将程序完全载入即可运行使得程序可以比实际内存更大</strong></p>
<p><strong>系统抖动</strong>：如果一个块正好在将要被用到之前换出，操作系统就不得不很快把它取回来。太多这类操作会导致一种称为系统抖动的情况，处理器大部分时间都用于交换块，而不是执行指令</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><ul>
<li>每个进程都有自己的页表</li>
<li>由于进程某些页可能不在内存中，所以页表项中有一位表示该页是否在内存中</li>
<li>页表项有一位表示该页(从上次载入)是否已经被修改</li>
<li>页表的长度可以基于进程的长度而变化，因此不能在寄存器中保存它（对于占据大量虚存空间的程序，其页表很大，因此页表通常保存在虚存中，因此页表也服从分页管理）</li>
<li>一个程序正在运行时，页表至少有一部分必须在内存中</li>
</ul>
<h3 id="一级分页系统中的地址转换"><a href="#一级分页系统中的地址转换" class="headerlink" title="一级分页系统中的地址转换"></a>一级分页系统中的地址转换</h3><p>一级分页系统中的虚拟地址和页表项：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102250.png" alt="Img"></p>
<p>地址转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102308.png" alt="Img"></p>
<h3 id="两级分页系统中的地址转换"><a href="#两级分页系统中的地址转换" class="headerlink" title="两级分页系统中的地址转换"></a>两级分页系统中的地址转换</h3><p>两级页表结构（假设页大小为4KB，每个页表项大小为4B）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102410.png" alt="Img"></p>
<p>地址转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102429.png" alt="Img"></p>
<h3 id="倒排页表"><a href="#倒排页表" class="headerlink" title="倒排页表"></a>倒排页表</h3><p>一级和两级分页系统中的页表存在一个缺陷：页表的大小与虚拟地址空间的大小成正比</p>
<p>一种替代方法是使用一个倒排页表，其机构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102505.png" alt="Img"></p>
<p>页表结构之所以称为”倒排“，是因为它使用页框号而非虚拟页号来索引页表项</p>
<h3 id="转换检测缓冲区-TLB"><a href="#转换检测缓冲区-TLB" class="headerlink" title="转换检测缓冲区(TLB)"></a>转换检测缓冲区(TLB)</h3><p>原则上，每次虚拟内存访问可能引起两次物理内存访问：一次取相应的页表项，一次取需要的数据。因此，简单的虚拟内存方案会导致内存访问时间加倍</p>
<p>TLB保存在高速缓冲存储器中，它记录了最近用到过的页表项。给定一个虚拟地址，处理器首先检查TLB：</p>
<ul>
<li>如果需要的页表项在其中，则检索页框号并形成实地址</li>
<li>如果未找到需要的页表项，则处理器用页号检索进程页表，并检查相应的页表项。<ul>
<li>如果”存在位“置位，则页在内存中，处理器从页表项中检索页框号形成实地址。并更新TLB</li>
<li>如果”存在位”没置位，表示需要的页不在内存中，这时发生缺页中断，因此离开硬件作用范围，调用操作系统，操作系统负责载入所需要的页，并更新页表</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102723.png" alt="Img"></p>
<p>虚拟机制必须与高速缓存系统进行交互，一个虚拟地址通常为页号、偏移量的形式。首先，内存系统查看TLB中是否存在匹配的页表项，如果存在，通过把页框号和偏移量组合起来产生实际地址（物理地址）；如果不存在，则从页表中读取页表项。一旦产生了一个由标记和其余部分组成的实地址，则查看高速缓存中是否存在包含这个字的块。如果有，把它返回给CPU；如果没有，从内存中检索这个字</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102738.png" alt="Img"></p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><ul>
<li>每个进程都有一个唯一的段表。</li>
<li>进程可能只有一部分段在内存中，所以段表项中有一位表明相应段是否在内存中</li>
<li>段表项有一位修改位表明相应段从上一次载入起是否被改变</li>
<li>根据进程大小，段表长度可变，而无法在寄存器中保存</li>
</ul>
<h3 id="分段系统中的地址转换"><a href="#分段系统中的地址转换" class="headerlink" title="分段系统中的地址转换"></a>分段系统中的地址转换</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519102915.png" alt="Img"></p>
<h3 id="保护和共享"><a href="#保护和共享" class="headerlink" title="保护和共享"></a>保护和共享</h3><p>分段有助于实现保护与共享机制。由于<strong>每个段表项包括一个长度和一个基地址</strong>，因而程序不会不经意地访问超出该段的内存单元。为实现共享，一个段可能在多个进程的段表中被引用</p>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><ul>
<li>分页对程序员是透明的，它消除了外部碎片，从而可以更有效地使用内存</li>
<li>分段对程序员是可见的，它具有处理不断增长的数据结构的能力以及支持共享和保护的能力</li>
</ul>
<p>分段通常对于程序员可见，并且作为组织程序和数据的一种方便手段提供给程序员。一般情况下，程序员或编译器会把程序和数据指定到不同的段。为了实现模块化程序设计的目的，程序或数据可能进一步分成多个段。这种方法最不方便的地方是程序员必须清楚段的最大长度限制</p>
<p>可以将分页和分段结合，即段页式</p>
<p>在段页式系统中，用户的地址空间被程序员划分成许多段。每个段依次划分成许多固定大小的页，页的长度等于内存中的页框大小。如果某一段的长度小于一页，则该段只占据一页。从程序员角度看，逻辑地址仍然由段号和段偏移量组成；从系统角度看，段偏移量可视为指定段中的一个页号和页偏移量</p>
<h3 id="段页式系统中的地址转换"><a href="#段页式系统中的地址转换" class="headerlink" title="段页式系统中的地址转换"></a>段页式系统中的地址转换</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519103149.png" alt="Img"></p>
<h2 id="内存管理中的相关策略"><a href="#内存管理中的相关策略" class="headerlink" title="内存管理中的相关策略"></a>内存管理中的相关策略</h2><p>操作系统的内存管理设计取决于三个基本方面的选择：</p>
<ol>
<li>是否使用虚存技术</li>
<li>是使用分页还是使用分段，或者是二者组合</li>
<li><strong>为各种存储管理特征采用的算法</strong></li>
</ol>
<h3 id="读取策略"><a href="#读取策略" class="headerlink" title="读取策略"></a>读取策略</h3><p>读取策略确定一个页何时取入内存</p>
<ul>
<li><strong>请求分页</strong>：只有当访问到某页中的一个单元时才将该页取入内存</li>
<li><strong>预先分页</strong>：读取的页并不是缺页中断请求的页，如果一个进程的页被连续存储在辅存中，则一次读取许多连续的页</li>
</ul>
<h3 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h3><p>放置策略决定一个进程块驻留在实存中的什么地方</p>
<ul>
<li>在一个纯粹的分段系统中，放置策略并不是重要的设计问题（诸如最佳适配、首次适配等都可供选择）</li>
<li>对于纯粹的分页系统或段页式系统，如何放置通常没有关系，因为地址转换硬件和内存访问硬件可以以相同的效率为任何页框组合执行它们的功能</li>
</ul>
<h3 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h3><p>置换策略决定在必须读取一个新页时，应该置换内存中的哪一页</p>
<p><strong>页框锁定</strong>：如果一个页框被锁定，当前保存在该页框中的页就不能被置换。大部分操作系统内核和重要的控制结构就保存在锁定的页框中。此外，I/O缓存区和其它对时间要求严格的区域也可能锁定在内存的页框中</p>
<p><strong>基本置换算法</strong></p>
<ul>
<li><strong>最佳(OPT)</strong>：置换下次访问距当前时间最长的那些页，该算法能导致最少的缺页中断（由于要求操作系统必须知道将来的事件，因此不可能实现，而是作为一种标准来衡量其它算法的性能）</li>
<li><strong>最近最少使用(LRU)</strong>：置换内存中上次使用距当前最远的页，LRU性能接近于OPT，但是难以实现（一种方法是为每一页添加一个最后一次访问的时间戳，但是开销较大</li>
<li><strong>先进先出(FIFO)</strong>：把分配给进程的页框视为一个循环缓冲区，按循环的方式移动页。实现简单，但性能较差（隐含的逻辑是置换驻留在内存中时间最长的页，经常会出现部分程序或数据在整个程序的生命周期中使用频率都很高的情况，如果使用FIFO这些页会需要反复地被换入换出）。FIFO还会产生当所分配的物理块数增大而页故障不减反增的异常现象，称为Belady异常</li>
<li><strong>时钟(CLOCK)</strong>：时钟策略是试图以较小的开销接近LRU性能的一种算法，最简单的时钟策略需要给每一页关联一个附加位，称为使用位。当某一页首次装入内存中时，该页的使用位设置为1；当该页随后被访问到时，它的使用位也会被置为1。当需要置换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一个页框。每当遇到一个使用位为1的页框时，就将该位重新置为0（<strong>只有寻找置换页和发生置换时，指针会移动。如果当前需要访问的页在内存中，即使不是当前指针指向的页，也只是将被访问的页置为1，而不发送指针移动，如下图右下角CLOCK策略中最后一次访问2</strong>）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519103530.png" alt="Img"></p>
<h3 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h3><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读入内存。因此，操作系统必须决定读取多少页，即给特定的进程分配多大的内存空间。需要考虑以下几个因素：</p>
<ul>
<li>分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多（这就增加了操作系统至少找到一个就绪进程的可能）</li>
<li>如果一个进程在内存中的页数比较少，尽管有局部性原理，缺页率仍然相对较高</li>
<li>如果分配过多页，由于局部性原理，该进程的缺页率没有明显的变化</li>
</ul>
<p>基于上述因素，通常采用两种策略：</p>
<ol>
<li><strong>固定分配策略</strong>：为一个进程在内存中分配固定数目的页框用于执行时使用，这个数目在最初加载时（创建进程时）决定（可以根据进程类型或程序员的需要确定）。一旦发生缺页中断，进程的一页必须被它所需要的页面置换</li>
<li><strong>可变分配策略</strong>：允许分配给一个进程的页框在进程的生命周期中不断地变化。如果缺页中断多，则多分配一些；缺页中断少，适当减少分配。这种方法的难点在于要求操作系统评估活动进程的行为</li>
</ol>
<p><strong>置换范围</strong></p>
<ul>
<li><strong>局部置换策略</strong>：仅仅在产生缺页的进程的驻留页中选择</li>
<li><strong>全局置换策略</strong>：把内存中所有未被锁定的页都视为置换的候选页，而不管它们属于哪个进程</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/yank-note-picgo-img-20230519103734.png" alt="Img"></p>
<ul>
<li><strong>可变分配、全局范围</strong>：发生缺页时，如果存在空闲页框，则使用空闲页框；否则在全局页框中选择置换</li>
<li><strong>可变分配、局部范围</strong>：不时评估进程的页框分配情况，增加或减少分配给它的页框</li>
</ul>
<h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><p>清除策略与读取策略相反，它用于确定在何时将一个被修改过的页写回辅存，通常有2种选择</p>
<ul>
<li><strong>请求式清除</strong>：只有当一页被选择用于置换时，才被写回辅存（可以减少写页，但意味着发生缺页中断的进程在解除阻塞之前必须等待两次页传送，这可能降低处理器的利用率）</li>
<li><strong>预约试清除</strong>：将被修改的多个页在需要用到它们占据的页框之前成批地写回辅存（并没有太大意义，因为这些页中大部分常常会在置换之前又被修改，辅存传送能力有限，不应该浪费在不太需要的清除操作上）</li>
</ul>
<p>比较好的方法是结合页缓冲技术</p>
<h3 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h3><p>加载控制决定驻留在内存中的进程数目，称为系统并发度</p>
<p>并发度太低会导致处理器利用率不高，并发度太高会发生系统抖动</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象三大特性之一——封装</title>
    <url>/posts/74e9d098.html</url>
    <content><![CDATA[<h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>在设计类的时候，属性和行为写在一起，表现事物</p>
<p>语法：</p>
<p><code>class 类名&#123; 访问权限：属性 / 行为&#125;;</code></p>
<p><strong>示例1</strong>：设计一个圆类，求圆的周长</p>
<p><strong>示例1代码：</strong></p>
<pre><code class="lang-cpp">//圆周率
const double PI = 3.14;

//1、封装的意义
//将属性和行为作为一个整体，用来表现生活中的事物

//封装一个圆类，求圆的周长
//class代表设计一个类，后面跟着的是类名
class Circle&#123;
public:  //访问权限  公共的权限

    //属性
    int m_r;//半径

    //行为
    //获取到圆的周长
    double calculateZC()    &#123;
        //2 * pi  * r
        //获取圆的周长
        return  2 * PI * m_r;
    &#125;
&#125;;

int main() &#123;

    //通过圆类，创建圆的对象
    // c1就是一个具体的圆
    Circle c1;
    c1.m_r = 10; //给圆对象的半径 进行赋值操作

    //2 * pi * 10 = = 62.8
    cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327171156.png" alt=""></p>
<p><strong>示例2</strong>：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码</strong>：</p>
<pre><code class="lang-cpp">//学生类
class Student &#123;
public:
    void setName(string name) &#123;
        m_name = name;
    &#125;
    void setID(int id) &#123;
        m_id = id;
    &#125;

    void showStudent() &#123;
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;
    &#125;
public:
    string m_name;
    int m_id;
&#125;;

int main() &#123;

    Student stu;
    stu.setName(&quot;德玛西亚&quot;);
    stu.setID(250);
    stu.showStudent();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230327171228.png" alt=""></p>
<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public       公共权限</li>
<li>protected    保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">//三种权限
//公共权限  public     类内可以访问  类外可以访问
//保护权限  protected  类内可以访问  类外不可以访问
//私有权限  private    类内可以访问  类外不可以访问

class Person
&#123;
    //姓名  公共权限
public:
    string m_Name;

    //汽车  保护权限
protected:
    string m_Car;

    //银行卡密码  私有权限
private:
    int m_Password;

public:
    void func()
    &#123;
        m_Name = &quot;张三&quot;;
        m_Car = &quot;拖拉机&quot;;
        m_Password = 123456;
    &#125;
&#125;;

int main() &#123;

    Person p;
    p.m_Name = &quot;李四&quot;;
    //p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到
    //p.m_Password = 123; //私有权限类外访问不到

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h2><p>在C++中，struct和class唯一的<strong>区别</strong>就在于<strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为public</li>
<li>class  默认权限为private</li>
</ul>
<pre><code class="lang-cpp">class C1&#123;
    int  m_A; //默认是私有权限
&#125;;

struct C2&#123;
    int m_A;  //默认是公共权限
&#125;;

int main() &#123;

    C1 c1;
    c1.m_A = 10; //错误，访问权限是私有

    C2 c2;
    c2.m_A = 10; //正确，访问权限是公共

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2><p><strong>优点</strong>：</p>
<ol>
<li>将所有成员属性设置为私有，可以自己控制读写权限</li>
<li>对于写权限，我们可以检测数据的有效性</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Person &#123;
public:

    //姓名设置可读可写
    void setName(string name) &#123;
        m_Name = name;
    &#125;
    string getName()    &#123;
        return m_Name;
    &#125;

    //获取年龄 
    int getAge() &#123;
        return m_Age;
    &#125;
    //设置年龄
    void setAge(int age) &#123;
        if (age &lt; 0 || age &gt; 150) &#123;
            cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;
            return;
        &#125;
        m_Age = age;
    &#125;

    //情人设置为只写
    void setLover(string lover) &#123;
        m_Lover = lover;
    &#125;

private:
    string m_Name; //可读可写  姓名

    int m_Age; //只读  年龄

    string m_Lover; //只写  情人
&#125;;

int main() &#123;

    Person p;
    //姓名设置
    p.setName(&quot;张三&quot;);
    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;

    //年龄设置
    p.setAge(50);
    cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;

    //情人设置
    p.setLover(&quot;苍井&quot;);
    //cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象三大特性之一——继承</title>
    <url>/posts/685188f0.html</url>
    <content><![CDATA[<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/jctree.png" alt=""></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h2 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h2><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现</strong>：</p>
<pre><code class="lang-cpp">//Java页面
class Java &#123;
public:
    void header()    &#123;
        cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
    &#125;
    void footer()    &#123;
        cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
    &#125;
    void left()    &#123;
        cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
    &#125;
    void content()    &#123;
        cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;
    &#125;
&#125;;
//Python页面
class Python&#123;
public:
    void header()    &#123;
        cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
    &#125;
    void footer()    &#123;
        cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
    &#125;
    void left()    &#123;
        cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
    &#125;
    void content()    &#123;
        cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;
    &#125;
&#125;;
//C++页面
class CPP &#123;
public:
    void header()    &#123;
        cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
    &#125;
    void footer()    &#123;
        cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
    &#125;
    void left()    &#123;
        cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
    &#125;
    void content()    &#123;
        cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01()&#123;
    //Java页面
    cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;
    Java ja;
    ja.header();
    ja.footer();
    ja.left();
    ja.content();
    cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

    //Python页面
    cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;
    Python py;
    py.header();
    py.footer();
    py.left();
    py.content();
    cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

    //C++页面
    cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;
    CPP cp;
    cp.header();
    cp.footer();
    cp.left();
    cp.content();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>继承实现</strong>：</p>
<pre><code class="lang-cpp">//公共页面
class BasePage&#123;
public:
    void header()    &#123;
        cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;
    &#125;

    void footer()    &#123;
        cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;
    &#125;
    void left()    &#123;
        cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;
    &#125;

&#125;;

//Java页面
class Java : public BasePage&#123;
public:
    void content()    &#123;
        cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;
    &#125;
&#125;;
//Python页面
class Python : public BasePage&#123;
public:
    void content()    &#123;
        cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;
    &#125;
&#125;;
//C++页面
class CPP : public BasePage&#123;
public:
    void content()    &#123;
        cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01()&#123;
    //Java页面
    cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;
    Java ja;
    ja.header();
    ja.footer();
    ja.left();
    ja.content();
    cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

    //Python页面
    cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;
    Python py;
    py.header();
    py.footer();
    py.left();
    py.content();
    cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;

    //C++页面
    cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;
    CPP cp;
    cp.header();
    cp.footer();
    cp.left();
    cp.content();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<blockquote>
<p>总结：继承的好处：可以减少<em>重复的代码</em></p>
</blockquote>
<p>class A: class B;</p>
<p>A类称为子类 或 派生类</p>
<p>B类称为父类 或 基类</p>
<p>派生类中的成员，包含两大部分</p>
<p>一类是从基类继承过来的，一类是自己增加的成员</p>
<p>从基类继承过来的表现其共性，而新增的成员体现了其个性</p>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>继承的语法： <code>class子类: 继承方式 父类</code></p>
<p>继承的方式一共有三种：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/jctable.png" alt=""></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Base1&#123;
public: 
    int m_A;
protected:
    int m_B;
private:
    int m_C;
&#125;;

//公共继承
class Son1 :public Base1&#123;
public:
    void func()    &#123;
        m_A; //可访问 public权限
        m_B; //可访问 protected权限
        //m_C; //不可访问
    &#125;
&#125;;

void myClass()&#123;
    Son1 s1;
    s1.m_A; //其他类只能访问到公共权限
&#125;

//保护继承
class Base2&#123;
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;
&#125;;

class Son2:protected Base2&#123;
public:
    void func()    &#123;
        m_A; //可访问 protected权限
        m_B; //可访问 protected权限
        //m_C; //不可访问
    &#125;
&#125;;

void myClass2()&#123;
    Son2 s;
    //s.m_A; //不可访问
&#125;

//私有继承
class Base3&#123;
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;
&#125;;

class Son3:private Base3&#123;
public:
    void func()    &#123;
        m_A; //可访问 private权限
        m_B; //可访问 private权限
        //m_C; //不可访问
    &#125;
&#125;;

class GrandSon3 :public Son3&#123;
public:
    void func()    &#123;
        //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到
        //m_A;
        //m_B;
        //m_C;
    &#125;
&#125;;
</code></pre>
<h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><p><strong>问题</strong>：从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<pre><code class="lang-cpp">class Base&#123;
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C; //私有成员只是被隐藏了，但是还是会继承下去
&#125;;

//公共继承
class Son :public Base&#123;
public:
    int m_D;
&#125;;

void test01()&#123;
    cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153616.png" alt=""></p>
<h2 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h2><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序谁先谁后</p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Base &#123;
public:
    Base()    &#123;
        cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;
    &#125;
    ~Base()    &#123;
        cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Son : public Base&#123;
public:
    Son()    &#123;
        cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;
    &#125;
    ~Son()    &#123;
        cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01()&#123;
    //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反
    Son s;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153651.png" alt=""></p>
<blockquote>
<p>总结：继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h2 id="继承同名成员处理的方式"><a href="#继承同名成员处理的方式" class="headerlink" title="继承同名成员处理的方式"></a>继承同名成员处理的方式</h2><p><strong>问题</strong>：当子类和父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Base &#123;
public:
    Base()    &#123;
        m_A = 100;
    &#125;

    void func()    &#123;
        cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;
    &#125;

    void func(int a)    &#123;
        cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;
    &#125;

public:
    int m_A;
&#125;;

class Son : public Base &#123;
public:
    Son()    &#123;
        m_A = 200;
    &#125;

    //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数
    //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域
    void func()    &#123;
        cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;
    &#125;
public:
    int m_A;
&#125;;

void test01()&#123;
    Son s;

    cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;
    cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;

    s.func();
    s.Base::func();
    s.Base::func(10);

&#125;
int main() &#123;

    test01();

    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153747.png" alt=""></p>
<ul>
<li>总结<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
</li>
</ul>
<h2 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h2><p><strong>问题</strong>：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类童名成员 需要加作用域</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Base &#123;
public:
    static void func()    &#123;
        cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;
    &#125;
    static void func(int a)    &#123;
        cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;
    &#125;

    static int m_A;
&#125;;

int Base::m_A = 100;

class Son : public Base &#123;
public:
    static void func()    &#123;
        cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;
    &#125;
    static int m_A;
&#125;;

int Son::m_A = 200;

//同名成员属性
void test01()&#123;
    //通过对象访问
    cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;
    Son s;
    cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;
    cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;

    //通过类名访问
    cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;
    cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;
&#125;

//同名成员函数
void test02()&#123;
    //通过对象访问
    cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;
    Son s;
    s.func();
    s.Base::func();

    cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;
    Son::func();
    Son::Base::func();
    //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问
    Son::Base::func(100);
&#125;

int main() &#123;
    //test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153841.png" alt=""></p>
<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过 对象 和 类名）</p>
</blockquote>
<h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code>class子类 : 继承方式 父类1, 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Base1 &#123;
public:
    Base1()    &#123;
        m_A = 100;
    &#125;
public:
    int m_A;
&#125;;

class Base2 &#123;
public:
    Base2()    &#123;
        m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确
    &#125;
public:
    int m_A;
&#125;;

//语法：class 子类：继承方式 父类1 ，继承方式 父类2 
class Son : public Base2, public Base1 &#123;
public:
    Son()    &#123;
        m_C = 300;
        m_D = 400;
    &#125;
public:
    int m_C;
    int m_D;
&#125;;

//多继承容易产生成员同名的情况
//通过使用类名作用域可以区分调用哪一个基类的成员
void test01()&#123;
    Son s;
    cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;
    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;
    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329153926.png" alt=""></p>
<blockquote>
<p>总结：多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p><strong>菱形继承概念：</strong></p>
<p>两个派生类继承同一个基类</p>
<p>又有某个类同时继承着两个派生类</p>
<p>这种继承被称为菱形继承，或者钻石继承</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/lx.jpeg" alt=""><br><strong>菱形继承问题</strong>：</p>
<ol>
<li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性</li>
<li>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Animal&#123;
public:
    int m_Age;
&#125;;

//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
class Sheep : virtual public Animal &#123;&#125;;
class Tuo   : virtual public Animal &#123;&#125;;
class SheepTuo : public Sheep, public Tuo &#123;&#125;;

void test01()&#123;
    SheepTuo st;
    st.Sheep::m_Age = 100;
    st.Tuo::m_Age = 200;

    cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;
    cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;
    cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<ul>
<li>总结<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
</li>
</ul>
<p>为什么虚继承可以解决菱形继承问题？利用虚继承之后，子类指向父类的成员变成了一个指着共享区域的指针，没有利用virtual sheep指向m_Age，是代表着值，但是用了虚继承之后，这个就是指针了，指向另一块区域，这块区域才是存着m_Age。这样菱形继承的基类就不会有二义性。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象三大特性之一——多态</title>
    <url>/posts/d5cbaf36.html</url>
    <content><![CDATA[<p>多态分为两类：</p>
<ul>
<li>静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Animal&#123;
public:
    //Speak函数就是虚函数
    //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。
    virtual void speak()    &#123;
        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Cat :public Animal&#123;
public:
    void speak()    &#123;
        cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Dog :public Animal&#123;
public:
    void speak()    &#123;
        cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;
    &#125;
&#125;;
//我们希望传入什么对象，那么就调用什么对象的函数
//如果函数地址在编译阶段就能确定，那么静态联编
//如果函数地址在运行阶段才能确定，就是动态联编

void DoSpeak(Animal &amp; animal)&#123;
    animal.speak();
&#125;
//
//多态满足条件： 
//1、有继承关系
//2、子类重写父类中的虚函数
//多态使用：
//父类指针或引用指向子类对象

void test01()&#123;
    Cat cat;
    DoSpeak(cat);

    Dog dog;
    DoSpeak(dog);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329154352.png" alt=""></p>
<ul>
<li><p>总结：</p>
<p>  多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li><p>子类重写父类中的虚函数</p>
<p>多态使用条件：</p>
</li>
<li><p>父类指针或引用指向子类对象</p>
</li>
</ul>
</li>
</ul>
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名(参数列表) = 0;</code></p>
<p>当类中有了纯虚函数，这个类也称为<em>抽象类</em></p>
<p>抽象类特点：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="lang-cpp">class Base&#123;
public:
    //纯虚函数
    //类中只要有一个纯虚函数就称为抽象类
    //抽象类无法实例化对象
    //子类必须重写父类中的纯虚函数，否则也属于抽象类
    virtual void func() = 0;
&#125;;

class Son :public Base&#123;
public:
    virtual void func()     &#123;
        cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;
    &#125;;
&#125;;

void test01()&#123;
    Base * base = NULL;
    //base = new Base; // 错误，抽象类无法实例化对象
    base = new Son;
    base-&gt;func();
    delete base;//记得销毁
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329154424.png" alt=""></p>
<h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方法：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：<code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法： <code>virtual ~类名() = 0;</code> <code>类名::~类名()&#123;&#125;</code></p>
<p>示例：</p>
<pre><code class="lang-cpp">class Animal &#123;
public:
    Animal()    &#123;
        cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;
    &#125;
    virtual void Speak() = 0;

    //析构函数加上virtual关键字，变成虚析构函数
    //virtual ~Animal()
    //&#123;
    //    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;
    //&#125;

    virtual ~Animal() = 0;
&#125;;

Animal::~Animal()&#123;
    cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;
&#125;

//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。

class Cat : public Animal &#123;
public:
    Cat(string name)    &#123;
        cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;
        m_Name = new string(name);
    &#125;
    virtual void Speak()    &#123;
        cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;
    &#125;
    ~Cat()    &#123;
        cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;
        if (this-&gt;m_Name != NULL) &#123;
            delete m_Name;
            m_Name = NULL;
        &#125;
    &#125;

public:
    string *m_Name;
&#125;;

void test01()&#123;
    Animal *animal = new Cat(&quot;Tom&quot;);
    animal-&gt;Speak();

    //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏
    //怎么解决？给基类增加一个虚析构函数
    //虚析构函数就是用来解决通过父类指针释放子类对象
    delete animal;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230329154514.png" alt=""></p>
<ul>
<li>总结<ol>
<li>虚构函数或纯虚构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++核心</category>
      </categories>
  </entry>
</search>
