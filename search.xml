<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ test</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>LeetCode 707.设计链表</title>
    <url>/2023/03/17/LeetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="LeetCode-707-设计链表-mid"><a href="#LeetCode-707-设计链表-mid" class="headerlink" title="LeetCode 707.设计链表(mid)"></a>LeetCode 707.设计链表(mid)</h1><h1 id="707-设计链表（20220923每日一题）"><a href="#707-设计链表（20220923每日一题）" class="headerlink" title="707 设计链表（20220923每日一题）"></a>707 设计链表（20220923每日一题）</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/Untitled.png" alt="Problem Description"></p>
<p>从题目中我们可以看到本题有以下几个功能：</p>
<ol>
<li>获取链表中位列index的值</li>
<li>在链表的头部添加节点</li>
<li>在链表的尾部添加节点</li>
<li>在链表中的指定索引地添加节点</li>
<li>删除指定索引的节点</li>
</ol>
<p>题目让我们不能使用内置的LinkedList库，那么我们可以用数组和链表来维护。由于该题有频繁的增加节点和删除节点，那么用数组来维护需要耗费大量的时间来维护index，因此我们选择链表来维护本题的“链表”。</p>
<h2 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h2><p>由于是一个链表，那么节点中所需要的元素至少有两个，一个值val，和一个指向下一个节点的*next，最好就是添加一个构造函数，这样方便快速生成新节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        List *next;</span><br><span class="line">        <span class="built_in">List</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h2><p>当我们创建一个链表的时候，我们需要对其进行初始化，即构造函数，我们要对其成员进行一系列的初始化，在本题中我们需要初始化的元素只有结构体List，以及一个链表的长度，这个长度方便我们之后判断是否可以删除某个节点或者是否可以将节点加入指定的index</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们创建的链表是自带头节点的链表，这类链表方便进行头插法（但是这题我的思路还是尾插法）</p>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>提供一个索引值index，返回索引所在的节点的val值，首先我们要先判断这个索引值index是否有效，如果无效则直接返回-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="keyword">this</span>-&gt;len || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在链表头部添加节点"><a href="#在链表头部添加节点" class="headerlink" title="在链表头部添加节点"></a>在链表头部添加节点</h2><p>在添加节点的三个功能中，添加头部节点是最方便的，因为相比于其他两个，头部添加节点不需要找位置，可以直接添加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        node-&gt;next = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在链表尾部添加节点"><a href="#在链表尾部添加节点" class="headerlink" title="在链表尾部添加节点"></a>在链表尾部添加节点</h2><p>添加尾部节点，如果我们用一个尾部标记tail来维护尾部节点，那么这个我们也能够快速添加，但是我没有用tail来维护，那么我们就要遍历到最后链表的最后一位以便于添加节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>) head = head-&gt;next;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在给定索引值前添加节点"><a href="#在给定索引值前添加节点" class="headerlink" title="在给定索引值前添加节点"></a>在给定索引值前添加节点</h2><p>这部分内容相比于前两个来说，只能够通过遍历来获取要添加的位置。</p>
<p>题目中对给定索引值添加节点指定了要求，首先，如果这个索引值大于链表的长度，那么我们将取消这次添加节点。如果这个索引值小于0，那么我们就将这个节点添加在头部，其余的我们需要遍历来获取节点添加的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除指定索引值的节点"><a href="#删除指定索引值的节点" class="headerlink" title="删除指定索引值的节点"></a>删除指定索引值的节点</h2><p>题目中对删除节点指定了要求，如果索引值index有效，那么我们可以顺利删除，否则，我们将因为没有对应的节点可以删除而退出这个删除函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        List *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        List *next;</span><br><span class="line">        <span class="built_in">List</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    List *root;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="keyword">this</span>-&gt;len || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        node-&gt;next = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>) head = head-&gt;next;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        List *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 788.旋转数字</title>
    <url>/2023/03/17/LeetCode-788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="LeetCode-788-旋转数字-Mid"><a href="#LeetCode-788-旋转数字-Mid" class="headerlink" title="LeetCode 788.旋转数字(Mid)"></a>LeetCode 788.旋转数字(Mid)</h1><h1 id="788-旋转数字（20220925每日一题）"><a href="#788-旋转数字（20220925每日一题）" class="headerlink" title="788 旋转数字（20220925每日一题）"></a>788 旋转数字（20220925每日一题）</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目中已经给出了大致意思，要想数字每个位上的数都旋转后还能成为数字，那么这个数字必须包含且只能包含数字0，1，2，5，6，8，9。那么为什么前十个数中1，2，8，10不包含在旋转数字中呢？因为这4个数字旋转之后还是1，2，8，10，数值不变，这违反了旋转数字的定义。从这我们可以看出，要想数字旋转之后数值要改变，不能只包含1，2，8，0，还必须至少包含2，5，6，9中的一个，那么我们只要判断从1到n中的数字中有几个数是由上述8个数字组成，并且至少包含一个2，5，6，9.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rotatedDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">8</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = i;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[t % <span class="number">10</span>] == <span class="number">1</span>) a = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(f[t % <span class="number">10</span>] == <span class="number">2</span>) b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                t /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!t &amp;&amp; a) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>同向双指针 滑动窗口</title>
    <url>/2023/03/17/%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="同向双指针-滑动窗口"><a href="#同向双指针-滑动窗口" class="headerlink" title="同向双指针 滑动窗口"></a>同向双指针 滑动窗口</h1><h1 id="209-长度最小的子数组-Medium"><a href="#209-长度最小的子数组-Medium" class="headerlink" title="209. 长度最小的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>(Medium)</strong></h1><p>这道题的目标是在给定数组上求最短连续数组的和大于给定的k值</p>
<p>一般思路：用两个for循环来遍历所有可能的子串和，这种方法的时间复杂度是 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">				<span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">				<span class="type">int</span> res = len;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">					<span class="type">int</span> tmp = nums[i];</span><br><span class="line">					<span class="keyword">if</span>(tmp &gt;= target) len = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">						tmp += nums[j];</span><br><span class="line">						<span class="keyword">if</span>(tmp &gt;= target) &#123;</span><br><span class="line">							len = <span class="built_in">min</span>(len, j - i + <span class="number">1</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法就是使用双指针，之前我们用到的双指针一般都是指向一头一尾，然后通过不断向中间位移来压缩长度。</p>
<p>这道题的双指针是同向双指针，类似于队列的头指针和尾指针。我们先移动头指针，直到头指针和尾指针之间的数之和大于等于给定值。当和大于等于给定值时，我们就开始移动尾指针，知道头指针和尾指针之间的数之和小于给定值，在移动尾指针的时候我们要实时更新最短长度，这个最短长度就是头指针和尾指针的距离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(i - idx, res);</span><br><span class="line">                idx++;</span><br><span class="line">                sum -= nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == nums.<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="713-乘积小于-K-的子数组-Medium"><a href="#713-乘积小于-K-的子数组-Medium" class="headerlink" title="713. 乘积小于 K 的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a>(Medium)</strong></h1><p>这道题和上面类似，只不过上面是求最大的长度，这里是要枚举数量。</p>
<p>但是No.713和No.209类似，都是需要用到双指针，而且是同向双指针，双指针维护的是双指针之间的乘积。</p>
<p>那么重点来了，双指针维护的是乘积，我们怎么获取个数呢？因为双指针之间的数的乘积是小于K的，当他大于K时，我们也只要更新左指针来保证双指针之间的数的乘积小于K。从这我们可以看出双指针的右指针在一次操作中是不动的，那么我们就可以在每次确立右指针之后，查看是否要更新左指针，之后我们在这个双指针的基础上，以右指针为数组的右端点，枚举左端点，查看最后有多少个以右指针为数组端点的子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum *= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= k &amp;&amp; idx &lt; i) sum /= nums[++idx];</span><br><span class="line">            res += (i - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-无重复字符的最长子串-Meduim"><a href="#3-无重复字符的最长子串-Meduim" class="headerlink" title="3. 无重复字符的最长子串[Meduim]"></a><strong><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>[Meduim]</strong></h1><p>这道题利用双指针怎么做呢？</p>
<p>我们利用同向双指针，右指针每往右移一个时，我们判断这个新加入的元素在左右指针中是否已经出现过。如果没出现过，那么我们就继续右移右指针，如果出现过，那么我们就要开始移动左指针，直到左右指针之间的所有元素都只出现一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash[s[i]])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - idx);</span><br><span class="line">                hash[s[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(s[++idx] != s[i])&#123;</span><br><span class="line">                    hash[s[idx]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，同向双指针重要的是维护双指针之间的数，如果满足条件，一般移动右指针，当不满足时，右移左指针。</p>
<p>一般操作：</p>
<ol>
<li>右移右指针直到末尾</li>
<li>判断左右指针之间的数是否满足条件<ol>
<li>如果满足，回到步骤1</li>
<li>如果不满足，移动左指针，回到步骤2</li>
</ol>
</li>
<li>结束</li>
</ol>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2389. 和有限的最长子序列</title>
    <url>/2023/03/17/LeetCode-2389-%E5%92%8C%E6%9C%89%E9%99%90%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="LeetCode-2389-和有限的最长子序列"><a href="#LeetCode-2389-和有限的最长子序列" class="headerlink" title="LeetCode 2389. 和有限的最长子序列"></a>LeetCode 2389. 和有限的最长子序列</h1><h1 id="2389-和有限的最长子序列"><a href="#2389-和有限的最长子序列" class="headerlink" title="2389. 和有限的最长子序列"></a><strong><a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/description/">2389. 和有限的最长子序列</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/2.png" alt="Problem Description"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">nums <span class="operator">=</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>], queries <span class="operator">=</span> [<span class="number">3</span>,<span class="number">10</span>,<span class="number">21</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。</span><br><span class="line">- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。</span><br><span class="line">- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。</span><br></pre></td></tr></table></figure>

<p>数据范围是</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == queries.length</code></li>
<li><code>1 &lt;= n, m &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], queries[i] &lt;= 1e6</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们注意的第一点就是他给我们划重点的地方，我们要求的是子序列的最大长度</p>
<ul>
<li><p>子序列</p>
<p>  是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组</p>
</li>
</ul>
<p>题目让我们求子序列的最大长度，刚开始我以为是子串，需要连续，如果需要连续的话这道题的难度就会成倍地增长。如果是子序列那难度就会大大降低。因为我们是求子序列的总和，总和不用参考数组的顺序，那么我们可以随意的往子序列（最开始为空）中加入数字，直到这个总和大于<code>query</code>。</p>
<p>那么我们应该怎么加才能让这个子序列数组<code>size</code>最大呢？肯定是优先往里面加入最小的数，比如说现在的<code>nums</code>是<code>[4,5,2,1]</code>，<code>query</code>为<code>4</code>。如果我们往子序列中加入<code>4</code>，总和已经达到了要求，这个时候的<code>size</code>是<code>1</code>。但是如果我们往子序列中添加<code>1</code>，子序列的总和为<code>1</code>，还可以继续往里面添加，那么我们再选剩下的最小数<code>2</code>，这个时候子序列的总和为<code>3</code>，继续添加剩下的最小数<code>4</code>，总和达到了<code>7</code>，超过了<code>query</code>，那么我们就回退，<code>size</code>为<code>2</code>。这个例子我们就可以得出可以优先往里面添加最小数才能使得目标子序列的<code>size</code>最大。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>为了让添加最小数，我们可以先对数组进行排序，这样我们就能识别挑完最小数之后剩下的数中的最小数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> len = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; t &lt; nums.<span class="built_in">size</span>(); t++)&#123;</span><br><span class="line">                queries[i] -= nums[t];</span><br><span class="line">                <span class="keyword">if</span>(queries[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了避免我们对每个query都要进行一次累加，我们可以用前缀和的方式统计前<code>n</code>个较小数的总和，方便后面的寻找目标值。这样我们的时间复杂度就从 $O(m^2 * n)$降低到了 $O(m * n)$。</p>
<p>还可以进一步优化</p>
<p>因为我们现在已经获得了前缀和，还是一个排序后的数组的前缀和，那么这个前缀和数组也是一个有序数组。那么我们可以在这个有序数组中找到第一个<code>&gt;query</code>的值的索引，这样我们就把时间复杂度从 $O(m*n)$降到了 $O(nlogm)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">-1</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len_nums = nums.<span class="built_in">size</span>(), len_queries = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">qzh</span><span class="params">(len_nums, <span class="number">0</span>)</span>, <span class="title">ans</span><span class="params">(len_queries, <span class="number">0</span>)</span></span>;</span><br><span class="line">        qzh[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            qzh[i] = qzh[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_queries; i++)&#123;</span><br><span class="line">            ans[i] = <span class="built_in">Binary_Search</span>(qzh, queries[i]);</span><br><span class="line">            ans[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 面试题17.09. 第k个数</title>
    <url>/2023/03/20/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-09-%E7%AC%ACk%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="LeetCode-面试题17-09-第k个数"><a href="#LeetCode-面试题17-09-第k个数" class="headerlink" title="LeetCode 面试题17.09. 第k个数"></a>LeetCode 面试题17.09. 第k个数</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1709.png" alt="Problem Description"></p>
<p>这道题让我们从一个只包含质因子3，5，7数字的数组中，根据从小到大排序，获取第k个数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚开始的想法，就是根据一个优先队列，让较小的数优先弹出，但是这种做法比较麻烦的就是你的优先队列需要维护的长度是k*3，而优先队列的复杂度是O(log n)，再结合需要经过3k次的插入以及多次弹出，复杂度不够理想。</p>
<p>后面看了一个大佬的做法，利用三指针，用三个指针p3,p5,p7分别记录上次乘以质因子3、5、7的数组index，然后比较num[p3] * 3, num[p5] * 5, num[p7] * 7三者的大小，谁最小就更新哪个质因子的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *nums = <span class="keyword">new</span> <span class="type">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p3 = <span class="number">0</span>, p5 = <span class="number">0</span>, p7 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">            nums[i] = <span class="built_in">min</span>(nums[p3] * <span class="number">3</span>, <span class="built_in">min</span>(nums[p5] * <span class="number">5</span>, nums[p7] * <span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p3] * <span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[p5] * <span class="number">5</span>) p5++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[p7] * <span class="number">7</span>) p7++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个问题，当时我没有考虑到去重，这边的顺序是1,3,5,7,9,15,15,21,21,….。会有重复的数字，我们在每次比较中，要将每个最小值的质因子的指针更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *nums = <span class="keyword">new</span> <span class="type">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p3 = <span class="number">0</span>, p5 = <span class="number">0</span>, p7 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">            nums[i] = <span class="built_in">min</span>(nums[p3] * <span class="number">3</span>, <span class="built_in">min</span>(nums[p5] * <span class="number">5</span>, nums[p7] * <span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p3] * <span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p5] * <span class="number">5</span>) p5++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p7] * <span class="number">7</span>) p7++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 811. 子域名访问计数</title>
    <url>/2023/03/20/LeetCode-811-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="LeetCode-811-子域名访问计数"><a href="#LeetCode-811-子域名访问计数" class="headerlink" title="LeetCode 811. 子域名访问计数"></a>LeetCode 811. 子域名访问计数</h1><h1 id="811-子域名访问计数-20221005每日一题"><a href="#811-子域名访问计数-20221005每日一题" class="headerlink" title="****811. 子域名访问计数(20221005每日一题)**"></a>****<a href="https://leetcode.cn/problems/subdomain-visit-count/">811. 子域名访问计数</a>(20221005每日一题)**</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/811.png" alt="ProblemDescription"></p>
<p>网站域名 “<a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“ 由多个子域名组成。顶级域名为 “com” ，二级域名为 “<a href="http://leetcode.com/">leetcode.com</a>“ ，最低一级为 “<a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“。当访问域名 <code>&quot;discuss.leetcode.com&quot;</code>时，同时也会隐式访问其父域名 <code>&quot;leetcode.com&quot;</code> 以及 <code>&quot;com&quot;</code>。</p>
<p>计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。</p>
<p>例如，”9001 <a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“ 就是一个 计数配对域名 ，表示 <a href="http://discuss.leetcode.com/">discuss.leetcode.com</a> 被访问了 9001 次。</p>
<p>给你一个 <strong>计数配对域名</strong> 组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的 <strong>计数配对域名</strong>，并以数组形式返回。可以按 <strong>任意顺序</strong>返回答案。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们需要获得所有的域名以及他们的子域名，这个时候我们最好的想法就是用一个hash来存储所有出现过的域名，如果用其他方法不太现实。用hash来存储时我们不仅要考虑到出现的域名，我们还要考虑到这些域名出现的次数。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>对于每个字符串，首先，我们先正序遍历，找到这个网站出现的个数，然后再逆序遍历找到所有的子域名，找完所有的子域名之后记录每个子域名在当前情况下访问了几次，然后通过hash表进行累加。最后我们遍历hash表获取所有的域名以及他们的访问次数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    vector&lt;string&gt; <span class="title function_">subdomainVisits</span>(<span class="params">vector&lt;string&gt;&amp; cpdomains</span>) &#123;</span><br><span class="line">        unordered_map&lt;string, int&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(auto c : cpdomains)&#123;</span><br><span class="line">            int i = <span class="number">0</span>;</span><br><span class="line">            string num;</span><br><span class="line">						<span class="comment">//统计访问次数</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; c.<span class="title function_">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">                num += c[i];</span><br><span class="line">            &#125;</span><br><span class="line">            int times = <span class="title function_">stoi</span>(num);</span><br><span class="line">            string com;</span><br><span class="line">						<span class="comment">//统计域名</span></span><br><span class="line">            <span class="keyword">for</span>(int j = c.<span class="title function_">size</span>() - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    hash[com] += times;</span><br><span class="line">                &#125;</span><br><span class="line">                com = c[j] + com;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[com] += times;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">				<span class="comment">//遍历hash表获取每个子域名以及访问次数</span></span><br><span class="line">        <span class="keyword">for</span>(auto ha : hash)&#123;</span><br><span class="line">            string t = <span class="title function_">to_string</span>(ha.<span class="property">second</span>) + <span class="string">&#x27; &#x27;</span> + ha.<span class="property">first</span>;</span><br><span class="line">            res.<span class="title function_">emplace_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 77. 组合</title>
    <url>/2023/03/20/LeetCode-77-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="LeetCode-77-组合"><a href="#LeetCode-77-组合" class="headerlink" title="LeetCode 77. 组合"></a>LeetCode 77. 组合</h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><strong><strong><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></strong></strong></h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/77.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>这道题的意思就是一道排列组合的问题，即求 $C^k_n$这种数学问题，但是我们不是求值，而是求排列组合中每一种的组合。这样的题显然是一种枚举问题，遇到枚举问题 $一般$是用dfs和bfs的方法。在这道题中，我用了一个剪枝策略来加速寻找每一种组合。</p>
<p>如果剩下的数字个数加上当前数组大小小于要求值k，则返回</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> index, <span class="type">int</span> n, <span class="type">int</span> sum, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;res.<span class="built_in">emplace_back</span>(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum + n - index + <span class="number">1</span> &lt; k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, index + <span class="number">1</span>, n, sum, k);</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(index);</span><br><span class="line">        <span class="built_in">dfs</span>(arr, index + <span class="number">1</span>, n, sum + <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, <span class="number">1</span>, n, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>Dfs</tag>
      </tags>
  </entry>
</search>
