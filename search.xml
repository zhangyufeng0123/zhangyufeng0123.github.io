<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ test</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>LeetCode 707.设计链表</title>
    <url>/2023/03/17/LeetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="LeetCode-707-设计链表-mid"><a href="#LeetCode-707-设计链表-mid" class="headerlink" title="LeetCode 707.设计链表(mid)"></a>LeetCode 707.设计链表(mid)</h1><h1 id="707-设计链表（20220923每日一题）"><a href="#707-设计链表（20220923每日一题）" class="headerlink" title="707 设计链表（20220923每日一题）"></a>707 设计链表（20220923每日一题）</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/Untitled.png" alt="Problem Description"></p>
<p>从题目中我们可以看到本题有以下几个功能：</p>
<ol>
<li>获取链表中位列index的值</li>
<li>在链表的头部添加节点</li>
<li>在链表的尾部添加节点</li>
<li>在链表中的指定索引地添加节点</li>
<li>删除指定索引的节点</li>
</ol>
<p>题目让我们不能使用内置的LinkedList库，那么我们可以用数组和链表来维护。由于该题有频繁的增加节点和删除节点，那么用数组来维护需要耗费大量的时间来维护index，因此我们选择链表来维护本题的“链表”。</p>
<h2 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h2><p>由于是一个链表，那么节点中所需要的元素至少有两个，一个值val，和一个指向下一个节点的*next，最好就是添加一个构造函数，这样方便快速生成新节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        List *next;</span><br><span class="line">        <span class="built_in">List</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h2><p>当我们创建一个链表的时候，我们需要对其进行初始化，即构造函数，我们要对其成员进行一系列的初始化，在本题中我们需要初始化的元素只有结构体List，以及一个链表的长度，这个长度方便我们之后判断是否可以删除某个节点或者是否可以将节点加入指定的index</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们创建的链表是自带头节点的链表，这类链表方便进行头插法（但是这题我的思路还是尾插法）</p>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>提供一个索引值index，返回索引所在的节点的val值，首先我们要先判断这个索引值index是否有效，如果无效则直接返回-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="keyword">this</span>-&gt;len || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在链表头部添加节点"><a href="#在链表头部添加节点" class="headerlink" title="在链表头部添加节点"></a>在链表头部添加节点</h2><p>在添加节点的三个功能中，添加头部节点是最方便的，因为相比于其他两个，头部添加节点不需要找位置，可以直接添加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        node-&gt;next = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在链表尾部添加节点"><a href="#在链表尾部添加节点" class="headerlink" title="在链表尾部添加节点"></a>在链表尾部添加节点</h2><p>添加尾部节点，如果我们用一个尾部标记tail来维护尾部节点，那么这个我们也能够快速添加，但是我没有用tail来维护，那么我们就要遍历到最后链表的最后一位以便于添加节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>) head = head-&gt;next;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在给定索引值前添加节点"><a href="#在给定索引值前添加节点" class="headerlink" title="在给定索引值前添加节点"></a>在给定索引值前添加节点</h2><p>这部分内容相比于前两个来说，只能够通过遍历来获取要添加的位置。</p>
<p>题目中对给定索引值添加节点指定了要求，首先，如果这个索引值大于链表的长度，那么我们将取消这次添加节点。如果这个索引值小于0，那么我们就将这个节点添加在头部，其余的我们需要遍历来获取节点添加的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除指定索引值的节点"><a href="#删除指定索引值的节点" class="headerlink" title="删除指定索引值的节点"></a>删除指定索引值的节点</h2><p>题目中对删除节点指定了要求，如果索引值index有效，那么我们可以顺利删除，否则，我们将因为没有对应的节点可以删除而退出这个删除函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        List *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        List *next;</span><br><span class="line">        <span class="built_in">List</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    List *root;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="keyword">this</span>-&gt;len || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        node-&gt;next = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>) head = head-&gt;next;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        List *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 788.旋转数字</title>
    <url>/2023/03/17/LeetCode-788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="LeetCode-788-旋转数字-Mid"><a href="#LeetCode-788-旋转数字-Mid" class="headerlink" title="LeetCode 788.旋转数字(Mid)"></a>LeetCode 788.旋转数字(Mid)</h1><h1 id="788-旋转数字（20220925每日一题）"><a href="#788-旋转数字（20220925每日一题）" class="headerlink" title="788 旋转数字（20220925每日一题）"></a>788 旋转数字（20220925每日一题）</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目中已经给出了大致意思，要想数字每个位上的数都旋转后还能成为数字，那么这个数字必须包含且只能包含数字0，1，2，5，6，8，9。那么为什么前十个数中1，2，8，10不包含在旋转数字中呢？因为这4个数字旋转之后还是1，2，8，10，数值不变，这违反了旋转数字的定义。从这我们可以看出，要想数字旋转之后数值要改变，不能只包含1，2，8，0，还必须至少包含2，5，6，9中的一个，那么我们只要判断从1到n中的数字中有几个数是由上述8个数字组成，并且至少包含一个2，5，6，9.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rotatedDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">8</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = i;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[t % <span class="number">10</span>] == <span class="number">1</span>) a = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(f[t % <span class="number">10</span>] == <span class="number">2</span>) b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                t /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!t &amp;&amp; a) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>同向双指针 滑动窗口</title>
    <url>/2023/03/17/%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="同向双指针-滑动窗口"><a href="#同向双指针-滑动窗口" class="headerlink" title="同向双指针 滑动窗口"></a>同向双指针 滑动窗口</h1><h1 id="209-长度最小的子数组-Medium"><a href="#209-长度最小的子数组-Medium" class="headerlink" title="209. 长度最小的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>(Medium)</strong></h1><p>这道题的目标是在给定数组上求最短连续数组的和大于给定的k值</p>
<p>一般思路：用两个for循环来遍历所有可能的子串和，这种方法的时间复杂度是 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">				<span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">				<span class="type">int</span> res = len;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">					<span class="type">int</span> tmp = nums[i];</span><br><span class="line">					<span class="keyword">if</span>(tmp &gt;= target) len = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">						tmp += nums[j];</span><br><span class="line">						<span class="keyword">if</span>(tmp &gt;= target) &#123;</span><br><span class="line">							len = <span class="built_in">min</span>(len, j - i + <span class="number">1</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法就是使用双指针，之前我们用到的双指针一般都是指向一头一尾，然后通过不断向中间位移来压缩长度。</p>
<p>这道题的双指针是同向双指针，类似于队列的头指针和尾指针。我们先移动头指针，直到头指针和尾指针之间的数之和大于等于给定值。当和大于等于给定值时，我们就开始移动尾指针，知道头指针和尾指针之间的数之和小于给定值，在移动尾指针的时候我们要实时更新最短长度，这个最短长度就是头指针和尾指针的距离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(i - idx, res);</span><br><span class="line">                idx++;</span><br><span class="line">                sum -= nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == nums.<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="713-乘积小于-K-的子数组-Medium"><a href="#713-乘积小于-K-的子数组-Medium" class="headerlink" title="713. 乘积小于 K 的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a>(Medium)</strong></h1><p>这道题和上面类似，只不过上面是求最大的长度，这里是要枚举数量。</p>
<p>但是No.713和No.209类似，都是需要用到双指针，而且是同向双指针，双指针维护的是双指针之间的乘积。</p>
<p>那么重点来了，双指针维护的是乘积，我们怎么获取个数呢？因为双指针之间的数的乘积是小于K的，当他大于K时，我们也只要更新左指针来保证双指针之间的数的乘积小于K。从这我们可以看出双指针的右指针在一次操作中是不动的，那么我们就可以在每次确立右指针之后，查看是否要更新左指针，之后我们在这个双指针的基础上，以右指针为数组的右端点，枚举左端点，查看最后有多少个以右指针为数组端点的子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum *= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= k &amp;&amp; idx &lt; i) sum /= nums[++idx];</span><br><span class="line">            res += (i - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-无重复字符的最长子串-Meduim"><a href="#3-无重复字符的最长子串-Meduim" class="headerlink" title="3. 无重复字符的最长子串[Meduim]"></a><strong><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>[Meduim]</strong></h1><p>这道题利用双指针怎么做呢？</p>
<p>我们利用同向双指针，右指针每往右移一个时，我们判断这个新加入的元素在左右指针中是否已经出现过。如果没出现过，那么我们就继续右移右指针，如果出现过，那么我们就要开始移动左指针，直到左右指针之间的所有元素都只出现一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash[s[i]])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - idx);</span><br><span class="line">                hash[s[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(s[++idx] != s[i])&#123;</span><br><span class="line">                    hash[s[idx]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，同向双指针重要的是维护双指针之间的数，如果满足条件，一般移动右指针，当不满足时，右移左指针。</p>
<p>一般操作：</p>
<ol>
<li>右移右指针直到末尾</li>
<li>判断左右指针之间的数是否满足条件<ol>
<li>如果满足，回到步骤1</li>
<li>如果不满足，移动左指针，回到步骤2</li>
</ol>
</li>
<li>结束</li>
</ol>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
