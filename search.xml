<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 运行机制</title>
    <url>/2023/03/20/Java-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Java运行机制"><a href="#Java运行机制" class="headerlink" title="Java运行机制"></a>Java运行机制</h1><h2 id="Java运行的一般步骤是"><a href="#Java运行的一般步骤是" class="headerlink" title="Java运行的一般步骤是"></a>Java运行的一般步骤是</h2><ol>
<li>Java首先利用文本编辑器编写Java源程序，源文件的后缀名为.java;</li>
<li>再利用编译器（javac）将源程序编译成字节码，字节码文件的后缀名为.class;</li>
<li>最后利用虚拟机（解释器，Java）解释执行。如下图所示</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160450.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160450.png"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160702.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160702.png"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160716.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320160716.png"></p>
<h2 id="JVM、JRE和JDK三者的不同"><a href="#JVM、JRE和JDK三者的不同" class="headerlink" title="JVM、JRE和JDK三者的不同"></a>JVM、JRE和JDK三者的不同</h2><p><strong>JVM</strong>(Java Virtual Machine):用于执行bytecode字节码的“虚拟计算机”；</p>
<p>不同的操作系统有不同版本的JVM，屏蔽了底层运行平台的差别，是实现跨平台的核心。</p>
<p><strong>JRE</strong>(Java Runtime Environment),它包含了Java虚拟机(JVM)、库函数等。</p>
<p><strong>JDK</strong>(Java Development Kit)包含了JRE，编译器和调试器等。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320161326.png" alt="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230320161326.png"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1326.灌溉花园的最少水龙头数目</title>
    <url>/2023/03/20/LeetCode-1326-%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E9%BE%99%E5%A4%B4%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="1326-灌溉花园的最少水龙头数目-20230221每日一题"><a href="#1326-灌溉花园的最少水龙头数目-20230221每日一题" class="headerlink" title="1326. 灌溉花园的最少水龙头数目(20230221每日一题)"></a><strong><a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/">1326. 灌溉花园的最少水龙头数目</a>(20230221每日一题)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i -  ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1326.png"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5</span>, ranges = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p><code>点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题看似是一道hard难度的题，真实难度感觉是一道medium难度的题。</p>
<p>题目的意思是用多个喷水口来覆盖整个花园，它的表达意思可能让我们难以下手，但是如果我们换一个说法，每一个喷水口不是<code>[i-range[i], i+range[i]]</code>，而是<code>[i, i+range[i]*2]</code>。这样子就能更好的理解了。</p>
<p>接下来的解题步骤就是我们先确定每个水龙头能灌溉的左右边界，然后确定每个左边界能够到达的最右边界。之后我们就从头开始遍历，先确定<code>0</code>位置能够到达的最右边界，然后我们定义<code>right</code>为当前最右边界，<code>right_last</code>为上次最右边界，然后每次从当前最右边界遍历到上次最右边界，如果在这个区间中能够到达的最右边界是小于<code>right</code>的值，那么说明水龙头不能灌溉所有的区间。否则就更新<code>right</code>和<code>right_last</code>这两个值，直到<code>right</code>值大于等于<code>n</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTaps</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_most</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> len = ranges[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= len) right_most[i - len] = i + len;</span><br><span class="line">            <span class="keyword">else</span> right_most[<span class="number">0</span>] = <span class="built_in">max</span>(right_most[<span class="number">0</span>], len + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, right = <span class="number">0</span>, right_last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="type">int</span> right_tmp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= right_last; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right_most[i] &gt; right)&#123;</span><br><span class="line">                    right_tmp = <span class="built_in">max</span>(right_tmp, right_most[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right_tmp == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            res++;</span><br><span class="line">            right_last = right;</span><br><span class="line">            right = right_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1769.移动所有球到每个盒子所需的最小操作数</title>
    <url>/2023/03/20/LeetCode-1769-%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1769-移动所有球到每个盒子所需的最小操作数-20221202每日一题"><a href="#1769-移动所有球到每个盒子所需的最小操作数-20221202每日一题" class="headerlink" title="1769. 移动所有球到每个盒子所需的最小操作数(20221202每日一题)"></a><strong><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/">1769. 移动所有球到每个盒子所需的最小操作数</a>(20221202每日一题)</strong></h1><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#39;0&#39;</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>&#39;1&#39;</code> 表示盒子里有 <strong>一个</strong> 小球。</p>
<p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>
<p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p>
<p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h2 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boxes = <span class="string">&quot;110&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>n == boxes.length</code></li>
<li><code>1 &lt;= n &lt;= 2000</code></li>
<li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据题目的意思，这是让我们求把所有的球移到一个位置所需要的最少次数，一次只能把一个球移到邻居。知道这个步骤之后，我们只要知道每个位置的左边的球和右边的球分别移到这个位置所需要多少次即可。那么我们怎么计算呢？如果每计算一个索引值时都遍历一次数组，那需要$O(n^2)$的时间复杂度，虽然本题中n的范围是<code>[1,2000]</code>，时间是足够的，但是这里有另一个更低的时间复杂度的方法。我们需要维护两个数组来维护数据，一个数组来维护这个位置左边所有的球到这个位置需要的次数和右边所有的球到这个位置需要的次数，怎么维护呢？这里就涉及到前缀和的思想。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minOperations</span><span class="params">(string boxes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = boxes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(len, <span class="number">0</span>)</span>, <span class="title">r</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> balls = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(boxes.<span class="built_in">front</span>() == <span class="string">&#x27;1&#x27;</span>) balls++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            l[i] = l[i - <span class="number">1</span>] + balls;</span><br><span class="line">            <span class="keyword">if</span>(boxes[i] == <span class="string">&#x27;1&#x27;</span>) balls++;</span><br><span class="line">        &#125;</span><br><span class="line">        balls = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(boxes.<span class="built_in">back</span>() == <span class="string">&#x27;1&#x27;</span>) balls++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            r[i] = r[i + <span class="number">1</span>] + balls;</span><br><span class="line">            <span class="keyword">if</span>(boxes[i] == <span class="string">&#x27;1&#x27;</span>) balls++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            l[i] += r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2469. 温度转换</title>
    <url>/2023/03/21/LeetCode-2469-%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="2469-温度转换"><a href="#2469-温度转换" class="headerlink" title="2469. 温度转换"></a><strong><a href="https://leetcode.cn/problems/convert-the-temperature/description/">2469. 温度转换</a></strong></h2><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230321132248.png"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">celsius = <span class="number">36.50</span></span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">309.65000</span>,<span class="number">97.70000</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>• <code>0 &lt;= celsius &lt;= 1000</code></p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>单纯的输入输出</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">convertTemperature</span><span class="params">(<span class="type">double</span> celsius)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = celsius + <span class="number">273.15</span>;</span><br><span class="line">        res[<span class="number">1</span>] = celsius * <span class="number">1.80</span> + <span class="number">32.00</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2389. 和有限的最长子序列</title>
    <url>/2023/03/17/LeetCode-2389-%E5%92%8C%E6%9C%89%E9%99%90%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="LeetCode-2389-和有限的最长子序列"><a href="#LeetCode-2389-和有限的最长子序列" class="headerlink" title="LeetCode 2389. 和有限的最长子序列"></a>LeetCode 2389. 和有限的最长子序列</h1><h1 id="2389-和有限的最长子序列"><a href="#2389-和有限的最长子序列" class="headerlink" title="2389. 和有限的最长子序列"></a><strong><a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/description/">2389. 和有限的最长子序列</a></strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/2.png" alt="Problem Description"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">nums <span class="operator">=</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>], queries <span class="operator">=</span> [<span class="number">3</span>,<span class="number">10</span>,<span class="number">21</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。</span><br><span class="line">- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。</span><br><span class="line">- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。</span><br></pre></td></tr></table></figure>

<p>数据范围是</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == queries.length</code></li>
<li><code>1 &lt;= n, m &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], queries[i] &lt;= 1e6</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们注意的第一点就是他给我们划重点的地方，我们要求的是子序列的最大长度</p>
<ul>
<li><p>子序列</p>
<p>  是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组</p>
</li>
</ul>
<p>题目让我们求子序列的最大长度，刚开始我以为是子串，需要连续，如果需要连续的话这道题的难度就会成倍地增长。如果是子序列那难度就会大大降低。因为我们是求子序列的总和，总和不用参考数组的顺序，那么我们可以随意的往子序列（最开始为空）中加入数字，直到这个总和大于<code>query</code>。</p>
<p>那么我们应该怎么加才能让这个子序列数组<code>size</code>最大呢？肯定是优先往里面加入最小的数，比如说现在的<code>nums</code>是<code>[4,5,2,1]</code>，<code>query</code>为<code>4</code>。如果我们往子序列中加入<code>4</code>，总和已经达到了要求，这个时候的<code>size</code>是<code>1</code>。但是如果我们往子序列中添加<code>1</code>，子序列的总和为<code>1</code>，还可以继续往里面添加，那么我们再选剩下的最小数<code>2</code>，这个时候子序列的总和为<code>3</code>，继续添加剩下的最小数<code>4</code>，总和达到了<code>7</code>，超过了<code>query</code>，那么我们就回退，<code>size</code>为<code>2</code>。这个例子我们就可以得出可以优先往里面添加最小数才能使得目标子序列的<code>size</code>最大。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>为了让添加最小数，我们可以先对数组进行排序，这样我们就能识别挑完最小数之后剩下的数中的最小数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> len = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; t &lt; nums.<span class="built_in">size</span>(); t++)&#123;</span><br><span class="line">                queries[i] -= nums[t];</span><br><span class="line">                <span class="keyword">if</span>(queries[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了避免我们对每个query都要进行一次累加，我们可以用前缀和的方式统计前<code>n</code>个较小数的总和，方便后面的寻找目标值。这样我们的时间复杂度就从 $O(m^2 * n)$降低到了 $O(m * n)$。</p>
<p>还可以进一步优化</p>
<p>因为我们现在已经获得了前缀和，还是一个排序后的数组的前缀和，那么这个前缀和数组也是一个有序数组。那么我们可以在这个有序数组中找到第一个<code>&gt;query</code>的值的索引，这样我们就把时间复杂度从 $O(m*n)$降到了 $O(nlogm)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">-1</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len_nums = nums.<span class="built_in">size</span>(), len_queries = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">qzh</span><span class="params">(len_nums, <span class="number">0</span>)</span>, <span class="title">ans</span><span class="params">(len_queries, <span class="number">0</span>)</span></span>;</span><br><span class="line">        qzh[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            qzh[i] = qzh[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_queries; i++)&#123;</span><br><span class="line">            ans[i] = <span class="built_in">Binary_Search</span>(qzh, queries[i]);</span><br><span class="line">            ans[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>前缀和</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1616.分割两个字符串得到回文串</title>
    <url>/2023/03/20/LeetCode-1616-%E5%88%86%E5%89%B2%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="1616-分割两个字符串得到回文串-Medium"><a href="#1616-分割两个字符串得到回文串-Medium" class="headerlink" title="1616. 分割两个字符串得到回文串(Medium)"></a><strong><a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/">1616. 分割两个字符串得到回文串</a>(Medium)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1616.png"></p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;ulacfd&quot;</span>, b = <span class="string">&quot;jizalu&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aprefix = <span class="string">&quot;ula&quot;</span>, asuffix = <span class="string">&quot;cfd&quot;</span></span><br><span class="line">bprefix = <span class="string">&quot;jiz&quot;</span>, bsuffix = <span class="string">&quot;alu&quot;</span></span><br><span class="line">那么 aprefix + bsuffix = <span class="string">&quot;ula&quot;</span> + <span class="string">&quot;alu&quot;</span> = <span class="string">&quot;ulaalu&quot;</span> 是回文串。</span><br></pre></td></tr></table></figure>

<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li><code>1 &lt;= a.length, b.length &lt;= 105</code></li>
<li><code>a.length == b.length</code></li>
<li><code>a</code> 和 <code>b</code> 都只包含小写英文字母</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题最暴力的想法，就是现在每个地方切一刀获取两个新形成的字符串，然后再比较每一个字符串是否是回文串，这样的时间复杂度是 $O(n^2)$，耗时比较高。</p>
<p>怎么降低耗时呢？</p>
<p>我的做法就是去除冗余的比较，比如说样例给的两个字符串”ulacfd”,”jizalu”，划在第一刀时形成的字符串”uizalu”,”jlacfd”，和划在第二刀形成的字符串”ulzalu”,”jiacfd”，其中第一个字符串首字母”u“和第二个字符串末字母”u“对比了两次，但是他们在位置上是构成回文的。如果我们先把这些能够构成回文的位置都找到，那么我们就能够减少很多冗余的对比。再给一组例子，“ulbbfc”,”jizalu”，我们已经找到了首尾能够构成回文的字符串了，”ul”,”lu”，但是剩下的中间部分不能由两个字符串拼接而成了，如果能够继续拼接，那么说明获取能够构成回文的字符串应该是”ulb”，”alu”，这很明显是不能构成回文的。</p>
<p>那么接下来应该怎么做呢？</p>
<p>既然剩下的部分不能由两个字符串拼接而成，那么我们就在两个字符串剩下的部分来判断是否是回文串即可，比如“ulbbfc”,”jizalu”这组例子，我们已经获得了目标回文串的首尾”ul“和”lu”，这个首尾能够组成的字符串只能是”ulzalu”，”ulbalu”，”ulbblu”，但是因为中间部分不能由两个字符串拼接，那么只剩下两个字符串”ulzalu”和”ulbblu”。也就是说，我们只要判断”za””bb”是不是回文串即可。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>这道题因为是<code>a$_&#123;prefix&#125;$ + b$_&#123;suffix&#125;$</code>或者<code>b$_&#123;prefix&#125;$ + a$_&#123;suffix&#125;$</code>其中有一个满足就行，那么我们只需要分别做<code>a$_&#123;prefix&#125;$ + b$_&#123;suffix&#125;$</code>和<code>b$_&#123;prefix&#125;$ + a$_&#123;suffix&#125;$</code>即可。即先判断a字符串前和b字符串末能够构成回文的最大长度，然后在两个字符串剩余部分判断是否构成回文，如果最后的字符串不是回文，那么再用相同的方法判断另外一组。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">chechAgain</span><span class="params">(string a, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == a[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string a, string b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chechAgain</span>(a, i ,j) || <span class="built_in">chechAgain</span>(b, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindromeFormation</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(a, b) || <span class="built_in">check</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 481.神奇数字</title>
    <url>/2023/03/20/LeetCode-481-%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="481-神奇字符串-20221031每日一题"><a href="#481-神奇字符串-20221031每日一题" class="headerlink" title="481. 神奇字符串(20221031每日一题)"></a><a href="https://leetcode.cn/problems/magical-string/">481. 神奇字符串</a>(20221031每日一题)</h1><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/481-1.png" alt="Problem Description"></p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题给出一个一维数组，后面的数会根据前面的数而定值，那么我们只需要模拟一下即可，那么怎么模拟呢？</p>
<p>定义这个一维数组为<code>arr</code>，那么我们可以看到。<code>arr[2]</code>的数字要根据<code>arr[1]</code>来定值，<code>arr[3]</code>的数字要根据<code>arr[2]</code>来定值，因为<code>arr[0]</code>为<code>1</code>，<code>arr[1]</code>为<code>2</code>，而因为<code>arr[1]</code>为<code>2</code>，那么<code>arr[1]</code>和<code>arr[2]</code>需要相同的数字，即<code>arr[2] = arr[1]</code>，之后<code>arr[3]</code>的值不能与<code>arr[2]</code>相等，否则就成为了<code>arr[1]=arr[2]=arr[3]</code>，这个时候<code>arr[1]</code>的值需要为<code>3</code>才能解释的通，但是<code>arr</code>的值只能是<code>1</code>或者<code>2</code>，那么我们就要将改变<code>arr[3]</code>的值与前面的值不同。</p>
<p>因此我们需要定义一个索引值<code>idx</code>，来表示当前相同数字所需要的连贯个数，用一个变量<code>f</code>来表示当前数组的数字，每加入一个数字时，我们就对<code>arr[idx]</code>进行减一操作，当<code>arr[idx]</code>为<code>0</code>时，我们就需要对<code>idx</code>进行<code>++</code>操作，并且改变<code>f</code>的值，使得数字之间不相同。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicalString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">1</span>, idx = <span class="number">2</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f == <span class="number">1</span>) ones++;</span><br><span class="line">            arr[i] = f;</span><br><span class="line">            arr[idx]--;</span><br><span class="line">            <span class="keyword">if</span>(arr[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                f = <span class="number">3</span> - f;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/481-2.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 209.长度最小的子数组</title>
    <url>/2023/03/20/LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/209.png" alt="Problem Description"></p>
<h2 id="Sample1"><a href="#Sample1" class="headerlink" title="Sample1"></a>Sample1</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">target = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="Sample2"><a href="#Sample2" class="headerlink" title="Sample2"></a>Sample2</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">target = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这个题目的数组长度范围是<code>[1,1e5]</code>，如果使用暴力的方法，也就是遍历所有的子数组，此时的时间复杂度是 $O(n^2)$，这个时候是有可能超时的，那么我们怎么来降低耗时呢？这个时候我们就可以利用滑动窗口的思路，即先记录一段子数组的总和，如果总和大于<code>target</code>，那么我们就可以慢慢减去这个子数组的最前面的数字，直到子数组的和小于<code>target</code>，在减的过程中我们统计这个子数组的长度与当前最优解进行比较，如果子数组的长度优于当前最优解时，我们就替换当前最优解。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们先用一个<code>idx</code>变量来记录这个数组的左端，然后遍历数组。在遍历数组的时候，我们用一个变量<code>sum</code>来记录从<code>idx</code>到<code>i</code>子数组总和。当这个总和<code>sum</code>的值大于等于<code>target</code>时，我们就慢慢删减<code>idx</code>上的数，同时把<code>idx</code>后移一位，直到<code>sum</code>小于<code>target</code>，在删减的同时更新最优解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(i - idx, res);</span><br><span class="line">                idx++;</span><br><span class="line">                sum -= nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == nums.<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 77. 组合</title>
    <url>/2023/03/20/LeetCode-77-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="LeetCode-77-组合"><a href="#LeetCode-77-组合" class="headerlink" title="LeetCode 77. 组合"></a>LeetCode 77. 组合</h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><strong><strong><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></strong></strong></h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/77.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>这道题的意思就是一道排列组合的问题，即求 $C^k_n$这种数学问题，但是我们不是求值，而是求排列组合中每一种的组合。这样的题显然是一种枚举问题，遇到枚举问题 $一般$是用dfs和bfs的方法。在这道题中，我用了一个剪枝策略来加速寻找每一种组合。</p>
<p>如果剩下的数字个数加上当前数组大小小于要求值k，则返回</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> index, <span class="type">int</span> n, <span class="type">int</span> sum, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;res.<span class="built_in">emplace_back</span>(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum + n - index + <span class="number">1</span> &lt; k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, index + <span class="number">1</span>, n, sum, k);</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(index);</span><br><span class="line">        <span class="built_in">dfs</span>(arr, index + <span class="number">1</span>, n, sum + <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">dfs</span>(arr, <span class="number">1</span>, n, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>Dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 788.旋转数字</title>
    <url>/2023/03/17/LeetCode-788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="LeetCode-788-旋转数字-Mid"><a href="#LeetCode-788-旋转数字-Mid" class="headerlink" title="LeetCode 788.旋转数字(Mid)"></a>LeetCode 788.旋转数字(Mid)</h1><h1 id="788-旋转数字（20220925每日一题）"><a href="#788-旋转数字（20220925每日一题）" class="headerlink" title="788 旋转数字（20220925每日一题）"></a>788 旋转数字（20220925每日一题）</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目中已经给出了大致意思，要想数字每个位上的数都旋转后还能成为数字，那么这个数字必须包含且只能包含数字0，1，2，5，6，8，9。那么为什么前十个数中1，2，8，10不包含在旋转数字中呢？因为这4个数字旋转之后还是1，2，8，10，数值不变，这违反了旋转数字的定义。从这我们可以看出，要想数字旋转之后数值要改变，不能只包含1，2，8，0，还必须至少包含2，5，6，9中的一个，那么我们只要判断从1到n中的数字中有几个数是由上述8个数字组成，并且至少包含一个2，5，6，9.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rotatedDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">9</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        f[<span class="number">8</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = i;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[t % <span class="number">10</span>] == <span class="number">1</span>) a = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(f[t % <span class="number">10</span>] == <span class="number">2</span>) b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                t /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!t &amp;&amp; a) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 707.设计链表</title>
    <url>/2023/03/17/LeetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="LeetCode-707-设计链表-mid"><a href="#LeetCode-707-设计链表-mid" class="headerlink" title="LeetCode 707.设计链表(mid)"></a>LeetCode 707.设计链表(mid)</h1><h1 id="707-设计链表（20220923每日一题）"><a href="#707-设计链表（20220923每日一题）" class="headerlink" title="707 设计链表（20220923每日一题）"></a>707 设计链表（20220923每日一题）</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/Untitled.png" alt="Problem Description"></p>
<p>从题目中我们可以看到本题有以下几个功能：</p>
<ol>
<li>获取链表中位列index的值</li>
<li>在链表的头部添加节点</li>
<li>在链表的尾部添加节点</li>
<li>在链表中的指定索引地添加节点</li>
<li>删除指定索引的节点</li>
</ol>
<p>题目让我们不能使用内置的LinkedList库，那么我们可以用数组和链表来维护。由于该题有频繁的增加节点和删除节点，那么用数组来维护需要耗费大量的时间来维护index，因此我们选择链表来维护本题的“链表”。</p>
<h2 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h2><p>由于是一个链表，那么节点中所需要的元素至少有两个，一个值val，和一个指向下一个节点的*next，最好就是添加一个构造函数，这样方便快速生成新节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        List *next;</span><br><span class="line">        <span class="built_in">List</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h2><p>当我们创建一个链表的时候，我们需要对其进行初始化，即构造函数，我们要对其成员进行一系列的初始化，在本题中我们需要初始化的元素只有结构体List，以及一个链表的长度，这个长度方便我们之后判断是否可以删除某个节点或者是否可以将节点加入指定的index</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们创建的链表是自带头节点的链表，这类链表方便进行头插法（但是这题我的思路还是尾插法）</p>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>提供一个索引值index，返回索引所在的节点的val值，首先我们要先判断这个索引值index是否有效，如果无效则直接返回-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="keyword">this</span>-&gt;len || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在链表头部添加节点"><a href="#在链表头部添加节点" class="headerlink" title="在链表头部添加节点"></a>在链表头部添加节点</h2><p>在添加节点的三个功能中，添加头部节点是最方便的，因为相比于其他两个，头部添加节点不需要找位置，可以直接添加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        node-&gt;next = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在链表尾部添加节点"><a href="#在链表尾部添加节点" class="headerlink" title="在链表尾部添加节点"></a>在链表尾部添加节点</h2><p>添加尾部节点，如果我们用一个尾部标记tail来维护尾部节点，那么这个我们也能够快速添加，但是我没有用tail来维护，那么我们就要遍历到最后链表的最后一位以便于添加节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>) head = head-&gt;next;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在给定索引值前添加节点"><a href="#在给定索引值前添加节点" class="headerlink" title="在给定索引值前添加节点"></a>在给定索引值前添加节点</h2><p>这部分内容相比于前两个来说，只能够通过遍历来获取要添加的位置。</p>
<p>题目中对给定索引值添加节点指定了要求，首先，如果这个索引值大于链表的长度，那么我们将取消这次添加节点。如果这个索引值小于0，那么我们就将这个节点添加在头部，其余的我们需要遍历来获取节点添加的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除指定索引值的节点"><a href="#删除指定索引值的节点" class="headerlink" title="删除指定索引值的节点"></a>删除指定索引值的节点</h2><p>题目中对删除节点指定了要求，如果索引值index有效，那么我们可以顺利删除，否则，我们将因为没有对应的节点可以删除而退出这个删除函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        List *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        List *next;</span><br><span class="line">        <span class="built_in">List</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    List *root;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="keyword">this</span>-&gt;len || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        node-&gt;next = <span class="keyword">this</span>-&gt;root-&gt;next;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>) head = head-&gt;next;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *node = <span class="keyword">new</span> <span class="built_in">List</span>(val);</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>-&gt;len) <span class="keyword">return</span>;</span><br><span class="line">        List *head = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        List *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode每日一题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 870. 优势洗牌</title>
    <url>/2023/03/20/LeetCode-870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/</url>
    <content><![CDATA[<h1 id="870-优势洗牌-20221008每日一题"><a href="#870-优势洗牌-20221008每日一题" class="headerlink" title="870. 优势洗牌 (20221008每日一题)"></a><a href="https://leetcode.cn/problems/advantage-shuffle/">870. 优势洗牌</a> (20221008每日一题)</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/870.png" alt="Problem Description"></p>
<p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p>
<p>返回 nums1的<strong>任意</strong>排列，使其相对于 <code>nums2</code>的优势最大化。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们重排序<code>nums1</code>数组里的数字，使得<code>nums1</code>与<code>nums2</code>相同下标下<code>nums1</code>中的数比<code>nums2</code>中的数大，我们要求的是最大化情况下<code>nums1</code>数组中数字的排列情况。</p>
<p>这道题类似于田忌赛马，田忌赛马中有下等马、中等马、上等马，我们用我方的中等马配对对方的下等马，用上等马配对对方的中等马，用下等马配对对方的上等马。</p>
<p>在这里我们可以把数字看作马匹的好坏，我们需要用<code>nums1</code>中的较好的马匹配<code>nums2</code>中较差的马，用<code>nums1</code>中较差的马匹配nums2中最好的马。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>首先我们需要先排序，将<code>nums1</code>和<code>nums2</code>分别进行从小到大的顺序进行排序，其中<code>nums2</code>排序之后我们要记录每个数原来的索引值。这样方便将<code>nums1</code>的数放到对应的位置。</p>
<p>我们依次从<code>nums1</code>和<code>nums2</code>拿出<code>n1</code>和<code>n2</code></p>
<ul>
<li>如果<code>n1&gt;n2</code>，那么<code>n1</code>就相当于上等马，<code>n2</code>相等于中等马或者下等马，这个时候我们就在<code>n2</code>对应的索引值上放入<code>n1</code>的值。</li>
<li>如果<code>n1≤n2</code>，那么<code>n1</code>就相当于下等马，我们将其与<code>nums2</code>中的最优秀的马进行对比。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;A, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.first &lt; B.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums1.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">arr</span>(len);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            arr[i] = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;nums2[i], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="keyword">this</span>-&gt;cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>, index = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; arr[idx].first)&#123;</span><br><span class="line">                res[arr[idx].second] = nums1[i];</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[arr[index].second] = nums1[i];</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/870-1.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 791. 自定义字符串排序</title>
    <url>/2023/03/20/LeetCode-791-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="791-自定义字符串排序-20221113-每日一题"><a href="#791-自定义字符串排序-20221113-每日一题" class="headerlink" title="791. 自定义字符串排序(20221113 每日一题)"></a><strong><a href="https://leetcode.cn/problems/custom-sort-string/">791. 自定义字符串排序</a>(20221113 每日一题)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定两个字符串 <code>order</code> 和 <code>s</code> 。<code>order</code> 的所有单词都是 <strong>唯一</strong> 的，并且以前按照一些自定义的顺序排序。对 <code>s</code> 的字符进行置换，使其与排序的 <code>order</code> 相匹配。更具体地说，如果在 <code>order</code> 中的字符 <code>x</code> 出现字符 <code>y</code> 之前，那么在排列后的字符串中， <code>x</code> 也应该出现在 <code>y</code> 之前。返回 <em>满足这个性质的 <code>s</code> 的任意排列</em> 。</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">order = <span class="string">&quot;cba&quot;</span>, s = <span class="string">&quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;cbad&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中给了我们两个字符串，一个优先级字符串，一个需要处理的字符串。从题目我们可以得出，我们需要处理的是有优先级定义的字符，对于其余字符我们可以不做处理，可以放在字符串最前面、可以放在字符串最后面、可以穿插在字符串之间。那么我们怎么处理这个有优先级的字符呢？</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>第一种想法就是我们先对$order$字符串中的字符定义优先级，其余字符的优先级都定义为最高优先级，然后对$s$字符串中的字符根据我们刚刚定义的优先级进行排序。但是这样有一个问题，这个想法涉及到排序，那么复杂度是$O(nlogn)$级别的，如果字符串长度太长会有一定的影响（但是题目中已经明确给出了字符串长度小于等于200，那这个思路也是可行的）。</p>
<h3 id="2（优化）"><a href="#2（优化）" class="headerlink" title="2（优化）"></a>2（优化）</h3><p>第二种想法就是一种$O(n)$的思路，我们没有必要使用排序来获得最终字符串，我们首先统计字符串$s$中每个字符有多少个，然后遍历$order$字符串，遍历到一个字符我们就将$s$中所有该字符加入目标字符串中，最后将没有出现在$order$字符串中但是出现在$s$字符串中的字符加入目标字符串即可。这个想法我们只要遍历两遍字符串$s$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">customSortString</span><span class="params">(string order, string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> O[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> letters[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) letters[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; order.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            O[order[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(letters[order[i] - <span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                res += order[i];</span><br><span class="line">                letters[order[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!O[i])&#123;</span><br><span class="line">                <span class="keyword">while</span>(letters[i]) &#123;</span><br><span class="line">                    res += <span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">                    letters[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 895. 最大频率栈</title>
    <url>/2023/03/20/LeetCode-895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
    <content><![CDATA[<h1 id="895-最大频率栈-20221130每日一题"><a href="#895-最大频率栈-20221130每日一题" class="headerlink" title="895. 最大频率栈(20221130每日一题)"></a><strong><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">895. 最大频率栈</a>(20221130每日一题)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>
<p>实现 <code>FreqStack</code> 类:</p>
<ul>
<li><code>FreqStack()</code> 构造一个空的堆栈。</li>
<li><code>void push(int val)</code> 将一个整数 <code>val</code> 压入栈顶。</li>
<li><code>int pop()</code> 删除并返回堆栈中出现频率最高的元素。<ul>
<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
</li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;FreqStack&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;pop&quot;</span>],</span><br><span class="line">[[],[<span class="number">5</span>],[<span class="number">7</span>],[<span class="number">5</span>],[<span class="number">7</span>],[<span class="number">4</span>],[<span class="number">5</span>],[],[],[],[]]</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[null,null,null,null,null,null,null,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0 &lt;= val &lt;= 1e9</code></li>
<li><code>push</code> 和 <code>pop</code> 的操作数不大于 <code>2 * 1e4</code>。</li>
<li>输入保证在调用 <code>pop</code> 之前堆栈中至少有一个元素。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中涉及到两个要点，一个是栈，一个是频率，即出现次数。题目要求我们实时弹出频率最高的那个元素，如果频率相同的元素，那就弹出先压入的元素。</p>
<p>那么我们怎么来确定每个元素的频率呢？考虑到元素范围是[0,1e9],那么如果使用数组来维护每个元素的频率，那就有可能会爆内存。后面显示push和pop的操作数不大于2e4，那么就代表元素种类最多是2e4，我们可以用哈希表来存。每push进一个元素的时候，我们就对其对应的出现次数进行+1操作，每pop一次时，我们对其对应的出现次数进行-1操作。这样我们就完成了对频率的维护。</p>
<p>剩下的问题是如何弹出频率最高的元素。我们目前已经完成了对push进来的数和pop出去的数的频率维护，我们要优先弹出频率最高的数。那么我们可以用数组来存储栈，数组的索引值代表着出现的频率，那么每当进行pop操作时，我们就优先弹出数组末尾的stack，因为数组末尾stack中存储的数都是频率最高的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;stack&lt;<span class="type">int</span>&gt;&gt; vst;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;</span><br><span class="line">        vst.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[val] == vst.<span class="built_in">size</span>())&#123;</span><br><span class="line">            vst.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        vst[hash[val]].<span class="built_in">push</span>(val);</span><br><span class="line">        hash[val]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(vst.<span class="built_in">back</span>().<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vst.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> e = vst.<span class="built_in">back</span>().<span class="built_in">top</span>();</span><br><span class="line">        vst.<span class="built_in">back</span>().<span class="built_in">pop</span>();</span><br><span class="line">        hash[e]--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack* obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 809. 情感丰富的文字</title>
    <url>/2023/03/20/LeetCode-809-%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<h1 id="809-情感丰富的文字"><a href="#809-情感丰富的文字" class="headerlink" title="809. 情感丰富的文字"></a><a href="https://leetcode.cn/problems/expressive-words/description/">809. 情感丰富的文字</a></h1><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code>, <code>&quot;hi&quot; -&gt; &quot;hiii&quot;</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：”h”, “eee”, “ll”, “ooo”。对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 <code>c</code> ），然后往其中添加相同的字母 <code>c</code> 使其长度达到 3 或以上。</p>
<p>例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 <code>s = &quot;helllllooo&quot;</code>，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>。</p>
<p>输入一组查询单词，输出其中可扩张的单词数量。</p>
<h1 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h1><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;heeellooo&quot;</span></span><br><span class="line">words = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;helo&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>第一想法是利用双指针，但是双指针在这题代码写着比较麻烦我就放弃了，之后就打算用暴力的方法。首先我先记录字符串<code>s</code>中的连续字符以及个数，然后分别记录words中每个字符串中的连续字符以及个数，把他们分别存储到各自的数组中，如果两个数组的长度不一样，说明这words中的字符串不能扩充为字符串<code>s</code>。那么当数组长度一样时，我们就比较相同索引下的字符是否相等以及字符个数的比较。</p>
<p>如果字符不相等，说明该字符串不能扩充为<code>s</code>。假设<code>s</code>为<code>”aaabbb”</code>，这个时候存储<code>s</code>的数组为<code>[&#123;’a’, 3&#125;, &#123;’b’, 3&#125;]</code>，<code>words</code>中存在一个字符串为<code>”aaaccc”</code>，那么存储该字符串的数组为<code>[&#123;’a’, 3&#125;, &#123;’c’, 3&#125;]</code>。虽然两个字符串对应的数组相同，但是第二个字符串的第二个字符为<code>’c’</code>，不能变为<code>’b’</code>，因此该字符串不能转变为<code>s</code>。</p>
<p>再者，题目中有对扩张的要求。扩张的操作：选择一个字幕组（包含字母<code>c</code>），然后往其中添加相同的字母<code>c</code>使其长度达到3或以上。那么我们就可以的出，<code>”o”</code>不能转换成<code>”oo”</code>，因为<code>”oo”</code>的字符串长度小于3。但是<code>”oo”</code>可以转变成<code>”ooo&quot;</code>，因为<code>“ooo”</code>的长度等于3，这符合扩张的操作。因此我们可以得出如果<code>s</code>中相同的字符的长度大于3，并且这个长度大于<code>words</code>对应字符串对应索引的字符长度，那么就可以被扩张，反之，有一个特例，即上述提到的<code>”o”</code>和<code>”oo”</code>之间的转化。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>首先我们对<code>s</code>进行操作，即用数组记录每一个连续字符的字符以及他的长度。之后我们对<code>words</code>中的每一个字符串进行相同的操作，然后比较两个数组。如果符合上述要求，那么<code>words</code>中的字符串就可以扩充为<code>s</code>，反之，不能。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expressiveWords</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &gt; str, tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                str.<span class="built_in">emplace_back</span>(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &#123;s[i], <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == str.<span class="built_in">back</span>().first)&#123;</span><br><span class="line">                str.<span class="built_in">back</span>().second++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.<span class="built_in">emplace_back</span>(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &#123;s[i], <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words)&#123;</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.<span class="built_in">empty</span>() || word[i] != tmp.<span class="built_in">back</span>().first)&#123;</span><br><span class="line">                    tmp.<span class="built_in">emplace_back</span>(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &#123;word[i], <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp.<span class="built_in">back</span>().second++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tmp.<span class="built_in">size</span>() != str.<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i].first != tmp[i].first || ((str[i].second - tmp[i].second) == <span class="number">1</span> &amp;&amp; str[i].second &lt; <span class="number">3</span>) || str[i].second - tmp[i].second &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 927. 三等分</title>
    <url>/2023/03/20/LeetCode-927-%E4%B8%89%E7%AD%89%E5%88%86/</url>
    <content><![CDATA[<h1 id="LeetCode-927-三等分"><a href="#LeetCode-927-三等分" class="headerlink" title="LeetCode 927. 三等分"></a>LeetCode 927. 三等分</h1><h1 id="927-三等分-20221006每日一题"><a href="#927-三等分-20221006每日一题" class="headerlink" title="****927. 三等分 (20221006每日一题)**"></a>****<a href="https://leetcode.cn/problems/three-equal-parts/">927. 三等分</a> (20221006每日一题)**</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/927.png" alt="Problem Description"></p>
<p>给定一个由 <code>0</code>和 <code>1</code>组成的数组 <code>arr</code> ，将数组分成  <strong>3 个非空的部分</strong>，使得所有这些部分表示相同的二进制值。</p>
<p>如果可以做到，请返回<strong>任何</strong><code>[i, j]</code>，其中 <code>i+1 &lt; j</code>，这样一来：</p>
<ul>
<li><code>arr[0], arr[1], ..., arr[i]</code> 为第一部分；</li>
<li><code>arr[i + 1], arr[i + 2], ..., arr[j - 1]</code> 为第二部分；</li>
<li><code>arr[j], arr[j + 1], ..., arr[arr.length - 1]</code> 为第三部分。</li>
<li>这三个部分所表示的二进制值相等。</li>
</ul>
<p>如果无法做到，就返回 <code>[-1, -1]</code></p>
<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。</p>
<p>这道题我将数组直接看作一个字符串，然后题目要求我们将这个字符串分成三份，这三份所形成的二进制的值要想等。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二进制的值的大小取决于该二进制中有效1的多少以及有效位数，如果有效位数越大，那么值也越大。</p>
<p>首先，我们得先确定这三部分的字符串是否可能会相等，最简单的方法就是判断1的个数，如果1的个数不是3的倍数，那么这个数组再怎么分割也不可能形成三个相等的二进制。因此我们可以先从1的个数来着手判断是否能分成三等份。</p>
<p>接下来我们将字符串分成三等份，每份中的1的个数相同，然后我们将相邻之间的0都放到前一份作为后导0，为什么这样放呢？是因为如果放到前导0毫无作用，前导0在值上面不起作用，放后导0如果值超过了，可以将后导0放到后一部分作为前导0降低二进制的值。</p>
<p>这样分完之后，我们统计三部份每份的后导0，因为最后一部分的0不能分给其他作为前导0，因此如果前两部分的后导0的个数只要有一个小于最后一份的后导0个数，那么这三等份就不可能是相等的，如果前两部分的后导0个数大于最后一份的，那么我们就将多余的0往后移作为前导0。</p>
<p>这样处理完之后，我们将每个二进制字符串的前导0删掉，这样剩下来的就是二进制的有效数，我们对比三个字符串，如果都相等，那么这个二进制数组可以三等分相等的二进制。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">threeEqualParts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; a : arr) sum += a;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>, res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> zero[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;, tmp = <span class="number">0</span>, len[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        string str[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//先把二进制根据1分配，后面的分配后导0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i])&#123;</span><br><span class="line">                tmp++;</span><br><span class="line">                <span class="keyword">if</span>(tmp == sum / <span class="number">3</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    idx++;</span><br><span class="line">                    tmp = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str[idx] += <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span> + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            len[i] = str[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = str[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i][j] == <span class="string">&#x27;0&#x27;</span>) zero[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zero[<span class="number">0</span>] &lt; zero[<span class="number">2</span>] || zero[<span class="number">1</span>] &lt; zero[<span class="number">2</span>]) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(str[i][<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) str[i].<span class="built_in">erase</span>(str[i].<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; zero[i] - zero[<span class="number">2</span>]; j++) str[i].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] != str[<span class="number">1</span>] || str[<span class="number">0</span>] != str[<span class="number">2</span>]) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = len[<span class="number">0</span>] - (zero[<span class="number">0</span>] - zero[<span class="number">2</span>]) - <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = len[<span class="number">1</span>] - (zero[<span class="number">1</span>] - zero[<span class="number">2</span>]) + len[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/927-1.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 周赛321</title>
    <url>/2023/03/20/LeetCode-%E5%91%A8%E8%B5%9B321/</url>
    <content><![CDATA[<h1 id="LeetCode-周赛321"><a href="#LeetCode-周赛321" class="headerlink" title="LeetCode 周赛321"></a>LeetCode 周赛321</h1><h1 id="6245-找出中枢整数-Easy"><a href="#6245-找出中枢整数-Easy" class="headerlink" title="6245. 找出中枢整数(Easy)"></a><strong><a href="https://leetcode.cn/problems/find-the-pivot-integer/">6245. 找出中枢整数</a>(Easy)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给你一个正整数 <code>n</code> ，找出满足下述条件的 <strong>中枢整数</strong> <code>x</code> ：</p>
<ul>
<li><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</li>
</ul>
<p>返回中枢整数 **<code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>• <code>1 &lt;= n &lt;= 1000</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>作为周赛的前三题，直接暴力做即可，并且数据范围是<code>1</code>到<code>1000</code>，那么我们只要直接遍历一遍即可</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们用两个变量来存储<code>[1,x]</code>的总和，和<code>[x,n]</code>的总和。</p>
<p>然后每向后移一位，我们就增加前缀和并在后缀和减去相应的数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotInteger</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a += i;</span><br><span class="line">            <span class="keyword">if</span>(a == b) <span class="keyword">return</span> i;</span><br><span class="line">            b -= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6246-追加字符以获得子序列-Easy"><a href="#6246-追加字符以获得子序列-Easy" class="headerlink" title="6246. 追加字符以获得子序列(Easy)"></a><strong><a href="https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/">6246. 追加字符以获得子序列</a>(Easy)</strong></h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p>
<p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p>
<p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p>
<h2 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;coaching&quot;</span>, t = <span class="string">&quot;coding&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题当时用的双指针的做法，为什么用双指针呢？因为我们要求子序列，那么我们就先求出当前t中在s的最长子序列，用双指针的做法，我们就能较快地求出这个长度。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">appendCharacters</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len1 = s.<span class="built_in">size</span>(), len2 = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len2 - j;<span class="comment">//j代表t在s中的连续最长子序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6247-从链表中移除节点-Medium"><a href="#6247-从链表中移除节点-Medium" class="headerlink" title="6247. 从链表中移除节点(Medium)"></a><strong><a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/">6247. 从链表中移除节点</a>(Medium)</strong></h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表的头节点 <code>head</code> 。</p>
<p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 <strong>严格更大</strong> 值的节点，则移除 <code>node</code> 。</p>
<p>返回修改后链表的头节点 **<code>head</code> **。</p>
<h2 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input:"></a>Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">head = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">13</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>给定列表中的节点数目在范围 <code>[1, 105]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>在打周赛的过程中，看见这道题，第一反应，链表，那么我们就可以将这个链表存储到数组中进行操作。因为函数只传入链表头，不管我们对他的操作。</p>
<p>然后题目要求我们删除<code>node</code>，如果这个<code>node</code>的右侧有比这个<code>node</code>所存储的值更大的，那么我们还一种思路，就是从后往前遍历，找到当前已遍历过的数字中的最大值，依次把它放进数组。然后根据数组里的数字开始创造目标链表。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>首先我们将链表的数依次存储到数组<code>nums</code>中，然后再根据题目的规定从后往前遍历找到对应的数字，最后再将数组里的数字组合成链表。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arrs;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= flag) &#123;</span><br><span class="line">                arrs.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                flag = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(arrs.<span class="built_in">begin</span>(), arrs.<span class="built_in">end</span>());</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arrs[<span class="number">0</span>]);</span><br><span class="line">        ListNode* tmp, *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arrs[i]);</span><br><span class="line">            p-&gt;next = tmp;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6248-统计中位数为-K-的子数组-Hard"><a href="#6248-统计中位数为-K-的子数组-Hard" class="headerlink" title="6248. 统计中位数为 K 的子数组(Hard)"></a><strong><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">6248. 统计中位数为 K 的子数组</a>(Hard)</strong></h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>
<p>统计并返回 <code>num</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。<ul>
<li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>
</ul>
</li>
<li>子数组是数组中的一个连续部分。</li>
</ul>
<h2 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input:"></a>Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output:"></a>Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 1e5</code></li>
<li><code>1 &lt;= nums[i], k &lt;= n</code></li>
<li><code>nums</code> 中的整数互不相同</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>看到数据是<code>1e5</code>，那么这道题就不能用 $O(n^2)$的时间复杂度做，所以暴力的方法行不通。</p>
<p>那么我们可以考虑到前缀和的思路，记录<code>k</code>左边和右边的数组中大于<code>k</code>和小于<code>k</code>的数分别有多少，因为<code>nums</code>中的整数互不相同，那么这个操作的存在是有意义的。在这个限制条件下，这道题的难度就大大降低了。</p>
<h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><p>首先我们得找到这个<code>k</code>的索引值<code>idx</code>，这样我们就能将整个数组分为两部分，一部分是<code>k</code>的左边，另一部分是<code>k</code>的右边。</p>
<p>然后我们用前缀和的思想，我们在<code>[idx - 1, 0]</code>统计每个数据。假设我们遍历到位置<code>index1</code>，那么我们只要统计<code>[index1, idx - 1]</code>中大于<code>k</code>的数字个数<code>a</code>和小于<code>k</code>的数字个数<code>b</code>。根据前缀和的思路，我们统计完前半部分的所有前缀和<code>a-b</code>的值的个数。</p>
<p>之后我们遍历<code>k</code>的右边，我们每遍历到一个索引<code>index2</code>，我们就记录<code>[idx + 1, index2]</code>范围内大于<code>k</code>的数字个数与小于<code>k</code>的数字个数之差x，然后根据<code>x</code>的值找到<code>k</code>值左边对应的差值的个数。因为我们要保障<code>k</code>是<code>[index1,index2]</code>的中位数，那么我们只要保证<code>[index1,index2]</code>中小于<code>k</code>的数字个数为等于大于<code>k</code>的数字个数或者小于<code>k</code>的数字个数比大于<code>k</code>的数字个数小<code>1</code>即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == k)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; k) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">            hash[a - b]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        res += hash[<span class="number">1</span>];</span><br><span class="line">        res += hash[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(auto it : hash)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; it.first &lt;&lt; &#x27; &#x27; &lt;&lt; it.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; k) x++;</span><br><span class="line">            <span class="keyword">else</span> y++;</span><br><span class="line">            <span class="comment">// if(a - b == 1) res++;</span></span><br><span class="line">            res += hash[y - x];</span><br><span class="line">            res += hash[y - x + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>双指针</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 904. 水果成篮</title>
    <url>/2023/03/20/LeetCode-904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
    <content><![CDATA[<h1 id="904-水果成篮-20221017-每日一题"><a href="#904-水果成篮-20221017-每日一题" class="headerlink" title="904. 水果成篮(20221017 每日一题)"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a>(20221017 每日一题)</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/904-1.png" alt="Problem Description"></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目给我们一个数组，让我们找到最长的子串，使得这个子串中所包含的数字种类最多只有两个。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解决这种题，简单的就是利用双指针，一个在前，一个在后，在前的指针负责往队列里加数字，如果加完数字之后发现队列里的数字种类大于两种，那么我们就用后指针来弹出队列的数字，直到队列的数字种类小于等于2。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first = <span class="number">0</span>, last = <span class="number">1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[fruits[<span class="number">0</span>]]++;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(last &lt; fruits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            hash[fruits[last]]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[fruits[last]] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, last - first);</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">while</span>(sum &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                    hash[fruits[first]]--;</span><br><span class="line">                    <span class="keyword">if</span>(hash[fruits[first]] == <span class="number">0</span>)&#123;</span><br><span class="line">                        sum--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, last - first);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/904-2.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 915.分割数组</title>
    <url>/2023/03/20/LeetCode-915-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="LeetCode-915-分割数组（Medium）"><a href="#LeetCode-915-分割数组（Medium）" class="headerlink" title="LeetCode 915.分割数组（Medium）"></a>LeetCode 915.分割数组（Medium）</h1><h1 id="915-分割数组（20221024每日一题）"><a href="#915-分割数组（20221024每日一题）" class="headerlink" title="915. 分割数组（20221024每日一题）"></a><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a>（20221024每日一题）</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/915-1.png" alt="Problem Description"></p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们将一个数组分为左右两部分，并且左半边的最大值要小于等于右半边的最小值，那么我们需要用两个数组 $b, s$来维护这个最大值喝最小值， $b[i]$代表我维护的是在<code>[1,i</code>]之间的最大值，<code>s[i]</code>代表我维护的是在<code>[i,]</code>的最小值，之后我们只要遍历一次数组，当<code>b[i]&gt;s[i + 1]</code>的时候我们就能找到我们想要找到的分界点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionDisjoint</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(len, <span class="number">0</span>)</span>, <span class="title">s</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        b[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) b[i] = <span class="built_in">max</span>(b[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">        s[len - <span class="number">1</span>] = nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) s[i] = <span class="built_in">min</span>(s[i + <span class="number">1</span>], nums[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i] &lt;= s[i + <span class="number">1</span>]) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/915-2.png" alt="Result"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 面试题17.09. 第k个数</title>
    <url>/2023/03/20/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-09-%E7%AC%ACk%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="LeetCode-面试题17-09-第k个数"><a href="#LeetCode-面试题17-09-第k个数" class="headerlink" title="LeetCode 面试题17.09. 第k个数"></a>LeetCode 面试题17.09. 第k个数</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/1709.png" alt="Problem Description"></p>
<p>这道题让我们从一个只包含质因子3，5，7数字的数组中，根据从小到大排序，获取第k个数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚开始的想法，就是根据一个优先队列，让较小的数优先弹出，但是这种做法比较麻烦的就是你的优先队列需要维护的长度是k*3，而优先队列的复杂度是O(log n)，再结合需要经过3k次的插入以及多次弹出，复杂度不够理想。</p>
<p>后面看了一个大佬的做法，利用三指针，用三个指针p3,p5,p7分别记录上次乘以质因子3、5、7的数组index，然后比较num[p3] * 3, num[p5] * 5, num[p7] * 7三者的大小，谁最小就更新哪个质因子的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *nums = <span class="keyword">new</span> <span class="type">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p3 = <span class="number">0</span>, p5 = <span class="number">0</span>, p7 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">            nums[i] = <span class="built_in">min</span>(nums[p3] * <span class="number">3</span>, <span class="built_in">min</span>(nums[p5] * <span class="number">5</span>, nums[p7] * <span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p3] * <span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[p5] * <span class="number">5</span>) p5++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[p7] * <span class="number">7</span>) p7++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个问题，当时我没有考虑到去重，这边的顺序是1,3,5,7,9,15,15,21,21,….。会有重复的数字，我们在每次比较中，要将每个最小值的质因子的指针更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *nums = <span class="keyword">new</span> <span class="type">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p3 = <span class="number">0</span>, p5 = <span class="number">0</span>, p7 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">            nums[i] = <span class="built_in">min</span>(nums[p3] * <span class="number">3</span>, <span class="built_in">min</span>(nums[p5] * <span class="number">5</span>, nums[p7] * <span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p3] * <span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p5] * <span class="number">5</span>) p5++;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[p7] * <span class="number">7</span>) p7++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>多指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ test</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>LeetCode 周赛336</title>
    <url>/2023/03/20/LeetCode-%E5%91%A8%E8%B5%9B336/</url>
    <content><![CDATA[<h1 id="LeetCode周赛336"><a href="#LeetCode周赛336" class="headerlink" title="LeetCode周赛336"></a>LeetCode周赛336</h1><h1 id="6315-统计范围内的元音字符串数-Easy"><a href="#6315-统计范围内的元音字符串数-Easy" class="headerlink" title="6315. 统计范围内的元音字符串数(Easy)"></a><strong><a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/description/">6315. 统计范围内的元音字符串数</a>(Easy)</strong></h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p>
<p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code> 。</p>
<p>返回 **<code>words[i]</code> 是元音字符串的数目，其中 **<code>i</code> 在闭区间 <code>[left, right]</code> 内。</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&quot;are&quot;</span>,<span class="string">&quot;amy&quot;</span>,<span class="string">&quot;u&quot;</span>], left = <span class="number">0</span>, right = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
<li><code>words[i]</code> 仅由小写英文字母组成</li>
<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们直接从下标为<code>left</code>的字符串遍历到下标为<code>right</code>的字符串，在遍历的时候我们需要检验每个字符串是否符合要求。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>我们先用哈希表来存储元音字母，然后检验每个字符串的开头字母和结尾字母是不是元音字母即可。</p>
<p>时间复杂度是 $O(n)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vowelStrings</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        hash[<span class="string">&#x27;e&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        hash[<span class="string">&#x27;i&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        hash[<span class="string">&#x27;o&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        hash[<span class="string">&#x27;u&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[words[i][<span class="number">0</span>]] &amp;&amp; hash[words[i].<span class="built_in">back</span>()]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6316-重排数组以得到最大前缀分数-Medium"><a href="#6316-重排数组以得到最大前缀分数-Medium" class="headerlink" title="6316. 重排数组以得到最大前缀分数(Medium)"></a><strong><a href="https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/">6316. 重排数组以得到最大前缀分数</a>(Medium)</strong></h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。你可以将 <code>nums</code> 中的元素按 <strong>任意顺序</strong> 重排（包括给定顺序）。</p>
<p>令 <code>prefix</code> 为一个数组，它包含了 <code>nums</code> 重新排列后的前缀和。换句话说，<code>prefix[i]</code> 是 <code>nums</code> 重新排列后下标从 <code>0</code> 到 <code>i</code> 的元素之和。<code>nums</code> 的 <strong>分数</strong> 是 <code>prefix</code> 数组中正整数的个数。</p>
<p>返回可以得到的最大分数</p>
<h2 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">-3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><ul>
<li><code>1 &lt;= nums.length &lt;= 1e5</code></li>
<li><code>-1e6 &lt;= nums[i] &lt;= 1e6</code></li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题让我们求前<code>n</code>个数使得这<code>n</code>个数的和大于<code>0</code>，要使得<code>n</code>最大，那么我们要保证这个和是整数，那么我们肯定希望这<code>n</code>个数里面的正数愈多越好，因此我们优先把正数放在前面。如果没有正数了，有<code>0</code>肯定优先加入<code>0</code>，这样不会影响这<code>n</code>个数之和的正负性，之后才添加负数，那么怎么添加呢？肯定不是添加最小的负数，因为你添加一个最小的负数说不定等价于添加<code>2</code>个甚至更多的负数，因此我们优先添加最大的负数，直到和变为非正数。</p>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>对数组从大到小进行排序，然后依次遍历累加直到和为非正数。注意到<code>nums[i]</code>的范围是<code>[-1e6,1e6]</code>，个数为<code>1e5</code>，所以我们要注意累加的和的变量类型，<code>1e11</code>的数是超了<code>int</code>的。</p>
<p>排序的时间复杂度为 $O(nlogn)$，累加的时间复杂度为 $O(n)$。因此总的时间复杂度为 $O(nlogn)$。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> &amp;A, <span class="type">int</span> &amp;B)&#123;</span><br><span class="line">            <span class="keyword">return</span> A &gt; B;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            tmp += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt;= <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6317-统计美丽子数组数目-Medium"><a href="#6317-统计美丽子数组数目-Medium" class="headerlink" title="6317. 统计美丽子数组数目(Medium)"></a><strong><a href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/">6317. 统计美丽子数组数目</a>(Medium)</strong></h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组<code>nums</code> 。每次操作中，你可以：</p>
<ul>
<li>选择两个满足 <code>0 &lt;= i, j &lt; nums.length</code> 的不同下标 <code>i</code> 和 <code>j</code> 。</li>
<li>选择一个非负整数 <code>k</code> ，满足 <code>nums[i]</code> 和 <code>nums[j]</code> 在二进制下的第 <code>k</code> 位（下标编号从 <strong>0</strong> 开始）是 <code>1</code> 。</li>
<li>将 <code>nums[i]</code> 和 <code>nums[j]</code> 都减去 <code>2k</code> 。</li>
</ul>
<p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code> 的数组，那么我们称它是一个 <strong>美丽</strong> 的子数组。</p>
<p>请你返回数组 <code>nums</code> 中 <strong>美丽子数组</strong> 的数目。</p>
<p>子数组是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p>
<h2 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目的意思是让我们求美丽子数组的个数，美丽子数组中的数字在二进制每一位上都是偶数，比如<code>[3,1,2]</code>中，用二进制表示是<code>[11,1,10]</code>，二进制中每一位都有两个<code>[2,2]</code>，两个<code>2</code>分别代表有<code>2</code>个 $2^1$和2个 $2^0$。因为只有个数是偶数时我们才能在删减操作使得数组中的数都为<code>0</code>，如果数组是<code>[3,1,1]</code>，二进制表示是<code>[11,1,1]</code>，二进制中每一位的表示是<code>[1,3]</code>，表示有<code>1</code>个 $2^1$和<code>3</code>个 $2^0$，这样的数组进行删减操作之后还会剩下<code>1</code>个 $2^1$和<code>1</code>个 $2^0$，得不到完美数组。</p>
<p>相当于我们要使美丽数组中的数异或和为<code>0</code>.</p>
<ul>
<li><p>异或</p>
<p>  异或的性质就是两个数相同时为<code>0</code>，不同时为<code>1</code>即</p>
<p>  0 ^ 0 &#x3D; 0</p>
<p>  1 ^ 0 &#x3D; 1</p>
<p>  0 ^ 1 &#x3D; 1</p>
<p>  1 ^ 1 &#x3D; 0</p>
</li>
</ul>
<p>那么这道题就可以转换成有多少个子数组的异或和为<code>0</code>.</p>
<h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><p>这边我是参考了前缀和的思想。</p>
<p>先用一个数组来维护从头到当前位置所有数的异或和，比如用样例给的数组<code>[4,3,1,2,4]</code>，那么他的前缀异或和就是<code>[4,7,6,4,0]</code>。记录完之后我们就要开始统计每一个异或和他在前缀异或和中出现了多少次。</p>
<p>要求美丽子数组的话我们就需要统计后面出现多少次与当前相同的异或和。为什么要找到相同的呢？比如说上面给的样例，有两个相同的异或和<code>4</code>，第一个<code>4</code>的异或和是<code>nums[0]</code>，第二个异或和是<code>nums[0]^nums[1]^nums[2]^nums[3]</code>。相同的两个数字进行异或操作之后的结果是<code>0</code>，那么<code>nums[0]^(nums[0]^nums[1]^nums[2]^nums[3])</code>之和也是<code>0</code>，<code>nums[0]^(nums[0]^nums[1]^nums[2]^nums[3])=0</code>等价于<code>nums[0]^nums[0]^nums[1]^nums[2]^nums[3]=0</code>，因为相同的数异或之后等于<code>0</code>，那么<code>nums[0]</code>可以消除，因此上面的等式等价于<code>nums[1]^nums[2]^nums[3]=0</code>，这样就有了一个美丽子数组。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long beautifulSubarrays(vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&amp;</span> nums) &#123;</span><br><span class="line">        <span class="type">int</span> len <span class="operator">=</span> nums.size();</span><br><span class="line">        vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> num(len, <span class="number">0</span>);</span><br><span class="line">        num[<span class="number">0</span>] <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> <span class="number">1</span>; i <span class="operator">&lt;</span> len; i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">            num[i] <span class="operator">=</span> num[i <span class="operator">-</span> <span class="number">1</span>] <span class="operator">^</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map<span class="operator">&lt;</span><span class="type">int</span> ,<span class="type">int</span><span class="operator">&gt;</span> hash;<span class="operator">/</span><span class="operator">/</span>记录每个异或和出现的个数</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> len; i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">            hash[num[i]]<span class="operator">+</span><span class="operator">+</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        long long res <span class="operator">=</span> hash[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> len; i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">            hash[num[i]]<span class="comment">--;//进行删减操作是为了不让前面的异或和影响到后面的累加</span></span><br><span class="line">            res <span class="operator">+</span><span class="operator">=</span> hash[num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2589-完成所有任务的最少时间-Hard"><a href="#2589-完成所有任务的最少时间-Hard" class="headerlink" title="2589. 完成所有任务的最少时间(Hard)"></a><strong><a href="https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/">2589. 完成所有任务的最少时间</a>(Hard)</strong></h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>你有一台电脑，它可以 <strong>同时</strong> 运行无数个任务。给你一个二维整数数组 <code>tasks</code> ，其中 <code>tasks[i] = [starti, endi, durationi]</code> 表示第 <code>i</code> 个任务需要在 <strong>闭区间</strong> 时间段 <code>[starti, endi]</code> 内运行 <code>durationi</code> 个整数时间点（但不需要连续）。</p>
<p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p>
<p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p>
<h2 id="Sample-3"><a href="#Sample-3" class="headerlink" title="Sample"></a>Sample</h2><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><ul>
<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>
<li><code>tasks[i].length == 3</code></li>
<li><code>1 &lt;= starti, endi &lt;= 2000</code></li>
<li><code>1 &lt;= durationi &lt;= endi - starti + 1</code></li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>参考灵神大佬说的话，像这种区间题一般都是根据右端点从小到大进行排序。</p>
<p>这道题在写的时候想到排序，但是没考虑到数据范围就没有莽上去A，不应该。看了直播回放之后自己写一次AC。</p>
<p>这道题主要是贪心的想法，我们根据排序之后区间从头开始遍历，我们每遍历一个区间的时候，我们得优先把CPU时间选在末尾，因为我们不能保障左端点之间能够有交集，但是我们能保证右端能够产生交集，而要减少CPU运行时间，交集的区间要越大越好，因此我们优先把CPU时间放在每个区间的右端。</p>
<h2 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h2><p>根据右端进行排序，然后依次遍历，我们遍历到每个区间时，先考虑这段区间之中有多少个区间已经有CPU在使用了，然后将还需要的时间划分到区间的右端，最后统计有多少时间使用CPU即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> findMinimumTime(vector<span class="operator">&lt;</span>vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;&gt;</span><span class="operator">&amp;</span> tasks) &#123;</span><br><span class="line">        sort(tasks.begin(), tasks.end(), [<span class="operator">&amp;</span>](vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>A, vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&amp;</span>B)&#123;</span><br><span class="line">            <span class="keyword">return</span> A[<span class="number">1</span>] <span class="operator">&lt;</span> B[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> f(<span class="number">2001</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len <span class="operator">=</span> tasks.size();</span><br><span class="line">        <span class="type">int</span> res <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> len; i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tmp <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j <span class="operator">=</span> tasks[i][<span class="number">0</span>]; j <span class="operator">&lt;=</span> tasks[i][<span class="number">1</span>]; j<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">                tmp <span class="operator">+</span><span class="operator">=</span> f[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp <span class="operator">&gt;=</span> tasks[i][<span class="number">2</span>]) continue;</span><br><span class="line">            tmp <span class="operator">=</span> tasks[i][<span class="number">2</span>] <span class="operator">-</span> tmp;</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> cout <span class="operator">&lt;&lt;</span> tmp <span class="operator">&lt;&lt;</span> endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j <span class="operator">=</span> tasks[i][<span class="number">1</span>]; j <span class="operator">&gt;=</span> tasks[i][<span class="number">0</span>]; j<span class="comment">--)&#123;</span></span><br><span class="line">                if(<span class="operator">!</span>f[j])&#123;</span><br><span class="line">                    f[j] <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    tmp<span class="comment">--;</span></span><br><span class="line">                    res<span class="operator">+</span><span class="operator">+</span>;</span><br><span class="line">                    if(<span class="operator">!</span>tmp) break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>周赛</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器 接雨水</title>
    <url>/2023/03/20/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="盛最多水的容器-接雨水"><a href="#盛最多水的容器-接雨水" class="headerlink" title="盛最多水的容器 接雨水"></a>盛最多水的容器 接雨水</h1><h1 id="11-盛最多水的容器-Medium"><a href="#11-盛最多水的容器-Medium" class="headerlink" title="11. 盛最多水的容器(Medium)"></a><strong><a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器</a>(Medium)</strong></h1><p>这道题的双指针刚开始用着很迷茫，因为不知道怎么验证这个双指针的正确性，然后我在题解中找到了一篇有关他的<a href="https://leetcode.cn/problems/container-with-most-water/solutions/11491/container-with-most-water-shuang-zhi-zhen-fa-yi-do/">正确性验证</a>。大佬讲的很细致！</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/lcsszz.png"></p>
<p>这道题用的双指针做法，我们用两个指针来表示区间的一头一尾，比较头尾指针的挡板高度之后再决定调整哪块挡板。调整的时候我们会消去一些状态，之前我就一直迷惑万一这些状态会不会有隐藏最大值，但是通过上面的证明的时候我才解开疑惑。每次更新头尾指针之后消去的状态他们所包含的最大值肯定是小于等于当前状态的，比如上面图片中因为S(i,j)→S(i+1,j)而消去的S(i,j-1),S(i,j-2),…,S(i,i+1)，他们所表示的面积时小于S(i,j)的，因为他们的短板要么是h[i],如果不是h[i]那就说明短板比h[i]更小，那么决定面积的短板高度因素就能排除在外了，之后再看底边宽度，因为原来的宽度时j-i，而后面的底边宽度范围时[1,j-i-1]，两者都比S(i,j)要小，因此S(i,j-1),S(i,j-2),…,S(i,i+1)这些都是小于S(i,j)的，我们最后只要比较S(i,j)和其他组合的比较即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> maxArea(vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&amp;</span> height) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">left</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">right</span> <span class="operator">=</span> height.size() <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        while(<span class="keyword">right</span> <span class="operator">&gt;</span> <span class="keyword">left</span>)&#123;</span><br><span class="line">            res <span class="operator">=</span> <span class="built_in">max</span>(res, (<span class="keyword">right</span> <span class="operator">-</span> <span class="keyword">left</span>) <span class="operator">*</span> <span class="built_in">min</span>(height[<span class="keyword">right</span>], height[<span class="keyword">left</span>]));</span><br><span class="line">            if(height[<span class="keyword">right</span>] <span class="operator">&lt;</span> height[<span class="keyword">left</span>]) <span class="keyword">right</span><span class="comment">--;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">left</span><span class="operator">+</span><span class="operator">+</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="42-接雨水-Hard"><a href="#42-接雨水-Hard" class="headerlink" title="42. 接雨水(Hard)"></a><strong><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水</a>(Hard)</strong></h1><p>这道题有两种做法，一种就是前后缀，另一种是双指针。</p>
<h2 id="前后缀"><a href="#前后缀" class="headerlink" title="前后缀"></a>前后缀</h2><p>这里的前缀是指从头往后当前遇到的最高的高度，比如说如果高度数组是<code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>，那么前缀数组就是<code>[0,1,1,2,2,2,2,3,3,3,3,3]</code>，这个数组中的数字代表从起始点到当前点所遇到的圆柱最高点，后缀数组是<code>[3,3,3,3,3,3,3,3,2,2,2,1]</code>，这两个数组有什么作用呢？我们根据索引依次遍历数组，当遍历到索引为<code>0</code>的时候，前缀数组是<code>0</code>，后缀数组是<code>3</code>，根据短板原理，我们这时只能取到<code>0</code>，当遍历到索引为<code>6</code>时，前缀数组是<code>2</code>，后缀数组是<code>3</code>，这时候根据短板原理水深应该是<code>2</code>，但是这个索引下高度本身就是<code>1</code>，那么水深就是<code>1</code>.根据这个思想我们统计所有索引值下的水深。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> height_len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!height_len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; max_left, max_right;</span><br><span class="line">        max_left.<span class="built_in">emplace_back</span>(height[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; height_len; i++)&#123;</span><br><span class="line">            max_left.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(height[i], max_left[i - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        max_right.<span class="built_in">emplace_back</span>(height[height_len - <span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = height_len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            max_right.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(height[i], max_right[k++]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; height_len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(max_left[i], max_right[height_len - i - <span class="number">1</span>]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h2><p>这里的思想就和上面的盛最多的水一样，都是增加短板，慢慢更新。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, pre_max = <span class="number">0</span>, suf_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            pre_max = <span class="built_in">max</span>(pre_max, height[left]);</span><br><span class="line">            suf_max = <span class="built_in">max</span>(suf_max, height[right]);</span><br><span class="line">            ans += pre_max &lt; suf_max ? pre_max - height[left++] : suf_max - height[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和 三数之和</title>
    <url>/2023/03/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和-三数之和"><a href="#两数之和-三数之和" class="headerlink" title="两数之和 三数之和"></a>两数之和 三数之和</h1><h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><strong><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组</a></strong></h1><p>双指针的具体原理可以看<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solutions/87919/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/">大佬的题解</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] == target)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = left + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = right + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><strong><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></strong></h1><p>这道题就是让我们求在给定数组中是否有两个数之和等于第三个数</p>
<p>一般做法是嵌套三层for循环分别来代表a,b,c三个数然后求得有多少个abc三元组。这样的时间复杂度为 $O(n^3)$，当n很大时是不理想的。这个时候我们就要换一种思路。</p>
<p>为了方便后面的操作，我们先对数组进行排序。</p>
<p>然后从头往后遍历，每次遍历时先确定三元组中的一个数，另外两个数就在该数的后面选。选后面两个数的操作就不用嵌套两层for循环，而是使用双指针的方法，双指针分别指针可选数范围的一头一尾，然后要使得双指针所指的数之和等于一个定值。这样我们就把问题转换成了上面的题目**.** 之后我们只需要保证不会有重复即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">3</span>, <span class="number">100001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp[<span class="number">0</span>] = nums[i];</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] + nums[right] == <span class="number">0</span> - nums[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tmp[<span class="number">1</span>] == nums[left] &amp;&amp; tmp[<span class="number">2</span>] == nums[right]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        tmp[<span class="number">1</span>] = nums[left];</span><br><span class="line">                        tmp[<span class="number">2</span>] = nums[right];</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &gt; <span class="number">0</span> - nums[i]) right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 811. 子域名访问计数</title>
    <url>/2023/03/20/LeetCode-811-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="LeetCode-811-子域名访问计数"><a href="#LeetCode-811-子域名访问计数" class="headerlink" title="LeetCode 811. 子域名访问计数"></a>LeetCode 811. 子域名访问计数</h1><h1 id="811-子域名访问计数-20221005每日一题"><a href="#811-子域名访问计数-20221005每日一题" class="headerlink" title="****811. 子域名访问计数(20221005每日一题)**"></a>****<a href="https://leetcode.cn/problems/subdomain-visit-count/">811. 子域名访问计数</a>(20221005每日一题)**</h1><p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/811.png" alt="ProblemDescription"></p>
<p>网站域名 “<a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“ 由多个子域名组成。顶级域名为 “com” ，二级域名为 “<a href="http://leetcode.com/">leetcode.com</a>“ ，最低一级为 “<a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“。当访问域名 <code>&quot;discuss.leetcode.com&quot;</code>时，同时也会隐式访问其父域名 <code>&quot;leetcode.com&quot;</code> 以及 <code>&quot;com&quot;</code>。</p>
<p>计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。</p>
<p>例如，”9001 <a href="http://discuss.leetcode.com/">discuss.leetcode.com</a>“ 就是一个 计数配对域名 ，表示 <a href="http://discuss.leetcode.com/">discuss.leetcode.com</a> 被访问了 9001 次。</p>
<p>给你一个 <strong>计数配对域名</strong> 组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的 <strong>计数配对域名</strong>，并以数组形式返回。可以按 <strong>任意顺序</strong>返回答案。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们需要获得所有的域名以及他们的子域名，这个时候我们最好的想法就是用一个hash来存储所有出现过的域名，如果用其他方法不太现实。用hash来存储时我们不仅要考虑到出现的域名，我们还要考虑到这些域名出现的次数。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>对于每个字符串，首先，我们先正序遍历，找到这个网站出现的个数，然后再逆序遍历找到所有的子域名，找完所有的子域名之后记录每个子域名在当前情况下访问了几次，然后通过hash表进行累加。最后我们遍历hash表获取所有的域名以及他们的访问次数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    vector&lt;string&gt; <span class="title function_">subdomainVisits</span>(<span class="params">vector&lt;string&gt;&amp; cpdomains</span>) &#123;</span><br><span class="line">        unordered_map&lt;string, int&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(auto c : cpdomains)&#123;</span><br><span class="line">            int i = <span class="number">0</span>;</span><br><span class="line">            string num;</span><br><span class="line">						<span class="comment">//统计访问次数</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; c.<span class="title function_">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">                num += c[i];</span><br><span class="line">            &#125;</span><br><span class="line">            int times = <span class="title function_">stoi</span>(num);</span><br><span class="line">            string com;</span><br><span class="line">						<span class="comment">//统计域名</span></span><br><span class="line">            <span class="keyword">for</span>(int j = c.<span class="title function_">size</span>() - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    hash[com] += times;</span><br><span class="line">                &#125;</span><br><span class="line">                com = c[j] + com;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[com] += times;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">				<span class="comment">//遍历hash表获取每个子域名以及访问次数</span></span><br><span class="line">        <span class="keyword">for</span>(auto ha : hash)&#123;</span><br><span class="line">            string t = <span class="title function_">to_string</span>(ha.<span class="property">second</span>) + <span class="string">&#x27; &#x27;</span> + ha.<span class="property">first</span>;</span><br><span class="line">            res.<span class="title function_">emplace_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2023/03/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>变种的二分查找主要分为区间变种和范围变种</p>
<p>区间变种主要是[],(),[)</p>
<p>范围变种主要是≥,&gt;,≤,&lt;</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/bs.png"></p>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><strong><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置</a></strong></h1><p>这道题我原来的做法是先在数组中找到这个元素的位置，然后往前往后寻找两个端点，这样的时间复杂度是$O(n)$,比较耗时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>())    <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)    <span class="keyword">return</span> res;</span><br><span class="line">        right = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        left = right;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == target)left--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] == target)right++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后面看了灵神的视频，发现可以使用两次二分查找即可。</p>
<p>在找起始位置时我们只要保证l前面的数都是小于target的，找末置位时我们只要保证r后面的都大于target即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == nums.<span class="built_in">size</span>() || nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = left;</span><br><span class="line">        left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>同向双指针 滑动窗口</title>
    <url>/2023/03/17/%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="同向双指针-滑动窗口"><a href="#同向双指针-滑动窗口" class="headerlink" title="同向双指针 滑动窗口"></a>同向双指针 滑动窗口</h1><h1 id="209-长度最小的子数组-Medium"><a href="#209-长度最小的子数组-Medium" class="headerlink" title="209. 长度最小的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>(Medium)</strong></h1><p>这道题的目标是在给定数组上求最短连续数组的和大于给定的k值</p>
<p>一般思路：用两个for循环来遍历所有可能的子串和，这种方法的时间复杂度是 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">				<span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">				<span class="type">int</span> res = len;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">					<span class="type">int</span> tmp = nums[i];</span><br><span class="line">					<span class="keyword">if</span>(tmp &gt;= target) len = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">						tmp += nums[j];</span><br><span class="line">						<span class="keyword">if</span>(tmp &gt;= target) &#123;</span><br><span class="line">							len = <span class="built_in">min</span>(len, j - i + <span class="number">1</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法就是使用双指针，之前我们用到的双指针一般都是指向一头一尾，然后通过不断向中间位移来压缩长度。</p>
<p>这道题的双指针是同向双指针，类似于队列的头指针和尾指针。我们先移动头指针，直到头指针和尾指针之间的数之和大于等于给定值。当和大于等于给定值时，我们就开始移动尾指针，知道头指针和尾指针之间的数之和小于给定值，在移动尾指针的时候我们要实时更新最短长度，这个最短长度就是头指针和尾指针的距离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(i - idx, res);</span><br><span class="line">                idx++;</span><br><span class="line">                sum -= nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == nums.<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="713-乘积小于-K-的子数组-Medium"><a href="#713-乘积小于-K-的子数组-Medium" class="headerlink" title="713. 乘积小于 K 的子数组(Medium)"></a><strong><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a>(Medium)</strong></h1><p>这道题和上面类似，只不过上面是求最大的长度，这里是要枚举数量。</p>
<p>但是No.713和No.209类似，都是需要用到双指针，而且是同向双指针，双指针维护的是双指针之间的乘积。</p>
<p>那么重点来了，双指针维护的是乘积，我们怎么获取个数呢？因为双指针之间的数的乘积是小于K的，当他大于K时，我们也只要更新左指针来保证双指针之间的数的乘积小于K。从这我们可以看出双指针的右指针在一次操作中是不动的，那么我们就可以在每次确立右指针之后，查看是否要更新左指针，之后我们在这个双指针的基础上，以右指针为数组的右端点，枚举左端点，查看最后有多少个以右指针为数组端点的子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum *= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= k &amp;&amp; idx &lt; i) sum /= nums[++idx];</span><br><span class="line">            res += (i - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-无重复字符的最长子串-Meduim"><a href="#3-无重复字符的最长子串-Meduim" class="headerlink" title="3. 无重复字符的最长子串[Meduim]"></a><strong><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>[Meduim]</strong></h1><p>这道题利用双指针怎么做呢？</p>
<p>我们利用同向双指针，右指针每往右移一个时，我们判断这个新加入的元素在左右指针中是否已经出现过。如果没出现过，那么我们就继续右移右指针，如果出现过，那么我们就要开始移动左指针，直到左右指针之间的所有元素都只出现一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash[s[i]])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - idx);</span><br><span class="line">                hash[s[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(s[++idx] != s[i])&#123;</span><br><span class="line">                    hash[s[idx]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，同向双指针重要的是维护双指针之间的数，如果满足条件，一般移动右指针，当不满足时，右移左指针。</p>
<p>一般操作：</p>
<ol>
<li>右移右指针直到末尾</li>
<li>判断左右指针之间的数是否满足条件<ol>
<li>如果满足，回到步骤1</li>
<li>如果不满足，移动左指针，回到步骤2</li>
</ol>
</li>
<li>结束</li>
</ol>
]]></content>
      <categories>
        <category>灵茶山艾府学习笔记</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
