---
title: 删除链表重复节点
categories:
  - 灵茶山艾府学习笔记
tags:
  - 链表
abbrlink: 3ab82e9f
date: 2023-03-28 13:04:05
---

## **[237.删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/description/)**

题目让我们删除提供的节点，但是我们不知道这个节点的前面位置，那应该怎么删除呢？我们看到这个链表的标识是`val`值，那么我们可以把要删除的后面的节点的值移到要删除的节点，再删除后面这个节点，返回的链表的`val`值顺序是不变的，只是地址会有不同。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        if(node->next == NULL) {
            delete node;
            return;
        }
        ListNode *root = node->next;
        node->val = root->val;
        node->next = root->next;
        delete root;
    }
};
```

## **[19.删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)**

这道题我原本想的是先跑一遍看这个链表的长度是多少，但是有一个更巧妙的方法

我不是要找到倒数第`N`个节点嘛，那我先让节点往前位移`N`个节点，再让一个新的指针从头出发，这样先出发的节点到达终点的时候，后一个出发的指针刚好指向倒数第`N`个节点，再删除那个节点即可。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* root = new ListNode(0, head), *p = root;
        int e = -1;
        while(head){
            head = head->next;
            e++;
            if(e >= n) p = p->next;
        }
        ListNode* q = p->next;
        p->next = p->next->next;
        delete q;
        return root->next;
    }
};
```

## **[83.删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)**

我们从头开始遍历，用一个变量来记录上一个节点的数，如果相同，则删除当前节点，如果不同，更新变量并移动指针到下一个节点。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head == NULL) return head;
        ListNode* root = new ListNode(0, head), *p = head;
        int val = head->val;
        while(head->next){
            head = head->next;
            if(head->val == val){
                p->next = head->next;
                delete head;
                head = p;
            }else{
                val = head->val;
                p = head;
            }
        }
        return root->next;
    }
};
```

## **[82.删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/)**

这道题我们只要记录要删除链表的起点的上一个节点`prev`和终点的下一个节点`next`就可以了，因此我们要实时维护`prev`指针的位置

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return head;
        ListNode *root = new ListNode(0, head), *p = root, *q = root, *t = root;
        int val = head->val;
        while(head->next){
            t = head;
            head = head->next;
            if(head->val != val){
                val = head->val;
                p = t;
            }else{
                while(head && head->val == val) head = head->next;
                p->next = head;
                while(t != head){
                    q = t;
                    t = t->next;
                    delete q;
                }
                if(head == NULL) break;
                val = head->val;
            }
        }
        return root->next;
    }
};
```