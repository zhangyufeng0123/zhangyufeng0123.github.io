---
title: 同向双指针 滑动窗口
categories:
  - 灵茶山艾府学习笔记
tags:
  - 双指针
abbrlink: 137e18a2
date: 2023-03-17 19:57:20
---
# 同向双指针 滑动窗口

# **[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)(Medium)**

这道题的目标是在给定数组上求最短连续数组的和大于给定的k值

一般思路：用两个for循环来遍历所有可能的子串和，这种方法的时间复杂度是 $O(n^2)$

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
				int len = nums.size();
				int res = len;
				for(int i = 0; i < len; i++){
					int tmp = nums[i];
					if(tmp >= target) len = 1;
					for(int j = i + 1; j < len; j++){
						tmp += nums[j];
						if(tmp >= target) {
							len = min(len, j - i + 1);
						}
					}
				}
		}
		return res;
}
```

另一种方法就是使用双指针，之前我们用到的双指针一般都是指向一头一尾，然后通过不断向中间位移来压缩长度。

这道题的双指针是同向双指针，类似于队列的头指针和尾指针。我们先移动头指针，直到头指针和尾指针之间的数之和大于等于给定值。当和大于等于给定值时，我们就开始移动尾指针，知道头指针和尾指针之间的数之和小于给定值，在移动尾指针的时候我们要实时更新最短长度，这个最短长度就是头指针和尾指针的距离。

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = nums.size() + 1;
        int idx = -1, sum = 0;
        for(int i = 0; i < nums.size(); i++){
            sum += nums[i];
            while(sum >= target){
                res = min(i - idx, res);
                idx++;
                sum -= nums[idx];
            }
        }
        if(res == nums.size() + 1) return 0;
        return res;
    }
};
```

# **[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)(Medium)**

这道题和上面类似，只不过上面是求最大的长度，这里是要枚举数量。

但是No.713和No.209类似，都是需要用到双指针，而且是同向双指针，双指针维护的是双指针之间的乘积。

那么重点来了，双指针维护的是乘积，我们怎么获取个数呢？因为双指针之间的数的乘积是小于K的，当他大于K时，我们也只要更新左指针来保证双指针之间的数的乘积小于K。从这我们可以看出双指针的右指针在一次操作中是不动的，那么我们就可以在每次确立右指针之后，查看是否要更新左指针，之后我们在这个双指针的基础上，以右指针为数组的右端点，枚举左端点，查看最后有多少个以右指针为数组端点的子数组。

```cpp
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int res = 0;
        int idx = -1, sum = 1;
        for(int i = 0; i < nums.size(); i++){
            sum *= nums[i];
            while(sum >= k && idx < i) sum /= nums[++idx];
            res += (i - idx);
        }
        return res;
    }
};
```

# **[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)[Meduim]**

这道题利用双指针怎么做呢？

我们利用同向双指针，右指针每往右移一个时，我们判断这个新加入的元素在左右指针中是否已经出现过。如果没出现过，那么我们就继续右移右指针，如果出现过，那么我们就要开始移动左指针，直到左右指针之间的所有元素都只出现一次。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> hash;
        int res = 0, idx = -1;
        for(int i = 0; i < s.size(); i++){
            if(!hash[s[i]]){
                res = max(res, i - idx);
                hash[s[i]] = 1;
            }else{
                while(s[++idx] != s[i]){
                    hash[s[idx]] = 0;
                }
            }
        }
        return res;
    }
};
```

# 总结

总的来说，同向双指针重要的是维护双指针之间的数，如果满足条件，一般移动右指针，当不满足时，右移左指针。

一般操作：

1. 右移右指针直到末尾
2. 判断左右指针之间的数是否满足条件
    1. 如果满足，回到步骤1
    2. 如果不满足，移动左指针，回到步骤2
3. 结束