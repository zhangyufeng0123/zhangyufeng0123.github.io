---
title: 二叉树公共祖先
categories:
  - 灵茶山艾府学习笔记
tags:
  - 二叉树
  - 递归
abbrlink: ee93e3cf
date: 2023-04-01 21:43:20
---
# 二叉树公共祖先

对于这种题，我们首先得明确一点。

> 什么是公共祖先？
> 

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：”对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**
）。“

# **[236.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)**

对于这一题，题目提供了一个二叉树以及两个节点。这里有几个特殊样例，如果`root`刚好等于`q`或者`root`刚好等于`q`，那么直接返回`root`即可，因为这个时候`root`就刚好是最近公共祖先，如果`root`为空，那么就返回空。

如果不是，那么我们就要递归遍历左右子树。

在每一轮的遍历中，我们根据左右子树返回的节点是否为空做了以下几个判断：

1. 如果`root`的左子树和右子树都不为空，说明左右子树各有一个目标节点，那么`p`和`q`的最近公共祖先就是`root`
2. 如果`root`的左子树为空，那么说明两个目标节点都在右子树上，那么我们就直接返回右子树给我们的最近公共祖先的节点即可
3. 如果`root`的右子树为空，那么说明两个目标节点都在左子树上，那么我们就直接返回左子树给我们的最近公共祖先的节点即可
4. 如果`root`的左右子树都为空，直接返回空即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left && right) return root;
        else if(left) return left;
        else if(right) return right;
        else return NULL;
    }
};
```

# **[235.二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)**

这道题相比于上一题有一个好处，那就是可以进行剪枝，我们可以根据二叉搜索树的特性来减少不必要的搜索。

二叉搜索树的特性能够帮我们判断`p`、`q`节点在`root`节点的哪个子树上。

如果`root`节点的值大于`p`、`q`节点的值，那么就只要递归右子树即可，因为`p`和`q`都只能在`root`的右子树，这样我们就节省了递归左子树的开销。

如果`root`节点的值小于`p`、`q`节点的值，那么就只要递归左子树即可，因为`p`和`q`都只能在`root`的左子树，这样我们就节省了递归右子树的开销。

如果`root`节点的值小于`p`、`q`中的一个，大于另外一个，这就说明`p`、`q`两个节点在`root`节点的左右两边，这种情况我们直接返回`root`节点即可。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL || root == p || root == q) return root;
        if(root->val > p->val && root->val > q->val){
            return lowestCommonAncestor(root->left, p, q);
        }else if(root->val < p->val && root->val < q->val){
            return lowestCommonAncestor(root->right, p, q);
        }else {
            return root;
        }
    }
};
```