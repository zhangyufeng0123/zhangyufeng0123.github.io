---
title: 盛最多水的容器 接雨水
categories:
  - 灵茶山艾府学习笔记
tags:
  - 双指针
abbrlink: a055a13d
date: 2023-03-20 15:22:47
---
# 盛最多水的容器 接雨水

# **[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)(Medium)**

这道题的双指针刚开始用着很迷茫，因为不知道怎么验证这个双指针的正确性，然后我在题解中找到了一篇有关他的[正确性验证](https://leetcode.cn/problems/container-with-most-water/solutions/11491/container-with-most-water-shuang-zhi-zhen-fa-yi-do/)。大佬讲的很细致！

![](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/lcsszz.png)

这道题用的双指针做法，我们用两个指针来表示区间的一头一尾，比较头尾指针的挡板高度之后再决定调整哪块挡板。调整的时候我们会消去一些状态，之前我就一直迷惑万一这些状态会不会有隐藏最大值，但是通过上面的证明的时候我才解开疑惑。每次更新头尾指针之后消去的状态他们所包含的最大值肯定是小于等于当前状态的，比如上面图片中因为S(i,j)→S(i+1,j)而消去的S(i,j-1),S(i,j-2),…,S(i,i+1)，他们所表示的面积时小于S(i,j)的，因为他们的短板要么是h[i],如果不是h[i]那就说明短板比h[i]更小，那么决定面积的短板高度因素就能排除在外了，之后再看底边宽度，因为原来的宽度时j-i，而后面的底边宽度范围时[1,j-i-1]，两者都比S(i,j)要小，因此S(i,j-1),S(i,j-2),…,S(i,i+1)这些都是小于S(i,j)的，我们最后只要比较S(i,j)和其他组合的比较即可。

## 代码

```sql
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int res = 0;
        while(right > left){
            res = max(res, (right - left) * min(height[right], height[left]));
            if(height[right] < height[left]) right--;
            else left++;
        }
        return res;
    }
};
```

# **[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)(Hard)**

这道题有两种做法，一种就是前后缀，另一种是双指针。

## 前后缀

这里的前缀是指从头往后当前遇到的最高的高度，比如说如果高度数组是`[0,1,0,2,1,0,1,3,2,1,2,1]`，那么前缀数组就是`[0,1,1,2,2,2,2,3,3,3,3,3]`，这个数组中的数字代表从起始点到当前点所遇到的圆柱最高点，后缀数组是`[3,3,3,3,3,3,3,3,2,2,2,1]`，这两个数组有什么作用呢？我们根据索引依次遍历数组，当遍历到索引为`0`的时候，前缀数组是`0`，后缀数组是`3`，根据短板原理，我们这时只能取到`0`，当遍历到索引为`6`时，前缀数组是`2`，后缀数组是`3`，这时候根据短板原理水深应该是`2`，但是这个索引下高度本身就是`1`，那么水深就是`1`.根据这个思想我们统计所有索引值下的水深。

### 代码

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int height_len = height.size();
        if(!height_len){
            return 0;
        }
        vector<int> max_left, max_right;
        max_left.emplace_back(height[0]);
        for(int i = 1; i < height_len; i++){
            max_left.emplace_back(max(height[i], max_left[i - 1]));
        }
        max_right.emplace_back(height[height_len - 1]);
        int k = 0;
        for(int i = height_len - 2; i >= 0; i--){
            max_right.emplace_back(max(height[i], max_right[k++]));
        }
        for(int i = 1; i < height_len - 1; i++){
            ans += min(max_left[i], max_right[height_len - i - 1]) - height[i];
        }
        return ans;
    }
};
```

## 相向双指针

这里的思想就和上面的盛最多的水一样，都是增加短板，慢慢更新。

### 代码

```cpp
class Solution {
public:
    int trap(vector<int> &height) {
        int ans = 0, left = 0, right = height.size() - 1, pre_max = 0, suf_max = 0;
        while (left <= right) {
            pre_max = max(pre_max, height[left]);
            suf_max = max(suf_max, height[right]);
            ans += pre_max < suf_max ? pre_max - height[left++] : suf_max - height[right--];
        }
        return ans;
    }
};
```