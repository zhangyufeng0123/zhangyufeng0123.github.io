---
title: 反转链表
categories:
  - 灵茶山艾府学习笔记
tags:
  - 链表
abbrlink: 82b7a1a9
date: 2023-03-25 15:14:24
---

## **[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)**

最暴力的方法就是先将链表中的所有节点都拆分下来，再一一安装上去，但是这样我们需要扫两遍。

有更简单的方法。

传入的是这样的一个链表

![https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325141342.png](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325141342.png)

我们要想反转链表，我们得需要额外的指针来指着当前节点的前面一个，以及该节点的`next`应该指着的位置。我们用`t`来表示当前节点的后面的位置，末尾的`next`指针指着`null`的位置，所以我们把`t`设置为`null`

![https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325141803.png](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325141803.png)

在每次循环中，我们要先移动`head`的位置，以防止改变`head`的`next`指针后`head`后面的位置访问不到。

![https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325142503.png](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325142503.png)

![https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325151238.png](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230325151238.png)

这样我们就能保证能够找到前后节点了，下次反转的时候我们先将`t`指向`root`再将`root`指向的内容变为`head`指向的内容，再将`head`往后移动一位，再将`root`的`next`指针指向`t`。

这样反复直到`head`指向`null`。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        ListNode *t = NULL, *ans = head;
        while(head){
            head = head->next;
            ans->next = t;
            t = ans;
            ans = head;
        }
        return t;
    }
};
```

## **[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)**

这道题我的做法就是利用上面的方法，我们将要反转的链表范围截取下来放到上面问题的反转链表中进行操作，最后将三段链表合并即可。

一整个链表被我拆分成了三段：

[head,prev],[left,right],[tail,NULL]

其中关系是`prev->next = left, right->next = tail.`

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){
        ListNode* root = head, *t = NULL;
        while(head){
            head = head->next;
            root->next = t;
            t = root;
            root = head;
        }
        return t;
    }

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == right) return head;
        ListNode* root = new ListNode(0, head);
        int i = 1;
        ListNode* prev = root;
        while(i < left){
            i++;
            prev = prev->next;
        }
        ListNode* tail = prev, *p = prev;
        while(i <= right + 1){
            p = tail;
            tail = tail->next;
            i++;
        }
        p->next = NULL;
        prev->next = reverseList(prev->next);
        while(prev->next) prev = prev->next;
        prev->next = tail;
        return root->next;
    }
};
```

## **[25.K个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)**

发现只要掌握第一个问题之后，后面的问题都能够依靠第一个问题的方法来解决。

这一题我每找到k个节点我就分割链表，将要反转的链表放入第一个问题中的解决函数，然后将返回的链表重新连接起来。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){
        ListNode* ans = head, *t = NULL;
        while(head != NULL){
            head = head->next;
            ans->next = t;
            t = ans;
            ans = head;
        }
        return t;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        if(k == 1) return head;
        ListNode* root = new ListNode(0, head);
        ListNode* prev = root, *tail = NULL;
        int i = 1;
        while(head != NULL){
            head = head->next;
            i++;
            if(i % k == 0){
                if(head == NULL) continue;
                tail = head->next;
                head->next = NULL;
                prev->next = reverseList(prev->next);
                while(prev->next) prev = prev->next;
                prev->next = tail;
                head = prev;
            }
        }
        
        return root->next;
    }
};
```