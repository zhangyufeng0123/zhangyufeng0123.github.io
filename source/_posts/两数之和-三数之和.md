---
title: 两数之和 三数之和
categories:
  - 灵茶山艾府学习笔记
tags:
  - 双指针
abbrlink: 34f50de6
date: 2023-03-20 15:21:24
---
# 两数之和 三数之和

# **[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)**

双指针的具体原理可以看[大佬的题解](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solutions/87919/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/)。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        vector<int> res(2, 0);
        while(left < right){
            if(numbers[left] + numbers[right] == target){
                res[0] = left + 1;
                res[1] = right + 1;
                return res;
            }else if(numbers[left] + numbers[right] < target) left++;
            else right--;
        }
        return res;
    }
};
```

# **[15. 三数之和](https://leetcode.cn/problems/3sum/)**

这道题就是让我们求在给定数组中是否有两个数之和等于第三个数

一般做法是嵌套三层for循环分别来代表a,b,c三个数然后求得有多少个abc三元组。这样的时间复杂度为 $O(n^3)$，当n很大时是不理想的。这个时候我们就要换一种思路。

为了方便后面的操作，我们先对数组进行排序。

然后从头往后遍历，每次遍历时先确定三元组中的一个数，另外两个数就在该数的后面选。选后面两个数的操作就不用嵌套两层for循环，而是使用双指针的方法，双指针分别指针可选数范围的一头一尾，然后要使得双指针所指的数之和等于一个定值。这样我们就把问题转换成了上面的题目**.** 之后我们只需要保证不会有重复即可。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> tmp(3, 100001);
        for(int i = 0; i < nums.size(); i++){
            if(i && nums[i] == nums[i - 1]) continue;
            tmp[0] = nums[i];
            int left = i + 1, right = nums.size() - 1;
            while(left < right){
                if(nums[left] + nums[right] == 0 - nums[i]){
                    if(tmp[1] == nums[left] && tmp[2] == nums[right]) {
                        left++;
                        right--;
                    }else{
                        tmp[1] = nums[left];
                        tmp[2] = nums[right];
                        res.emplace_back(tmp);
                        left++;
                        right--;
                    }
                }else if(nums[left] + nums[right] > 0 - nums[i]) right--;
                else left++;
            }
        }
        return res;
    }
};
```