---
title: 搜索旋转数组
categories:
  - 灵茶山艾府学习笔记
tags:
  - 二分查找
abbrlink: c5ac4b34
date: 2023-03-23 14:57:11
---

# [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/description/)

根据之前灵神对于二分的理解，我们可以这样理解二分，**把整个数组看成一个着色区间，其中红色代表不可能存在峰顶的区间，蓝色代表峰顶及其右边**；

那么我们的范围是`[0,n-2]`，为什么呢？因为最后一位要么是峰顶要么在峰顶的右侧，因此最后一个位置的颜色就是蓝色。

刚开始我们是不知道`[0,n-2]`这个区间的颜色，因此我们要用开区间来写，那么开区间的范围就是`(-1, n-1)`，其中`-1`位置是红色，`n-1`位置是蓝色(为了区分才区分红蓝色，其实这两个位置在搜索中是没有的)。

那么我们定好区间之后，就开始确定`check`方法，我们在取到中间值`mid`之后，如果`nums[mid]>nums[mid+1]`，那么说明`mid`要么是峰值，要么在峰值的右侧，因此我们可以把`[mid,right]`之间都着色蓝色。反之，说明`mid`在峰值的左侧，因此我们把区间`[left,mid]`着色红色。最后我们获取`right`位置上的索引，因为`right`及其右边是峰值及其右侧。

```sql
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = -1, right = nums.size() - 1;
        while(left  + 1 < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[mid + 1]){
                right = mid;
            }else{
                left = mid;
            }
        }
        return right;
    }
};
```

# **[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)**

这道题其实和上面一题一样，都是找峰值，只不过上面找的是峰顶，这里找的是峰底。

```sql
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1, right = nums.size() - 1;
        while(left + 1 < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[right]){
                left = mid;
            }else{
                right = mid;
            }
        }
        return nums[right];
    }
};
```

# **[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)**

有两种做法：

一种是根据这个旋转排序数组的性质将数组分为两段有序数组，然后在有序数组中寻找到`target`，但是这样就需要用到两次二分

另一种是直接寻找，但是要根据这个旋转排序数组的性质来判断红蓝区域。

我们只讨论右边为蓝的情况

第一种，`mid`在右侧递增位，这个时候我们要想右边为蓝色区域，那就需要判断`target`在左侧。左侧分为两个有序数组，所以我们要分两种情况

![](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323145043.png)

第一种情况就是`target`在最初的两个有序数组的左边的数组，这个时候我们只要保证`target > nums.back()`即可。

![](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323145304.png)

第二种情况就是`target`在灰色数组的左侧，这个时候我们只要保证`target < nums[mid]`即可。

还有另外一种情况，即`mid`的位置是蓝色数组的情况，这个时候我们要想让左边的区域是蓝色，那就得让`target`在左侧的蓝色数组内。

![](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323145525.png)

这种情况我们只需要判断`target`是否在`[nums.back(),mid]`之间即可。

```cpp
class Solution {
public:
    bool check(vector<int> &nums, int target, int mid){
        if(nums[mid] > nums.back()){
            return nums.back() < target && target <= nums[mid];
        }else{
            return target <= nums[mid] || target > nums.back();
        }
    }

    int search(vector<int>& nums, int target) {
        int left = -1, right = (int)(nums.size());
        while(left + 1 < right){
            int mid = (left + right) >> 1;
            if(check(nums, target, mid)){
                right = mid;
            }else{
                left = mid;
            }
        }
        // cout << right << endl;
        if(right == (int)nums.size() || nums[right] != target) return -1;
        return right;
    }
};
```