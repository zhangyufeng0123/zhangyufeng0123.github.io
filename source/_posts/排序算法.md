---
title: 排序算法
categories:
  - AcWing
tags:
  - 快速排序
  - 归并排序
abbrlink: '735e5788'
date: 2023-03-23 18:00:17
---
# 快速排序—分治

快排的步骤主要是下面三步：

1. 确定分界点：确认一个数，使他数组分类的分界点`x`，一般（区间最左端，区间最右端，区间中间，随机）四种挑一个
2. **调整区间**：将数组中比分界点小的数都移到分界点的左边，比分界点大的数都移到分界点右边
3. 递归处理左右两区间：递归处理区间直到没有区间可以处理，这样得到的数组就是一个有序数组

## 调整区间的方法一：开两个额外数组

1. `a[],b[]`
2. 将`q[l~r]`数组分类
    1. 如果数小于等于`x`，那么该数就放入`a`数组
    2. 如果数大于`x`，那么该数就放入`b`数组
3. 然后将`a`数组放入`q`中，再将`b`数组放入`q`中

这个方法的时间复杂度是 $O(n)$，因为只扫了两边数组，但是需要开辟额外的空间，空间复杂度是 $O(n)$.

## 调整区间的方法二：使用双指针

![](https://cdn.jsdelivr.net/gh/zhangyufeng0123/ImageHosting/img/20230323153230.png)

我们利用双指针i从前往后遍历，找到第一个大于x的值，然后将j指针从后往前遍历没找到第一个小于等于x的值，交换这俩个指针所指的值。重复操作，直到两指针相遇。

这样我们的时间复杂度还是 $O(n)$，但是我们的空间复杂度是 $O(1)$。比之前的方法好上不少。

## 练习题-**[785.快速排序](https://www.acwing.com/problem/content/description/787/)**

这道题很坑，卡你用左端点作为分界点，我用左端点作为分界点的时候一直Tle，换成中间点作为分界点就AC了。

如果这个数组本来就是有序数组，那么快排耗时就会比较高。

```cpp
#include<iostream>

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn];

void quick_sort(int nums[], int l, int r){
    if(l >= r) return;
    int target = nums[(l + r) >> 1];
    int i = l - 1, j = r + 1;
    while(i < j){
        do ++i; while(nums[i] < target);
        do --j; while(nums[j] > target);
        if(i < j) swap(nums[i], nums[j]);
    }
    quick_sort(nums, l, j);
    quick_sort(nums, j + 1, r);
}

int main(){
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        scanf("%d", &nums[i]);
    }
    quick_sort(nums, 0, n - 1);
    cout << nums[0];
    for(int i = 1; i < n; i++) cout << ' ' << nums[i];
    cout << endl;
    return 0;
}
```

### 快排的应用-**[786.第k个数](https://www.acwing.com/problem/content/788/)**

我们根据快排的原理能够很快的找到一个数在没有重复数字的数组中的位置，因此我们每当确立一个分界点的时候，我们先找到这个分界点的位置，如果该分界点的位置大于k，那么我们只要在分界点左边的数组中找即可，反之，我们在分界点的右边寻找。这样就能大大减少搜索范围。

```cpp
#include<iostream>

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn];
int k;

void quick_sort(int nums[], int l, int r){
    if(l >= r) return;
    int target = nums[(l + r) >> 1];
    int i = l - 1, j = r + 1;
    while(i < j){
        do ++i; while(nums[i] < target);
        do --j; while(nums[j] > target);
        if(i < j) swap(nums[i], nums[j]);
    }
    if(j >= k - 1) quick_sort(nums, l, j);
    else quick_sort(nums, j + 1, r);
}

int main(){
    int n;
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i++){
        scanf("%d", &nums[i]);
    }
    quick_sort(nums, 0, n - 1);
    printf("%d\n", nums[k - 1]);
}
```

# 归并排序—分治

归并排序的主要步骤是

1. 确定分界点。指索引分界点：mid = (right + left) >> 1;
2. 递归排序两个区间[left, mid],[mid + 1,right]。
3. 归并—合二为一

归并的具体操作：我们是先递归排序，这样两个区间都是有序的，那么我们合并两个区间的时候只要逐一获取两个区间的较小值即可。

每一轮的时间复杂度是 $O(n)$.因为一直是二分，那么说明递归层数有logn层，那么总时间复杂度是 $O(nlogn)$.

## 练习题—**[787.归并排序](https://www.acwing.com/problem/content/789/)**

```cpp
//模板题
#include<iostream>

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn];
int tmp[maxn];

void merge_sort(int nums[], int l, int r){
    if(l == r) return;
    int mid = (l + r) >> 1;
    merge_sort(nums, l, mid);
    merge_sort(nums, mid + 1, r);
    
    int i = l, j = mid + 1;
    int idx = 0;
    while(i <= mid && j <= r){
        if(nums[i] < nums[j]) tmp[idx++] = nums[i++];
        else tmp[idx++] = nums[j++];
    }
    while(i <= mid) tmp[idx++] = nums[i++];
    while(j <= r) tmp[idx++] = nums[j++];
    for(int i = 0; i < idx; i++){
        nums[l + i] = tmp[i];
    }
}

int main(){
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        scanf("%d", &nums[i]);
    }
    merge_sort(nums, 0, n - 1);
    printf("%d", nums[0]);
    for(int i = 1; i < n; i++){
        printf(" %d", nums[i]);
    }
    printf("\n");
    
    return 0;
}
```

## 归并的应用—[找逆序对的数量](https://www.acwing.com/problem/content/790/)

每次我们合并两个区间的时候，如果较前面的区间的数大于后面区间的数时，我们就对逆序对进行累加。

```cpp
#include<iostream>

using namespace std;

const int maxn = 1e5 + 10;
int nums[maxn], tmp[maxn];
long long ans = 0;

void merge_sort(int q[], int l, int r){
    if(l == r) return;
    int mid = (l + r) >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int idx = 0;
    int i = l, j = mid + 1;
    while(i <= mid && j <= r){
        if(q[i] > q[j]) {
            ans += (mid - i + 1);
            tmp[idx++] = q[j++];
        }else tmp[idx++] = q[i++];
    }
    while(i <= mid) tmp[idx++] = q[i++];
    while(j <= r) tmp[idx++] = q[j++];
    for(int i = 0; i < idx; i++) q[i + l] = tmp[i];
}

int main(){
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        scanf("%d", &nums[i]);
    }
    merge_sort(nums, 0, n - 1);
    printf("%lld\n", ans);
    return 0;
}
```